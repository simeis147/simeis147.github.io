const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/intro.html\":{\"title\":\"Chengpeng Dong\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"地球这样的行星，是产生不了重元素的，你身体里的铁，来自璀璨的超新星爆炸。\",\"血液里的锌，源自两次中子星对撞后喷射向宇宙的尘埃。\",\"那微量的铜，更是需要见证一颗白矮星的死亡，\",\"即使是最微不足道的钴，也源自几十亿光年外的星云。\",\"某种意义上讲，人类对星空怀有好奇，是正常的。\",\"渴望见证星河大海的极限，因为我们本就是星辰之子\"]},{\"header\":\"Education\",\"slug\":\"education\",\"contents\":[\"M.S. in Software Engineering, Hunan University\",\"2023-2025\",\"B.Eng. in Software Engineering, Guizhou University\",\"2018-2022\"]},{\"header\":\"Miscellaneous\",\"slug\":\"miscellaneous\",\"contents\":[\"🪧 Want to pass CET-6, so this resume is written in English\",\"🏂 May be an extreme sports enthusiasts in the future\",\"💪 Like fitness, computer peripherals, recently became obsessed with keyboards\",\"🧍‍♂️ Used to be a member of the Model team School of Computer Science and Computing, Guizhou University\",\"🏃‍♂️ Used to be a member of the track team of Guizhou University\",\"🔭 Childhood dream was to be an astronomer\"]}]},\"/slides.html\":{\"title\":\"幻灯片页\",\"contents\":[]},\"/demo/\":{\"title\":\"主要功能与配置演示\",\"contents\":[{\"header\":\"目录\",\"slug\":\"目录\",\"contents\":[\"页面展示\",\"禁用展示\"]}]},\"/demo/disable.html\":{\"title\":\"布局与功能禁用\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]}]},\"/demo/page.html\":{\"title\":\"页面配置\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"more 注释之前的内容被视为文章摘要。\"]},{\"header\":\"页面信息\",\"slug\":\"页面信息\",\"contents\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},{\"header\":\"页面内容\",\"slug\":\"页面内容\",\"contents\":[\"你可以自由在这里书写你的 Markdown。\",\"提示\",\"你可以将图片和 Markdown 文件放置在一起，但是你需要使用相对链接./ 进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\",\"主题包含了一个自定义徽章可以使用: \",\"文字结尾应该有深蓝色的 徽章文字 徽章。 \"]},{\"header\":\"页面结构\",\"slug\":\"页面结构\",\"contents\":[\"此页面应当包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"导航栏\",\"侧边栏\",\"页脚\",\"返回顶部按钮\",\"你可以通过主题选项和页面 Frontmatter 自定义它们。\"]}]},\"/BackEnd/JavaSE/Javase01.html\":{\"title\":\"Java基本语法\",\"contents\":[{\"header\":\"1 JAVA发展和JDK\",\"slug\":\"_1-java发展和jdk\",\"contents\":[]},{\"header\":\"1.1 Java语言背景了解\",\"slug\":\"_1-1-java语言背景了解\",\"contents\":[\"提示\",\"Java语言是美国Sun公司（Stanford University Network）在1995年推出的计算机语言\",\"Java之父：詹姆斯·高斯林（James Gosling）\",\"2009年，Sun公司被甲骨文公司收购\"]},{\"header\":\"1.2 Java的主要特性\",\"slug\":\"_1-2-java的主要特性\",\"contents\":[\"面向对象\",\"安全性\",\"多线程\",\"简单易用\",\"开源\",\"跨平台\"]},{\"header\":\"1.3 常见的CMD命令如下\",\"slug\":\"_1-3-常见的cmd命令如下\",\"contents\":[\"操作\",\"说明\",\"盘符名称:\",\"盘符切换。E:回车，表示切换到E盘。\",\"dir\",\"查看当前路径下的内容。\",\"cd 目录\",\"进入单级目录。cd javajdk\",\"cd ..\",\"回退到上一级目录。\",\"cd 目录1\\\\目录2\\\\...\",\"进入多级目录。cd javajdk\\\\jdk11\",\"cd \\\\\",\"回退到盘符目录。\",\"cls\",\"清屏。\",\"exit\",\"退出命令提示符窗口。\"]},{\"header\":\"1.4 JDK的目录介绍\",\"slug\":\"_1-4-jdk的目录介绍\",\"contents\":[\"目录名称\",\"说明\",\"bin\",\"该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。\",\"conf\",\"该路径下存放了JDK的相关配置文件。\",\"include\",\"该路径下存放了一些平台特定的头文件。\",\"jmods\",\"该路径下存放了JDK的各种模块。\",\"legal\",\"该路径下存放了JDK各模块的授权文档。\",\"lib\",\"该路径下存放了JDK工具的一些补充JAR包。\"]},{\"header\":\"1.5 JDK、JRE和JVM\",\"slug\":\"_1-5-jdk、jre和jvm\",\"contents\":[\"提示\",\"JVM（Java Virtual Machine），Java虚拟机\",\"JRE（Java Runtime Environment），Java运行环境，包含了JVM和Java的核心类库（Java API）\",\"JDK（Java Development Kit）称为Java开发工具，包含了JRE和开发工具\"]},{\"header\":\"2 JAVA基础语法\",\"slug\":\"_2-java基础语法\",\"contents\":[]},{\"header\":\"2.1 Java语言数据类型的分类\",\"slug\":\"_2-1-java语言数据类型的分类\",\"contents\":[\"基本数据类型\",\"引用数据类型（面向对象）\"]},{\"header\":\"2.2 基本数据类型的四类八种\",\"slug\":\"_2-2-基本数据类型的四类八种\",\"contents\":[\"数据类型\",\"关键字\",\"内存占用\",\"取值范围\",\"整数\",\"byte\",\"1\",\"-128~127\",\"short\",\"2\",\"-32768~32767\",\"int\",\"4\",\"-2147483648~2147483647\",\"long\",\"8\",\"-9223372036854775808~9223372036854775807\",\"浮点数\",\"float\",\"4\",\"1.401298e-45 ~ 3.402823e+38\",\"double\",\"8\",\"4.9000000e-324 ~ 1.797693e+308\",\"字符\",\"char\",\"2\",\"0-65535\",\"布尔\",\"boolean\",\"1\",\"true，false\",\"注意点：\",\"如果要定义一个long类型的变量，那么在数据值的后面需要加上L后缀。（建议大写）\",\"如果要定义一个float类型的变量，那么在数据值的后面需要加上F后缀。\"]},{\"header\":\"2.3 标识符\",\"slug\":\"_2-3-标识符\",\"contents\":[]},{\"header\":\"2.3.1 硬性要求\",\"slug\":\"_2-3-1-硬性要求\",\"contents\":[\"必须要这么做，否则代码会报错。\",\"必须由 数字、字母、下划线_、美元符号$ 组成。\",\"数字不能开头\",\"不能是关键字\",\"区分大小写的。\"]},{\"header\":\"2.3.2 软件建议\",\"slug\":\"_2-3-2-软件建议\",\"contents\":[\"​ 如果不这么做，代码不会报错，但是会让代码显得比较low。\",\"小驼峰命名法：\",\"适用于 变量名和方法名\",\"如果是一个单词，那么全部小写，比如：name\",\"如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge\",\"大驼峰命名法：\",\"适用于 类名\",\"如果是一个单词，那么首字母大写。比如：Demo、Test。\",\"如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld\",\"不管起什么名字，都要做到见名知意。\"]},{\"header\":\"3 运算符和表达式\",\"slug\":\"_3-运算符和表达式\",\"contents\":[]},{\"header\":\"3.1 两种提升规则\",\"slug\":\"_3-1-两种提升规则\",\"contents\":[\"取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。\",\"byte、short、char三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算。\"]},{\"header\":\"3.2 取值范围从小到大的关系\",\"slug\":\"_3-2-取值范围从小到大的关系\",\"contents\":[\"byte < short < int < long < float < double\"]},{\"header\":\"3.3 强制转换\",\"slug\":\"_3-3-强制转换\",\"contents\":[\"目标数据类型 变量名 = （目标数据类型）被强转的数据；\",\"double sum = (int) 100.99;\",\"强制转换有可能会导致数据发生错误。（数据的精度丢失）\"]},{\"header\":\"3.4 扩展赋值运算符\",\"slug\":\"_3-4-扩展赋值运算符\",\"contents\":[\"注意点: 扩展的赋值运算符中隐层还包含了一个强制转换。\",\"a += b; 实际上相当于 a = (byte)(a + b);\",\"public class OperatorDemo8 { public static void main(String[] args) { byte a = 10; byte b = 20; //a += b; a = (byte)(a + b); System.out.println(a);//30 } } \"]},{\"header\":\"4 流程控制语句\",\"slug\":\"_4-流程控制语句\",\"contents\":[]},{\"header\":\"4.1 switch的扩展知识\",\"slug\":\"_4-1-switch的扩展知识\",\"contents\":[\"default的位置和省略情况\",\"default可以放在任意位置，也可以省略\",\"case穿透\",\"不写break会引发case穿透现象\",\"switch在JDK12的新特性：\",\"int number = 10; switch (number) { case 1 -> System.out.println(\\\"一\\\"); case 2 -> System.out.println(\\\"二\\\"); case 3 -> System.out.println(\\\"三\\\"); default -> System.out.println(\\\"其他\\\"); } \",\"switch和if的使用场景：\",\"当我们需要对一个范围进行判断的时候，用if\",\"当我们把有限个数据列举出来，选择其中一个执行的时候，用switch语句\",\"比如：\",\"小明的考试成绩，如果用switch，那么需要写100个case，太麻烦了，所以用if简单。\",\"如果是星期，月份，客服电话中0~9的功能选择就可以用switch\",\"代码示例：\",\"//1.键盘录入星期数 Scanner sc = new Scanner(System.in); System.out.println(\\\"请输入星期\\\"); int week = sc.nextInt();//3 //2.利用switch进行匹配 ---------------------------------------------------- 利用case穿透简化代码 switch (week){ case 1: case 2: case 3: case 4: case 5: System.out.println(\\\"工作日\\\"); break; case 6: case 7: System.out.println(\\\"休息日\\\"); break; default: System.out.println(\\\"没有这个星期\\\"); break; } ---------------------------------------------------- 利用JDK12简化代码书写 switch (week) { case 1, 2, 3, 4, 5 -> System.out.println(\\\"工作日\\\"); case 6, 7 -> System.out.println(\\\"休息日\\\"); default -> System.out.println(\\\"没有这个星期\\\"); } \"]},{\"header\":\"4.2 三种循环结构的区别\",\"slug\":\"_4-2-三种循环结构的区别\",\"contents\":[\"for和while循环，是先判断，再执行。\",\"​do...while是先执行，再判断。\",\"​当知道循环次数或者循环范围的时候，用for循环。\",\"​当不知道循环次数，也不知道循环范围，但是知道循环的结束条件时，用while循环\"]},{\"header\":\"5 数组\",\"slug\":\"_5-数组\",\"contents\":[\"数组一旦创建之后，长度不能发生变化。\"]},{\"header\":\"5.1 完整格式\",\"slug\":\"_5-1-完整格式\",\"contents\":[\"数据类型[ ] 数组名 = new 数据类型[ ]{元素1，元素2，元素3，元素4...};\",\"int[ ] arr = new int[ ]{11,22,33};\",\"double[ ] arr = new double[ ]{1.1,1.2,1.3};\",\"string[ ] arr = new String[ ]{\\\"aaa\\\",\\\"bbb\\\",\\\"ccc\\\"};\"]},{\"header\":\"5.2 数组的动态初始化\",\"slug\":\"_5-2-数组的动态初始化\",\"contents\":[\"格式：\",\"数据类型[] 数组名 = new 数据类型[数组的长度];\",\"举例：\",\"//1.定义一个数组，存3个人的年龄，年龄未知 int[] agesArr = new int[3]; //2.定义一个数组，存班级10名学生的考试成绩，考试成绩暂时未知，考完才知道。 int[] scoresArr = new int[10]; \",\"数组的默认初始化值：\",\"整数类型：0\",\"小数类型：0.0\",\"布尔类型：false\",\"字符类型：'\\\\u0000'\",\"引用类型：null\"]},{\"header\":\"6 方法\",\"slug\":\"_6-方法\",\"contents\":[\"方法（method）是程序中最小的执行单元\"]},{\"header\":\"6.1 方法重载\",\"slug\":\"_6-1-方法重载\",\"contents\":[\"概念：\",\"指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载\",\"多个方法在同一个类中\",\"多个方法具有相同的方法名\",\"多个方法的参数不相同，类型不同或者数量不同\",\"注意：\",\"重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式\",\"重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载\",\"正确范例：\",\" public class MethodDemo { public static void fn(int a) { //方法体 } public static int fn(double a) { //方法体 } } public class MethodDemo { public static float fn(int a) { //方法体 } public static int fn(int a , int b) { //方法体 } } \",\"错误范例：\",\" public class MethodDemo { public static void fn(int a) { //方法体 } public static int fn(int a) { /*错误原因：重载与返回值无关*/ //方法体 } } public class MethodDemo01 { public static void fn(int a) { //方法体 } } public class MethodDemo02 { public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/ //方法体 } } \"]},{\"header\":\"7 综合练习\",\"slug\":\"_7-综合练习\",\"contents\":[]},{\"header\":\"练习一：双色球\",\"slug\":\"练习一-双色球\",\"contents\":[\"双色球\",\"代码示例:\",\"package com.demo.test; import java.util.Random; import java.util.Scanner; public class Test1 { public static void main(String[] args) { //1.生成中奖号码 int[] arr = createNumber(); // 123456 7 System.out.println(\\\"=======================\\\"); for (int i = 0; i < arr.length; i++) { System.out.print(arr[i] + \\\" \\\"); } System.out.println(\\\"=======================\\\"); //2.用户输入彩票号码（红球 + 蓝球）//654321 int[] userInputArr = userInputNumber(); //3.判断用户的中奖情况 //红球 蓝球 int redCount = 0; int blueCount = 0; //判断红球 for (int i = 0; i < userInputArr.length - 1; i++) { int redNumber = userInputArr[i]; for (int j = 0; j < arr.length - 1; j++) { if(redNumber == arr[j]){ redCount++; //如果找到了，那么后面的数字就没有必要继续比较了 //跳出内循环，继续判断下一个红球号码是否中奖 break; } } } //判断蓝球 int blueNumber = userInputArr[userInputArr.length-1]; if(blueNumber == arr[arr.length - 1]){ blueCount++; } //根据红球的个数以及蓝球的个数来判断中奖情况 if(redCount == 6 && blueCount == 1){ System.out.println(\\\"恭喜你，中奖1000万\\\"); }else if(redCount == 6 && blueCount == 0){ System.out.println(\\\"恭喜你，中奖500万\\\"); }else if(redCount == 5 && blueCount == 1){ System.out.println(\\\"恭喜你，中奖3000\\\"); }else if((redCount == 5 && blueCount == 0) || (redCount == 4 && blueCount == 1)){ System.out.println(\\\"恭喜你，中奖200\\\"); }else if((redCount == 4 && blueCount == 0) || (redCount == 3 && blueCount == 1)){ System.out.println(\\\"恭喜你，中奖10\\\"); }else if((redCount == 2 && blueCount == 1) || (redCount == 1 && blueCount == 1)|| (redCount == 0 && blueCount == 1)){ System.out.println(\\\"恭喜你，中奖5\\\"); }else{ System.out.println(\\\"谢谢参与，谢谢惠顾\\\"); } } public static int[] userInputNumber() { //1.创建数组用于添加用户购买的彩票号码 //6个红球 1个蓝球 数组长度：7 int[] arr = new int[7]; //2.利用键盘录入让用户输入 Scanner sc = new Scanner(System.in); //让用户输入红球号码 for (int i = 0; i < 6; ) { System.out.println(\\\"请输入第\\\" + (i + 1) + \\\"个红球号码\\\"); int redNumber = sc.nextInt(); //redNumber 在1~33 唯一不重复 if (redNumber >= 1 && redNumber <= 33) { boolean flag = contains(arr, redNumber); if (!flag) { //不存在 //有效的，可以添加到数组当中 arr[i] = redNumber; i++; } else { //存在 System.out.println(\\\"当前红球号码已经存在，请重新输入\\\"); } } else { System.out.println(\\\"当前红球号码超出范围\\\"); } } //让用户输入篮球号码 System.out.println(\\\"请输入篮球号码\\\"); //1~16 while (true) { int blueNumber = sc.nextInt(); if (blueNumber >= 1 && blueNumber <= 16) { arr[arr.length - 1] = blueNumber; break; } else { System.out.println(\\\"当前篮球号码超出范围\\\"); } } return arr; } public static int[] createNumber() { //1.创建数组用于添加中奖号码 //6个红球 1个蓝球 数组长度：7 int[] arr = new int[7]; //2.随机生成号码并添加到数组当中 //红球：不能重复的 1 2 3 4 5 6 //蓝球：可以跟红球号码重复 7 //生成红球号码并添加到数组当中 Random r = new Random(); for (int i = 0; i < 6; ) { //获取红球号码 int redNumber = r.nextInt(33) + 1; boolean flag = contains(arr, redNumber); if (!flag) { //把红球号码添加到数组当中 arr[i] = redNumber; i++; } } //生成蓝球号码并添加到数组当中 int blueNumber = r.nextInt(16) + 1; arr[arr.length - 1] = blueNumber; return arr; } //用于判断数组在数组中是否存在 public static boolean contains(int[] arr, int number) { for (int i = 0; i < arr.length; i++) { if (arr[i] == number) { return true; } } return false; } } \"]},{\"header\":\"练习二：整数存数组\",\"slug\":\"练习二-整数存数组\",\"contents\":[\"package com.demo.test; public class Test2 { public static void main(String[] args) { //需求： //把整数上的每一位都添加到数组当中 //反向推导 //1.计算出数组的长度 int number = 12345; //定义一个变量临时记录number的值，就是为了第三步的时候再次使用 int temp = number; //定义一个变量进行统计 int count = 0; while(number != 0){ //每一次循环就去掉右边的一个数字 number = number / 10; //去掉一位计数器就自增一次。 count++; } //2.定义数组 //动态初始化 int[] arr = new int[count]; //3.把整数上的每一位都添加到数组当中 int index = arr.length -1; while(temp != 0){//12345 //获取temp里面的每一位数组 int ge = temp % 10; //再去掉右边的那位数字 temp = temp / 10; //把当前获取到的个位添加到数组当中 arr[index] = ge; index--; } //验证结果 1 2 3 4 5 for (int i = 0; i < arr.length; i++) { System.out.print(arr[i] + \\\" \\\"); } } } \"]},{\"header\":\"练习三：验证码\",\"slug\":\"练习三-验证码\",\"contents\":[\"package com.demo.test; import java.util.Random; public class Test3 { public static void main(String[] args) { /* 需求：定义方法实现随机产生一个5位的验证码 验证码格式： 长度为5 前四位是大写字母或者小写字母 最后一位是数字 */ //1.大写字母和小写字母都放到数组当中 char[] chs = new char[52]; for (int i = 0; i < chs.length; i++) { if(i <= 25){ chs[i] = (char)(97 + i); }else{ chs[i] = (char)(65 + i - 26); } } String result = \\\"\\\"; //2.随机抽取4次 Random r = new Random(); for (int i = 0; i < 4; i++) { int randomIndex = r.nextInt(chs.length); result = result + chs[randomIndex]; } //3.随机抽取一个数字0~9 int number = r.nextInt(10); result = result + number; System.out.println(result); } } \"]}]},\"/BackEnd/JavaSE/Javase02.html\":{\"title\":\"Java面向对象\",\"contents\":[{\"header\":\"8 类和对象\",\"slug\":\"_8-类和对象\",\"contents\":[]},{\"header\":\"8.1 类和对象的理解\",\"slug\":\"_8-1-类和对象的理解\",\"contents\":[\"类：类是对现实生活中一类具有共同属性和行为的事物的抽象\",\"对象：客观存在的事物皆为对象 ，所以我们也常常说万物皆对象。\",\"简单理解：类是对事物的一种描述，对象则为具体存在的事物\"]},{\"header\":\"8.2 类的定义\",\"slug\":\"_8-2-类的定义\",\"contents\":[\"类的组成是由属性和行为两部分组成\",\"属性：在类中通过成员变量来体现（类中方法外的变量）\",\"行为：在类中通过成员方法来体现（和方法相比去掉static关键字即可）\"]},{\"header\":\"8.3 对象内存图\",\"slug\":\"_8-3-对象内存图\",\"contents\":[]},{\"header\":\"单个对象内存图\",\"slug\":\"单个对象内存图\",\"contents\":[\"831\"]},{\"header\":\"多个对象内存图\",\"slug\":\"多个对象内存图\",\"contents\":[\"832\",\"总结：\",\"多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用一份。\"]},{\"header\":\"8.4 this内存原理\",\"slug\":\"_8-4-this内存原理\",\"contents\":[\"注意 : this代表当前调用方法的引用，哪个对象调用的方法，this就代表哪一个对象\",\"图解 ：\",\"841\",\"842\"]},{\"header\":\"8.5 封装思想\",\"slug\":\"_8-5-封装思想\",\"contents\":[\"封装概述\",\"是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界是无法直接操作的对象代表什么，就得封装对应的数据，并提供数据对应的行为\",\"封装原则\",\"将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 成员变量private，提供对应的getXxx()/setXxx()方法\",\"封装好处\",\"通过方法来控制成员变量的操作，提高了代码的安全性 把代码用方法进行封装，提高了代码的复用性\"]},{\"header\":\"9 面对对象综合练习\",\"slug\":\"_9-面对对象综合练习\",\"contents\":[]},{\"header\":\"练习一：文字版格斗游戏\",\"slug\":\"练习一-文字版格斗游戏\",\"contents\":[\"需求: 格斗游戏，每个游戏角色的姓名，血量，都不相同，在选定人物的时候（new对象的时候），这些信息就应该被确定下来。\",\"举例：\",\"程序运行之后结果为：\",\"姓名为:乔峰 血量为:100\",\"姓名为:鸠摩智 血量为:100\",\"乔峰举起拳头打了鸠摩智一下，造成了XX点伤害，鸠摩智还剩下XXX点血。\",\"鸠摩智举起拳头打了鸠摩智一下，造成了XX点伤害，乔峰还剩下XXX点血。\",\"乔峰举起拳头打了鸠摩智一下，造成了XX点伤害，鸠摩智还剩下XXX点血。\",\"鸠摩智举起拳头打了鸠摩智一下，造成了XX点伤害，乔峰还剩下XXX点血。\",\"乔峰K.O.了鸠摩智\",\"代码示例：\",\"public class GameTest { public static void main(String[] args) { Role r1 = new Role(\\\"乔峰\\\",100); Role r2 = new Role(\\\"鸠摩智\\\",100); while(true){ r1.attack(r2); if(r2.getBlood() == 0){ System.out.println(r1.getName() + \\\" K.O了\\\" + r2.getName()); break; } r2.attack(r1); if(r1.getBlood() == 0){ System.out.println(r2.getName() + \\\" K.O了\\\" + r1.getName()); break; } } } } public class Role { private String name; private int blood; public Role() { } public Role(String name, int blood) { this.name = name; this.blood = blood; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getBlood() { return blood; } public void setBlood(int blood) { this.blood = blood; } public void attack(Role role) { Random r = new Random(); int hurt = r.nextInt(20) + 1; int remainBoold = role.getBlood() - hurt; remainBoold = remainBoold < 0 ? 0 : remainBoold; role.setBlood(remainBoold); System.out.println(this.getName() + \\\"举起拳头，打了\\\" + role.getName() + \\\"一下，\\\" + \\\"造成了\\\" + hurt + \\\"点伤害，\\\" + role.getName() + \\\"还剩下了\\\" + remainBoold + \\\"点血\\\"); } } \"]},{\"header\":\"练习二：复杂的对象数组操作\",\"slug\":\"练习二-复杂的对象数组操作\",\"contents\":[\"定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。\",\"学生的属性：学号，姓名，年龄。\",\"要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。\",\"要求2：添加完毕之后，遍历所有学生信息。\",\"要求3：通过id删除学生信息\",\"如果存在，则删除，如果不存在，则提示删除失败。\",\"要求4：删除完毕之后，遍历所有学生信息。\",\"要求5：查询数组id为“Student002”的学生，如果存在，则将他的年龄+1岁\",\"代码示例：\",\" public class Student { private int id; private String name; private int age; public Student() { } public Student(int id, String name, int age) { this.id = id; this.name = name; this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } \",\"public class Test { public static void main(String[] args) { /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。 学生的属性：学号，姓名，年龄。 要求1：再次添加一个学生对象，并在添加的时候进行学号的唯一性判断。 要求2：添加完毕之后，遍历所有学生信息。 */ Student[] arr = new Student[3]; Student stu1 = new Student(1, \\\"zhangsan\\\", 23); Student stu2 = new Student(2, \\\"lisi\\\", 24); arr[0] = stu1; arr[1] = stu2; Student stu4 = new Student(1, \\\"zhaoliu\\\", 26); boolean flag = contains(arr, stu4.getId()); if(flag){ System.out.println(\\\"当前id重复，请修改id后再进行添加\\\"); }else{ int count = getCount(arr); if(count == arr.length){ Student[] newArr = creatNewArr(arr); newArr[count] = stu4; printArr(newArr); }else{ arr[count] = stu4; printArr(arr); } } } public static void printArr(Student[] arr){ for (int i = 0; i < arr.length; i++) { Student stu = arr[i]; if(stu != null){ System.out.println(stu.getId() + \\\", \\\" + stu.getName() + \\\", \\\" + stu.getAge()); } } } public static Student[] creatNewArr(Student[] arr){ Student[] newArr = new Student[arr.length + 1]; for (int i = 0; i < arr.length; i++) { newArr[i] = arr[i]; } return newArr; } public static int getCount(Student[] arr){ int count = 0; for (int i = 0; i < arr.length; i++) { if(arr[i] != null){ count++; } } return count; } public static boolean contains(Student[] arr, int id) { for (int i = 0; i < arr.length; i++) { Student stu = arr[i]; if(stu != null){ int sid = stu.getId(); //比较 if(sid == id){ return true; } } } return false; } } \",\"public class Test3 { public static void main(String[] args) { /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。 学生的属性：学号，姓名，年龄。 要求3：通过id删除学生信息 如果存在，则删除，如果不存在，则提示删除失败。 要求4：删除完毕之后，遍历所有学生信息。 */ Student[] arr = new Student[3]; Student stu1 = new Student(1, \\\"zhangsan\\\", 23); Student stu2 = new Student(2, \\\"lisi\\\", 24); Student stu3 = new Student(3, \\\"wangwu\\\", 25); arr[0] = stu1; arr[1] = stu2; arr[2] = stu3; int index = getIndex(arr, 2); if (index >= 0){ arr[index] = null; printArr(arr); }else{ System.out.println(\\\"当前id不存在，删除失败\\\"); } } public static int getIndex(Student[] arr , int id){ for (int i = 0; i < arr.length; i++) { Student stu = arr[i]; if(stu != null){ int sid = stu.getId(); if(sid == id){ return i; } } } return -1; } public static void printArr(Student[] arr){ for (int i = 0; i < arr.length; i++) { Student stu = arr[i]; if(stu != null){ System.out.println(stu.getId() + \\\", \\\" + stu.getName() + \\\", \\\" + stu.getAge()); } } } } \",\" public class Test4 { public static void main(String[] args) { /*定义一个长度为3的数组，数组存储1~3名学生对象作为初始数据，学生对象的学号，姓名各不相同。 学生的属性：学号，姓名，年龄。 要求5：查询数组id为“2”的学生，如果存在，则将他的年龄+1岁*/ Student[] arr = new Student[3]; Student stu1 = new Student(1, \\\"zhangsan\\\", 23); Student stu2 = new Student(2, \\\"lisi\\\", 24); Student stu3 = new Student(3, \\\"wangwu\\\", 25); arr[0] = stu1; arr[1] = stu2; arr[2] = stu3; int index = getIndex(arr, 2); if(index >= 0){ Student stu = arr[index]; int newAge = stu.getAge() + 1; stu.setAge(newAge); printArr(arr); }else{ System.out.println(\\\"当前id不存在，修改失败\\\"); } } public static int getIndex(Student[] arr , int id){ for (int i = 0; i < arr.length; i++) { Student stu = arr[i]; if(stu != null){ int sid = stu.getId(); if(sid == id){ return i; } } } return -1; } public static void printArr(Student[] arr){ for (int i = 0; i < arr.length; i++) { Student stu = arr[i]; if(stu != null){ System.out.println(stu.getId() + \\\", \\\" + stu.getName() + \\\", \\\" + stu.getAge()); } } } } \"]},{\"header\":\"10 static关键字、继承\",\"slug\":\"_10-static关键字、继承\",\"contents\":[]},{\"header\":\"10.1 static关键字\",\"slug\":\"_10-1-static关键字\",\"contents\":[\"Java中成员（变量和方法）等是存在所属性的，Java是通过static关键字来区分的。static关键字在Java开发非常的重要，对于理解面向对象非常关键。\",\"关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是属于类的，放在静态区中，没有static修饰的成员变量和方法则是属于对象的。\"]},{\"header\":\"10.1.1 定义格式和使用\",\"slug\":\"_10-1-1-定义格式和使用\",\"contents\":[\"static是静态的意思。 static可以修成员变量或者修饰方法。\"]},{\"header\":\"静态变量及其访问\",\"slug\":\"静态变量及其访问\",\"contents\":[\"public class Student { public static String schoolName = \\\"贵州大学\\\"； // 属于类，只有一份。 // ..... } \"]},{\"header\":\"格式：类名.静态变量\",\"slug\":\"格式-类名-静态变量\",\"contents\":[\"public static void main(String[] args){ System.out.println(Student.schoolName); // 贵州大学 Student.schoolName = \\\"湖南大学\\\"; System.out.println(Student.schoolName); // 湖南大学 } \"]},{\"header\":\"静态方法及其访问\",\"slug\":\"静态方法及其访问\",\"contents\":[\"public class Student{ public static String schoolName = \\\"贵州大学\\\"； // 属于类，只有一份。 // ..... public static void study(){ System.out.println(\\\"我们都在学习\\\"); } } \"]},{\"header\":\"格式：类名.静态方法\",\"slug\":\"格式-类名-静态方法\",\"contents\":[\"public static void main(String[] args){ Student.study(); } \"]},{\"header\":\"10.1.2 总结\",\"slug\":\"_10-1-2-总结\",\"contents\":[\"当 static 修饰成员变量或者成员方法时，该变量称为静态变量，该方法称为静态方法。该类的每个对象都共享同一个类的静态变量和静态方法。\",\"无static修饰的成员变量或者成员方法，称为实例变量，实例方法，实例变量和实例方法必须创建类的对象，然后通过对象来访问。\",\"static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。\",\"无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。\"]},{\"header\":\"10.2 继承\",\"slug\":\"_10-2-继承\",\"contents\":[\"继承：就是子类继承父类的属性和行为，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。\",\"继承的好处：\",\"提高代码的复用性（减少代码冗余，相同代码重复利用）。\",\"使类与类之间产生了关系。\",\"继承的格式：\",\"通过 extends 关键字，可以声明一个子类继承另外一个父类\",\"class 父类 { ... } class 子类 extends 父类 { ... } \",\"注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。\",\"顶层父类是Object类。\"]},{\"header\":\"10.2.1 子类不能继承的内容\",\"slug\":\"_10-2-1-子类不能继承的内容\",\"contents\":[\"子类不能继承父类的构造方法。 值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter/setter方法访问父类的private成员变量。\"]},{\"header\":\"10.2.2 super访问父类成员变量\",\"slug\":\"_10-2-2-super访问父类成员变量\",\"contents\":[\"子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量，类似于之前学过的 this 。\",\"需要注意的是：super代表的是父类对象的引用，this代表的是当前对象的引用。\"]},{\"header\":\"10.2.3 方法重写\",\"slug\":\"_10-2-3-方法重写\",\"contents\":[\"子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。\"]},{\"header\":\"@Override重写注解\",\"slug\":\"override重写注解\",\"contents\":[\"@Override: 注解，重写注解校验！\",\"这个注解标记的方法，就说明这个方法必须是重写父类的方法，否则编译阶段报错。\",\"注意：子类方法覆盖父类方法，必须要保证权限大于等于父类权限。\"]},{\"header\":\"10.2.4 super(...)案例图解\",\"slug\":\"_10-2-4-super-案例图解\",\"contents\":[\"父类空间优先于子类对象产生：\",\"在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造调用时，一定先调用父类的构造方法。理解图解如下：\",\"super(...)案例图解\"]},{\"header\":\"10.2.5 小结\",\"slug\":\"_10-2-5-小结\",\"contents\":[\"子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。\",\"super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。\",\"super(..)和this(...)是根据参数去确定调用父类哪个构造方法的。\",\"super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。\",\"this(..)可以调用本类中的其他构造方法。\"]},{\"header\":\"11 多态、包、final、权限修饰符、代码块\",\"slug\":\"_11-多态、包、final、权限修饰符、代码块\",\"contents\":[]},{\"header\":\"11.1 多态\",\"slug\":\"_11-1-多态\",\"contents\":[\"多态是出现在继承或者实现关系中的。\",\"多态体现的格式\",\"父类类型 变量名 = new 子类/实现类构造器; 变量名.方法名();\",\"多态的前提：有继承关系，子类对象是可以赋值给父类类型的变量。 例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。\",\"值得注意的是:\",\"当一个方法的形参是一个类，我们可以传递这个类所有的子类对象。 当一个方法的形参是一个接口，我们可以传递这个接口所有的实现类对象 而且多态还可以根据传递的不同对象来调用不同类中的方法\"]},{\"header\":\"11.1.1 多态的定义、运行特点\",\"slug\":\"_11-1-1-多态的定义、运行特点\",\"contents\":[\"多态： 是指同一行为，具有多个不同表现形式。\",\"调用成员变量时：编译看左边，运行看左边 调用成员方法时：编译看左边，运行看右边\",\"代码示例：\",\" Fu f = new Zi()； //编译看左边的父类中有没有name这个属性，没有就报错 //在实际运行的时候，把父类name属性的值打印出来 System.out.println(f.name); //编译看左边的父类中有没有show这个方法，没有就报错 //在实际运行的时候，运行的是子类中的show方法 f.show(); \"]},{\"header\":\"11.1.2 多态的弊端、引用类型转换\",\"slug\":\"_11-1-2-多态的弊端、引用类型转换\",\"contents\":[\"多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时多态的写法就无法访问子类独有功能了。\",\"向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。 一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。\",\"使用格式：\",\"子类类型 变量名 = (子类类型) 父类变量名; 如: Aniaml a = new Cat(); Cat c = (Cat) a; \",\"instanceof 关键字:\",\"为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：\",\"变量名 instanceof 数据类型 如果变量属于该数据类型或者其子类类型，返回true。 如果变量不属于该数据类型或者其子类类型，返回false。 \",\"所以，转换前，最好先做一个判断，代码如下：\",\"public class Test { public static void main(String[] args) { // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat){ Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse } else if (a instanceof Dog){ Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse } } } \",\"JDK14的时候提出了新特性，把判断和强转合并成了一行\",\"//先判断a是否为Dog类型，如果是，则强转成Dog类型，转换之后变量名为d if(a instanceof Dog d){ d.lookHome(); }else if(a instanceof Cat c){ c.catchMouse(); }else{ System.out.println(\\\"没有这个类型，无法转换\\\"); } \"]},{\"header\":\"11.2 包\",\"slug\":\"_11-2-包\",\"contents\":[\"包在操作系统中其实就是一个文件夹。包是用来分门别类的管理技术，不同的技术类放在不同的包下，方便管理和维护。\",\"包名一般是公司域名的倒写。例如：百度是 www.baidu.com ,包名就可以定义成com.baidu.技术名称。\",\"包名必须用”.“连接。\",\"包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。\"]},{\"header\":\"11.3 权限修饰符\",\"slug\":\"_11-3-权限修饰符\",\"contents\":[\"public：公共的，所有地方都可以访问。\",\"protected：本类 ，本包，其他包中的子类都可以访问。\",\"默认（没有修饰符）：本类 ，本包可以访问。\",\"private：私有的，当前类可以访问。\",\"不同权限的访问能力:\",\"public\",\"protected\",\"默认\",\"private\",\"同一类中\",\"√\",\"√\",\"√\",\"√\",\"同一包中的类\",\"√\",\"√\",\"√\",\"不同包的子类\",\"√\",\"√\",\"不同包中的无关类\",\"√\",\"编写代码时，如果没有特殊的考虑，建议这样使用权限：\",\"成员变量使用 private ，隐藏细节。\",\"构造方法使用 public ，方便创建对象。\",\"成员方法使用 public ，方便调用方法。\"]},{\"header\":\"11.4 final关键字\",\"slug\":\"_11-4-final关键字\",\"contents\":[\"Java提供了 final 关键字，表示修饰的内容不可变。\",\"final： 不可改变，最终的含义。可以用于修饰类、方法和变量。\",\"类：被修饰的类，不能被继承。\",\"方法：被修饰的方法，不能被重写。\",\"变量：被修饰的变量，有且仅能被赋值一次。\",\"被final修饰的常量名称，一般都有书写规范，所有字母都大写。\"]},{\"header\":\"12 抽象类、接口\",\"slug\":\"_12-抽象类、接口\",\"contents\":[]},{\"header\":\"12.1 抽象类\",\"slug\":\"_12-1-抽象类\",\"contents\":[\"abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。\"]},{\"header\":\"12.1.1 抽象类的使用\",\"slug\":\"_12-1-1-抽象类的使用\",\"contents\":[\"要求：继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。\",\"代码举例：\",\"// 父类,抽象类 abstract class Employee { private String id; private String name; private double salary; public Employee() { } public Employee(String id, String name, double salary) { this.id = id; this.name = name; this.salary = salary; } // 抽象方法 // 抽象方法必须要放在抽象类中 abstract public void work(); } // 定义一个子类继承抽象类 class Manager extends Employee { public Manager() { } public Manager(String id, String name, double salary) { super(id, name, salary); } @Override public void work() { System.out.println(\\\"管理其他人\\\"); } } // 定义一个子类继承抽象类 class Cook extends Employee { public Cook() { } public Cook(String id, String name, double salary) { super(id, name, salary); } @Override public void work() { System.out.println(\\\"厨师炒菜多加点盐...\\\"); } } // 测试类 public class Demo10 { public static void main(String[] args) { // 创建抽象类,抽象类不能创建对象 // 假设抽象类让我们创建对象,里面的抽象方法没有方法体 // Employee e = new Employee(); // e.work(); Manager m = new Manager(); m.work(); Cook c = new Cook(\\\"ap002\\\", \\\"库克\\\", 1); c.work(); } \",\"此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做实现方法。\"]},{\"header\":\"12.1.2 抽象类的特征\",\"slug\":\"_12-1-2-抽象类的特征\",\"contents\":[\"抽象类的特征总结起来可以说是 有得有失\",\"有得：抽象类得到了拥有抽象方法的能力。\",\"有失：抽象类失去了创建对象的能力。\",\"其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。\"]},{\"header\":\"12.1.3 抽象类的细节\",\"slug\":\"_12-1-3-抽象类的细节\",\"contents\":[\"抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。\",\"理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。\",\"抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。\",\"理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。\",\"抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\",\"理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。\",\"抽象类的子类，必须重写抽象父类中所有的抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。\",\"理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。\",\"抽象类存在的意义是为了被子类继承。\",\"理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。\"]},{\"header\":\"12.2 接口\",\"slug\":\"_12-2-接口\",\"contents\":[\"接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的。\",\"定义格式：\",\"interface 接口名称{ // 抽象方法 } \",\"接口中的抽象方法默认会自动加上 public abstract 修饰。 接口中定义的成员变量默认会加上 public static final 修饰。\",\"案例演示：\",\"public interface InterF { // public abstract void run(); void run(); // public abstract String getName(); String getName(); // public abstract int add(int a , int b); int add(int a , int b); // public static final int AGE = 12 ; int AGE = 12; //常量 String SCHOOL_NAME = \\\"黑马程序员\\\"; } \"]},{\"header\":\"12.2.1 基本的实现\",\"slug\":\"_12-2-1-基本的实现\",\"contents\":[\"类与接口的关系为实现关系，即类实现接口，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 implements 关键字。\",\"class 类名 implements 接口1,接口2,接口3...{ } \"]},{\"header\":\"12.2.2 类实现接口的要求和意义\",\"slug\":\"_12-2-2-类实现接口的要求和意义\",\"contents\":[\"必须重写实现的全部接口中所有抽象方法。\",\"如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。\",\"意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。\"]},{\"header\":\"12.2.3 类与接口的多实现案例\",\"slug\":\"_12-2-3-类与接口的多实现案例\",\"contents\":[\"类与接口之间的关系是多实现的，一个类可以同时实现多个接口。\",\"首先我们先定义两个接口，代码如下：\",\"/** 法律规范：接口*/ public interface Law { void rule(); } /** 这一个运动员的规范：接口*/ public interface SportMan { void run(); } \",\"然后定义一个实现类：\",\"public class JumpMan implements Law ,SportMan { @Override public void rule() { System.out.println(\\\"尊长守法\\\"); } @Override public void run() { System.out.println(\\\"训练跑步！\\\"); } } \",\"从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。\"]},{\"header\":\"12.2.4 接口与接口的多继承\",\"slug\":\"_12-2-4-接口与接口的多继承\",\"contents\":[\"Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。\",\"值得注意的是：\",\"类与接口是实现关系\",\"接口与接口是继承关系\",\"接口继承接口就是把其他接口的抽象方法与本接口进行了合并。\",\"案例演示：\",\"public interface Abc { void go(); void test(); } /* 法律规范：接口*/ public interface Law { void rule(); void test(); } /* * 总结： * 接口与类之间是多实现的。 * 接口与接口之间是多继承的。 * */ public interface SportMan extends Law , Abc { void run(); } \"]},{\"header\":\"12.2.5 扩展：接口的细节\",\"slug\":\"_12-2-5-扩展-接口的细节\",\"contents\":[\"当两个接口中存在相同抽象方法的时候，该怎么办？\",\"只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。\",\"实现类能不能继承A类的时候，同时实现其他接口呢？\",\"继承的父类，就好比是亲爸爸一样 实现的接口，就好比是干爹一样 可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。\",\"实现类能不能继承一个抽象类的时候，同时实现其他接口呢？\",\"实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。\",\"实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？\",\"处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。 处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。\",\"如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?\",\"可以在接口跟实现类中间，新建一个中间类（适配器类）\\n让这个适配器类去实现接口，对接口里面的所有的方法做空重写。\\n让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。\\n因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象\"]}]},\"/BackEnd/JavaSE/Javase03.html\":{\"title\":\"Java基础API\",\"contents\":[{\"header\":\"13 基础API\",\"slug\":\"_13-基础api\",\"contents\":[]},{\"header\":\"13.1 API概述\",\"slug\":\"_13-1-api概述\",\"contents\":[\"什么是API\",\"API (Application Programming Interface) ：应用程序编程接口\",\"java中的API\",\"指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。\"]},{\"header\":\"13.2 String类\",\"slug\":\"_13-2-string类\",\"contents\":[\"常用的构造方法\",\"方法名\",\"说明\",\"public String()\",\"创建一个空白字符串对象，不含有任何内容\",\"public String(char[] chs)\",\"根据字符数组的内容，来创建字符串对象\",\"public String(byte[] bys)\",\"根据字节数组的内容，来创建字符串对象\",\"String s = “abc”;\",\"直接赋值的方式创建字符串对象，内容就是abc\"]},{\"header\":\"创建字符串对象两种方式的区别\",\"slug\":\"创建字符串对象两种方式的区别\",\"contents\":[\"通过构造方法创建\",\"通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同\",\"直接赋值方式创建\",\"以“ ”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护\"]},{\"header\":\"字符串的比较\",\"slug\":\"字符串的比较\",\"contents\":[]},{\"header\":\"== 号的作用\",\"slug\":\"号的作用\",\"contents\":[\"比较基本数据类型：比较的是具体的值\",\"比较引用数据类型：比较的是对象地址值\"]},{\"header\":\"equals 方法的作用\",\"slug\":\"equals-方法的作用\",\"contents\":[\"public boolean equals(String s) //比较两个字符串内容是否相同、区分大小写 \"]},{\"header\":\"例题:金额转换\",\"slug\":\"例题-金额转换\",\"contents\":[\"案例需求:\",\"把2135变成：零佰零拾零万贰仟壹佰叁拾伍元\",\"把789变成：零佰零拾零万零仟柒佰捌拾玖元\",\"代码实现:\",\" import java.util.Scanner; public class StringDemo9 { public static void main(String[] args) { //1.键盘录入一个金额 Scanner sc = new Scanner(System.in); int money; while (true) { System.out.println(\\\"请录入一个金额\\\"); money = sc.nextInt(); if (money >= 0 && money <= 9999999) { break; } else { System.out.println(\\\"金额无效\\\"); } } //定义一个变量用来表示钱的大写 String moneyStr = \\\"\\\"; //2.得到money里面的每一位数字,再转成中文 while (true) {//2135 //从右往左获取数据，因为右侧是数据的个位 int ge = money % 10; String capitalNumber = getCapitalNumber(ge); //把转换之后的大写拼接到moneyStr当中 moneyStr = capitalNumber + moneyStr; //第一次循环 ： \\\"伍\\\" + \\\"\\\" = \\\"伍\\\" //第二次循环 ： \\\"叁\\\" + \\\"伍\\\" = \\\"叁伍\\\" //去掉刚刚获取的数据 money = money / 10; //如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束 if (money == 0) { break; } } //3.在前面补0，补齐7位 int count = 7 - moneyStr.length(); for (int i = 0; i < count; i++) { moneyStr = \\\"零\\\" + moneyStr; } System.out.println(moneyStr);//零零零贰壹叁伍 //4.插入单位 //定义一个数组表示单位 String[] arr = {\\\"佰\\\",\\\"拾\\\",\\\"万\\\",\\\"仟\\\",\\\"佰\\\",\\\"拾\\\",\\\"元\\\"}; // 零 零 零 贰 壹 叁 伍 //遍历moneyStr，依次得到 零 零 零 贰 壹 叁 伍 //然后把arr的单位插入进去 String result = \\\"\\\"; for (int i = 0; i < moneyStr.length(); i++) { char c = moneyStr.charAt(i); //把大写数字和单位拼接到result当中 result = result + c + arr[i]; } //5.打印最终结果 System.out.println(result); } //定义一个方法把数字变成大写的中文 //1 -- 壹 public static String getCapitalNumber(int number) { //定义数组，让数字跟大写的中文产生一个对应关系 String[] arr = {\\\"零\\\", \\\"壹\\\", \\\"贰\\\", \\\"叁\\\", \\\"肆\\\", \\\"伍\\\", \\\"陆\\\", \\\"柒\\\", \\\"捌\\\", \\\"玖\\\"}; //返回结果 return arr[number]; } } \"]},{\"header\":\"13.3 StringBuilder\",\"slug\":\"_13-3-stringbuilder\",\"contents\":[\"StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。\",\"当我们在拼接字符串和反转字符串的时候会使用到\"]},{\"header\":\"练习：对称字符串\",\"slug\":\"练习-对称字符串\",\"contents\":[\"需求：键盘接受一个字符串，程序判断出该字符串是否是对称字符串，并在控制台打印是或不是\",\"对称字符串：123321、111 非对称字符串：123123\",\"代码示例：\",\"public class StringBuilderDemo6 { //使用StringBuilder的场景： //1.字符串的拼接 //2.字符串的反转 public static void main(String[] args) { //1.键盘录入一个字符串 Scanner sc = new Scanner(System.in); System.out.println(\\\"请输入一个字符串\\\"); String str = sc.next(); //2.反转键盘录入的字符串 String result = new StringBuilder().append(str).reverse().toString(); //3.比较 if(str.equals(result)){ System.out.println(\\\"当前字符串是对称字符串\\\"); }else{ System.out.println(\\\"当前字符串不是对称字符串\\\"); } } } \"]},{\"header\":\"13.4 StringJoiner\",\"slug\":\"_13-4-stringjoiner\",\"contents\":[\"StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。\",\"作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。\",\"JDK8出现的\",\"基本使用：\",\"//1.创建一个对象，并指定中间的间隔符号 StringJoiner sj = new StringJoiner(\\\"---\\\"); //2.添加元素 sj.add(\\\"aaa\\\").add(\\\"bbb\\\").add(\\\"ccc\\\"); //3.打印结果 System.out.println(sj);//aaa---bbb---ccc \",\"//1.创建对象 StringJoiner sj = new StringJoiner(\\\", \\\",\\\"[\\\",\\\"]\\\"); //2.添加元素 sj.add(\\\"aaa\\\").add(\\\"bbb\\\").add(\\\"ccc\\\"); int len = sj.length(); System.out.println(len);//15 //3.打印 System.out.println(sj);//[aaa, bbb, ccc] String str = sj.toString(); System.out.println(str);//[aaa, bbb, ccc] \"]},{\"header\":\"14 集合\",\"slug\":\"_14-集合\",\"contents\":[\"集合和数组的优势对比\",\"长度可变\",\"添加数据的时候不需要考虑索引，默认将数据添加到末尾\"]},{\"header\":\"14.1 ArrayList类概述\",\"slug\":\"_14-1-arraylist类概述\",\"contents\":[\"什么是集合\",\"提供一种存储空间可变的存储模型，存储的数据容量可以发生改变\",\"ArrayList集合的特点\",\"长度可以变化，只能存储引用数据类型。\",\"泛型的使用\",\"用于约束集合中存储元素的数据类型\"]},{\"header\":\"14.2 ArrayList类常用方法\",\"slug\":\"_14-2-arraylist类常用方法\",\"contents\":[]},{\"header\":\"构造方法\",\"slug\":\"构造方法\",\"contents\":[\"方法名\",\"说明\",\"public ArrayList()\",\"创建一个空的集合对象\"]},{\"header\":\"成员方法\",\"slug\":\"成员方法\",\"contents\":[\"方法名\",\"说明\",\"public boolean add(要添加的元素)\",\"将指定的元素追加到此集合的末尾\",\"public boolean remove(要删除的元素)\",\"删除指定元素,返回值表示是否删除成功\",\"public E remove(int index)\",\"删除指定索引处的元素，返回被删除的元素\",\"public E set(int index,E element)\",\"修改指定索引处的元素，返回被修改的元素\",\"public E get(int index)\",\"返回指定索引处的元素\",\"public int size()\",\"返回集合中的元素的个数\"]},{\"header\":\"15 学生管理系统\",\"slug\":\"_15-学生管理系统\",\"contents\":[]},{\"header\":\"15.1 学生管理系统实现步骤\",\"slug\":\"_15-1-学生管理系统实现步骤\",\"contents\":[\"案例需求\",\"针对目前我们的所学内容，完成一个综合案例：学生管理系统。该系统主要 能如下： 添加学生：通过键盘录入学生信息，添加到集合中 删除学生：通过键盘录入要删除学生的学号，将该学生对象从集合中删除 修改学生：通过键盘录入要修改学生的学号，将该学生对象其他信息进行修改 查看学生：将集合中的学生对象信息进行展示 退出系统：结束程序\",\"实现步骤\",\"定义学生类，包含以下成员变量\",\"private String sid // 学生id\",\"private String name // 学生姓名\",\"private String age // 学生年龄\",\"private String address // 学生所在地\",\"学生管理系统主界面的搭建步骤\",\"2.1 用输出语句完成主界面的编写 2.2 用Scanner实现键盘输入 2.3 用switch语句完成选择的功能 2.4 用循环完成功能结束后再次回到主界面\",\"学生管理系统的添加学生功能实现步骤\",\"3.1 定义一个方法，接收ArrayList<Student>集合 3.2 方法内完成添加学生的功能 ​ ①键盘录入学生信息 ​ ②根据录入的信息创建学生对象 ​ ③将学生对象添加到集合中 ​ ④提示添加成功信息 3.3 在添加学生的选项里调用添加学生的方法\",\"学生管理系统的查看学生功能实现步骤\",\"4.1 定义一个方法，接收ArrayList<Student>集合 4.2 方法内遍历集合，将学生信息进行输出 4.3 在查看所有学生选项里调用查看学生方法\",\"学生管理系统的删除学生功能实现步骤\",\"5.1 定义一个方法，接收ArrayList<Student>集合 5.2 方法中接收要删除学生的学号 5.3 遍历集合，获取每个学生对象 5.4 使用学生对象的学号和录入的要删除的学号进行比较,如果相同，则将当前学生对象从集合中删除 5.5 在删除学生选项里调用删除学生的方法\",\"学生管理系统的修改学生功能实现步骤\",\"6.1 定义一个方法，接收ArrayList<Student>集合 6.2 方法中接收要修改学生的学号 6.3 通过键盘录入学生对象所需的信息，并创建对象 6.4 遍历集合，获取每一个学生对象。并和录入的修改学生学号进行比较.如果相同，则使用新学生对象替换当前学生对象 6.5 在修改学生选项里调用修改学生的方法\",\"退出系统\",\"使用System.exit(0); 退出JVM\"]},{\"header\":\"15.2 代码演示\",\"slug\":\"_15-2-代码演示\",\"contents\":[]},{\"header\":\"学生类的定义\",\"slug\":\"学生类的定义\",\"contents\":[\" public class Student { private String id; private String name; private int age; private String address; //下面是空参，有参，get和set方法 } \"]},{\"header\":\"测试类的定义\",\"slug\":\"测试类的定义\",\"contents\":[\"public class StudentSystem { public static void main(String[] args) { ArrayList<Student> list = new ArrayList<>(); loop: while (true) { System.out.println(\\\"-----------------欢迎来到黑马学生管理系统-------------------\\\"); System.out.println(\\\"1:添加学生\\\"); System.out.println(\\\"2:删除学生\\\"); System.out.println(\\\"3:修改学生\\\"); System.out.println(\\\"4:查询学生\\\"); System.out.println(\\\"5:退出\\\"); System.out.println(\\\"请输入您的选择：\\\"); Scanner sc = new Scanner(System.in); String choose = sc.next(); switch (choose) { case \\\"1\\\" -> addStudent(list); case \\\"2\\\" -> deleteStudent(list); case \\\"3\\\" -> updateStudent(list); case \\\"4\\\" -> queryStudent(list); case \\\"5\\\" -> { System.out.println(\\\"退出\\\"); //break loop; System.exit(0);//停止虚拟机运行 } default -> System.out.println(\\\"没有这个选项\\\"); } } } //添加学生 public static void addStudent(ArrayList<Student> list) { //利用空参构造先创建学生对象 Student s = new Student(); Scanner sc = new Scanner(System.in); String id = null; while (true) { System.out.println(\\\"请输入学生的id\\\"); id = sc.next(); boolean flag = contains(list, id); if(flag){ //表示id已经存在，需要重新录入 System.out.println(\\\"id已经存在，请重新录入\\\"); }else{ //表示id不存在，表示可以使用 s.setId(id); break; } } System.out.println(\\\"请输入学生的姓名\\\"); String name = sc.next(); s.setName(name); System.out.println(\\\"请输入学生的年龄\\\"); int age = sc.nextInt(); s.setAge(age); System.out.println(\\\"请输入学生的家庭住址\\\"); String address = sc.next(); s.setAddress(address); //把学生对象添加到集合当中 list.add(s); //提示一下用户 System.out.println(\\\"学生信息添加成功\\\"); } //删除学生 public static void deleteStudent(ArrayList<Student> list) { Scanner sc = new Scanner(System.in); System.out.println(\\\"请输入要删除的id\\\"); String id = sc.next(); //查询id在集合中的索引 int index = getIndex(list, id); //对index进行判断 //如果-1，就表示不存在，结束方法，回到初始菜单 if(index >= 0){ //如果大于等于0的，表示存在，直接删除 list.remove(index); System.out.println(\\\"id为：\\\" + id + \\\"的学生删除成功\\\"); }else{ System.out.println(\\\"id不存在，删除失败\\\"); } } //修改学生 public static void updateStudent(ArrayList<Student> list) { Scanner sc = new Scanner(System.in); System.out.println(\\\"请输入要修改学生的id\\\"); String id = sc.next(); int index = getIndex(list, id); if(index == -1){ System.out.println(\\\"要修改的id\\\" + id + \\\"不存在，请重新输入\\\"); return; } //当代码执行到这里，表示什么？表示当前id是存在的。 //获取要修改的学生对象 Student stu = list.get(index); //输入其他的信息并修改 System.out.println(\\\"请输入要修改的学生姓名\\\"); String newName = sc.next(); stu.setName(newName); System.out.println(\\\"请输入要修改的学生年龄\\\"); int newAge = sc.nextInt(); stu.setAge(newAge); System.out.println(\\\"请输入要修改的学生家庭住址\\\"); String newAddress = sc.next(); stu.setAddress(newAddress); System.out.println(\\\"学生信息修改成功\\\"); } //查询学生 public static void queryStudent(ArrayList<Student> list) { if (list.size() == 0) { System.out.println(\\\"当前无学生信息，请添加后再查询\\\"); //结束方法 return; } //打印表头信息 System.out.println(\\\"id\\\\t\\\\t姓名\\\\t年龄\\\\t家庭住址\\\"); //当代码执行到这里，表示集合中是有数据的 for (int i = 0; i < list.size(); i++) { Student stu = list.get(i); System.out.println(stu.getId() + \\\"\\\\t\\\" + stu.getName() + \\\"\\\\t\\\" + stu.getAge() + \\\"\\\\t\\\" + stu.getAddress()); } } //判断id在集合中是否存在 public static boolean contains(ArrayList<Student> list, String id) { //循环遍历集合得到里面的每一个学生对象 /*for (int i = 0; i < list.size(); i++) { //拿到学生对象后，获取id并进行判断 Student stu = list.get(i); String sid = stu.getId(); if(sid.equals(id)){ //存在，true return true; } } // 不存在false return false;*/ return getIndex(list,id) >= 0; } //通过id获取索引的方法 public static int getIndex(ArrayList<Student> list, String id){ //遍历集合 for (int i = 0; i < list.size(); i++) { //得到每一个学生对象 Student stu = list.get(i); //得到每一个学生对象的id String sid = stu.getId(); //拿着集合中的学生id跟要查询的id进行比较 if(sid.equals(id)){ //如果一样，那么就返回索引 return i; } } //当循环结束之后还没有找到，就表示不存在，返回-1. return -1; } } \"]}]},\"/BackEnd/JavaSE/Javase04.html\":{\"title\":\"Java常用API\",\"contents\":[{\"header\":\"16 常见API、对象克隆\",\"slug\":\"_16-常见api、对象克隆\",\"contents\":[]},{\"header\":\"16.1 常见API\",\"slug\":\"_16-1-常见api\",\"contents\":[]},{\"header\":\"16.1.1 System类\",\"slug\":\"_16-1-1-system类\",\"contents\":[\"System类所在包为java.lang包，因此在使用的时候不需要进行导包。并且System类被final修饰了，因此该类是不能被继承的。\",\"System包含了系统操作的一些常用的方法。比如获取当前时间所对应的毫秒值，再比如终止当前JVM等等。\"]},{\"header\":\"常见方法\",\"slug\":\"常见方法\",\"contents\":[\"// 获取当前时间所对应的毫秒值（当前时间为0时区所对应的时间即就是英国格林尼治天文台旧址所在位置） public static long currentTimeMillis() // 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出 public static void exit(int status) // 进行数值元素copy public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); // src: 源数组 // srcPos： 源数值的开始位置 // dest： 目标数组 // destPos： 目标数组开始位置 // length: 要复制的元素个数 \",\"arraycopy方法底层细节：\",\"如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错\",\"在拷贝的时候需要考虑数组的长度，如果超出范围也会报错\",\"如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型\"]},{\"header\":\"16.1.2 Runtime\",\"slug\":\"_16-1-2-runtime\",\"contents\":[\"Runtime表示Java中运行时对象，可以获取到程序运行时涉及到的一些信息\",\"常见方法：\",\"//当前系统的运行环境对象 public static Runtime getRuntime() //停止虚拟机 public void exit(int status) //获得CPU的线程数 public int availableProcessors() //JVM能从系统中获取总内存大小（单位byte） public long maxMemory() //JVM已经从系统中获取总内存大小（单位byte） public long totalMemory() //JVM剩余内存大小（单位byte） public long freeMemory() //运行cmd命令 public Process exec(String command) \",\"代码示例：\",\"public class RunTimeDemo1 { public static void main(String[] args) throws IOException { //1.获取Runtime的对象 //Runtime r1 =Runtime.getRuntime(); //2.exit 停止虚拟机 //Runtime.getRuntime().exit(0); //System.out.println(\\\"看看我执行了吗?\\\"); //3.获得CPU的线程数 System.out.println(Runtime.getRuntime().availableProcessors());//8 //4.总内存大小,单位byte字节 System.out.println(Runtime.getRuntime().maxMemory() / 1024 / 1024);//4064 //5.已经获取的总内存大小,单位byte字节 System.out.println(Runtime.getRuntime().totalMemory() / 1024 / 1024);//254 //6.剩余内存大小 System.out.println(Runtime.getRuntime().freeMemory() / 1024 / 1024);//251 //7.运行cmd命令 //shutdown :关机 //加上参数才能执行 //-s :默认在1分钟之后关机 //-s -t 指定时间 : 指定关机时间 //-a :取消关机操作 //-r: 关机并重启 Runtime.getRuntime().exec(\\\"shutdown -s -t 3600\\\"); } } \"]},{\"header\":\"16.1.3 Object类\",\"slug\":\"_16-1-3-object类\",\"contents\":[\"常用方法：\",\"//返回该对象的字符串表示形式(可以看做是对象的内存地址值) public String toString() //比较两个对象地址值是否相等；true表示相同，false表示不相同 public boolean equals(Object obj) //对象克隆 protected Object clone() \",\"对象克隆的分类：\",\"深克隆和浅克隆\",\"浅克隆：\",\"不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来\",\"基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。\",\"Object类默认的是浅克隆\",\"浅克隆\",\"深克隆：\",\"基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的\",\"深克隆\",\"代码实现：\",\"package com.demo.a04objectdemo; public class ObjectDemo4 { public static void main(String[] args) throws CloneNotSupportedException { // protected object clone(int a) 对象克隆 //1.先创建一个对象 int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0}; User u1 = new User(1, \\\"zhangsan\\\", \\\"1234qwer\\\", \\\"girl11\\\", data); //2.克隆对象 //细节: //方法在底层会帮我们创建一个对象,并把原对象中的数据拷贝过去。 //书写细节: //1.重写Object中的clone方法 //2.让javabean类实现Cloneable接口 //3.创建原对象并调用clone就可以了 //User u2 =(User)u1.clone(); //验证一件事情：Object中的克隆是浅克隆 //想要进行深克隆，就需要重写clone方法并修改里面的方法体 //int[] arr = u1.getData(); //arr[0] = 100; //System.out.println(u1); //System.out.println(u2); //以后一般会用第三方工具进行克隆 //1.第三方写的代码导入到项目中 //2.编写代码 //Gson gson =new Gson(); //把对象变成一个字符串 //String s=gson.toJson(u1); //再把字符串变回对象就可以了 //User user =gson.fromJson(s, User.class); //int[] arr=u1.getData(); //arr[0] = 100; //打印对象 //System.out.println(user); } } package com.demo.a04objectdemo; import java.util.StringJoiner; //Cloneable //如果一个接口里面没有抽象方法 //表示当前的接口是一个标记性接口 //现在Cloneable表示一旦实现了，那么当前类的对象就可以被克降 //如果没有实现，当前类的对象就不能克隆 public class User implements Cloneable { private int id; private String username; private String password; private String path; private int[] data; public User() { } public User(int id, String username, String password, String path, int[] data) { this.id = id; this.username = username; this.password = password; this.path = path; this.data = data; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getPath() { return path; } public void setPath(String path) { this.path = path; } public int[] getData() { return data; } public void setData(int[] data) { this.data = data; } public String toString() { return \\\"角色编号为：\\\" + id + \\\"，用户名为：\\\" + username + \\\"密码为：\\\" + password + \\\", 游戏图片为:\\\" + path + \\\", 进度:\\\" + arrToString(); } public String arrToString() { StringJoiner sj = new StringJoiner(\\\", \\\", \\\"[\\\", \\\"]\\\"); for (int i = 0; i < data.length; i++) { sj.add(data[i] + \\\"\\\"); } return sj.toString(); } @Override protected Object clone() throws CloneNotSupportedException { //调用父类中的clone方法 //相当于让Java帮我们克隆一个对象，并把克隆之后的对象返回出去。 //先把被克隆对象中的数组获取出来 int[] data = this.data; //创建新的数组 int[] newData =new int[data.length]; //拷贝数组中的数据 for (int i = 0; i < data.length; i++) { newData[i] = data[i]; } //调用父类中的方法克隆对象 User u=(User)super.clone(); //因为父类中的克隆方法是浅克隆，替换克隆出来对象中的数组地址值 u.data =newData; return u; } } \"]},{\"header\":\"16.2 BigInteger类\",\"slug\":\"_16-2-biginteger类\",\"contents\":[\"常见方法:\",\"//获取随机大整数，范围：[0 ~ 2的num次方-1] public BigInteger(int num, Random rnd) //获取指定的大整数 public BigInteger(String val) //获取指定进制的大整数 public BigInteger(String val, int radix) //下面这个不是构造，而是一个静态方法获取BigInteger对象 //静态方法获取BigInteger的对象，内部有优化 public static BigInteger valueOf(long val) \",\"构造方法小结：\",\"如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取。\",\"如果BigInteger表示的超出long的范围，可以用构造方法获取。\",\"对象一旦创建，BigInteger内部记录的值不能发生改变。\",\"只要进行计算都会产生一个新的BigInteger对象\",\"常见成员方法:\",\"BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：\",\"public BigInteger add(BigInteger val) public BigInteger subtract(BigInteger val) public BigInteger multiply(BigInteger val) public BigInteger divide(BigInteger val) //除法，获取商和余数 public BigInteger[] divideAndRemainder(BigInteger val) public boolean equals(Object x) public BigInteger pow(int exponent) public BigInteger max/min(BigInteger val) //转为int类型整数，超出范围数据有误 public int intValue(BigInteger val) \"]},{\"header\":\"16.2.1 底层存储方式\",\"slug\":\"_16-2-1-底层存储方式\",\"contents\":[\"对于计算机而言，其实是没有数据类型的概念的，都是0101010101，数据类型是编程语言自己规定的，所以在实际存储的时候，先把具体的数字变成二进制，每32个bit为一组，存储在数组中。\",\"数组中最多能存储元素个数：21亿多\",\"数组中每一位能表示的数字：42亿多\",\"理论上，BigInteger能表示的最大数字为：42亿的21亿次方。\",\"但是还没到这个数字，电脑的内存就会撑爆，所以一般认为BigInteger是无限的。\",\"存储方式如图所示：\",\"bigInteger的底层原理\"]},{\"header\":\"16.3 BigDecimal类\",\"slug\":\"_16-3-bigdecimal类\",\"contents\":[\"常见成员方法:\",\"BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：\",\"// 加法运算 public BigDecimal add(BigDecimal value) // 减法运算 public BigDecimal subtract(BigDecimal value) // 乘法运算 public BigDecimal multiply(BigDecimal value) // 触发运算 public BigDecimal divide(BigDecimal value) \",\"演示除法的特殊情况:\",\"如果使用BigDecimal类型的数据进行除法运算的时候，得到的结果是一个无限循环小数，那么就会报错：ArithmeticException。 如下代码所示：\",\"public class BigDecimalDemo02 { public static void main(String[] args) { // 创建两个BigDecimal对象 BigDecimal b1 = new BigDecimal(\\\"1\\\") ; BigDecimal b2 = new BigDecimal(\\\"3\\\") ; // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出 System.out.println(b1.divide(b2)); } } \",\"运行程序进行测试，控制台输出结果如下所示：\",\"Exception in thread \\\"main\\\" java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result. at java.base/java.math.BigDecimal.divide(BigDecimal java:1716) at com.demo.api.bigdecimal.demo02.BigDecimalDemo02.main(BigDecimalDemo02.java:14) \",\"针对这个问题怎么解决，此时我们就需要使用到BigDecimal类中另外一个divide方法，如下所示：\",\"BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) \",\"上述divide方法参数说明：\",\"divisor: 除数对应的BigDecimal对象； scale: 精确的位数； roundingMode: 取舍模式； \",\"取舍模式被封装到了RoundingMode这个枚举类中，在这个枚举类中定义了很多种取舍方式。最常见的取舍方式有如下几个： UP(直接进1) ， FLOOR(直接删除) ， HALF_UP(4舍五入)，我们可以通过如下格式直接访问这些取舍模式：枚举类名.变量名\",\"接下来我们就来演示一下这些取舍模式，代码如下所示：\",\"public class BigDecimalDemo02 { public static void main(String[] args) { // 调用方法 method_03() ; } // 演示取舍模式HALF_UP public static void method_03() { // 创建两个BigDecimal对象 BigDecimal b1 = new BigDecimal(\\\"0.3\\\") ; BigDecimal b2 = new BigDecimal(\\\"4\\\") ; // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出 System.out.println(b1.divide(b2 , 2 , RoundingMode.HALF_UP)); } // 演示取舍模式FLOOR public static void method_02() { // 创建两个BigDecimal对象 BigDecimal b1 = new BigDecimal(\\\"1\\\") ; BigDecimal b2 = new BigDecimal(\\\"3\\\") ; // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出 System.out.println(b1.divide(b2 , 2 , RoundingMode.FLOOR)); } // 演示取舍模式UP public static void method_01() { // 创建两个BigDecimal对象 BigDecimal b1 = new BigDecimal(\\\"1\\\") ; BigDecimal b2 = new BigDecimal(\\\"3\\\") ; // 调用方法进行b1和b2的除法运算，并且将计算结果在控制台进行输出 System.out.println(b1.divide(b2 , 2 , RoundingMode.UP)); } } \",\"小结：后期在进行两个数的除法运算的时候，我们常常使用的是可以设置取舍模式的divide方法。\",\"底层存储方式:\",\"把数据看成字符串，遍历得到里面的每一个字符，把这些字符在ASCII码表上的值，都存储到数组中。\",\"bigdecimal存储原理\"]},{\"header\":\"17 正则表达式\",\"slug\":\"_17-正则表达式\",\"contents\":[]},{\"header\":\"17.1 字符类\",\"slug\":\"_17-1-字符类\",\"contents\":[\"[abc]：代表a或者b，或者c字符中的一个。\",\"[^abc]：代表除a,b,c以外的任何字符。\",\"[a-z]：代表a-z的所有小写字符中的一个。\",\"[A-Z]：代表A-Z的所有大写字符中的一个。\",\"[0-9]：代表0-9之间的某一个数字字符。\",\"[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。\",\"[a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。\"]},{\"header\":\"17.2 逻辑运算符\",\"slug\":\"_17-2-逻辑运算符\",\"contents\":[\"&&：并且\",\"| ：或者\",\"\\\\ ：转义字符\"]},{\"header\":\"17.3 预定义字符\",\"slug\":\"_17-3-预定义字符\",\"contents\":[\"\\\".\\\" ： 匹配任何字符。\",\"\\\"\\\\d\\\"：任何数字[0-9]的简写；\",\"\\\"\\\\D\\\"：任何非数字[^0-9]的简写；\",\"\\\"\\\\s\\\"： 空白字符：[ \\\\t\\\\n\\\\x0B\\\\f\\\\r] 的简写\",\"\\\"\\\\S\\\"： 非空白字符：[^s] 的简写\",\"\\\"\\\\w\\\"：单词字符：[a-zA-Z_0-9]的简写\",\"\\\"\\\\W\\\"：非单词字符：[^w]\"]},{\"header\":\"17.4 数量词\",\"slug\":\"_17-4-数量词\",\"contents\":[\"X? : 0次或1次\",\"X* : 0次到多次\",\"X+ : 1次或多次\",\"X{n} : 恰好n次\",\"X{n,} : 至少n次\",\"X{n,m}: n到m次(n和m都是包含的)\"]},{\"header\":\"17.5 Pattern、Matcher\",\"slug\":\"_17-5-pattern、matcher\",\"contents\":[\"Pattern：表示正则表达式 Matcher：文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。\",\"代码示例：\",\"package com.demo.a08regexdemo; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexDemo6 { public static void main(String[] args) { String str = \\\"Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，\\\" + \\\"因为这两个是长期支持版本，下一个长期支持版本是Java17，相信在未来不久Java17也会逐渐登上历史舞台\\\"; //1.获取正则表达式的对象 Pattern p = Pattern.compile(\\\"Java\\\\\\\\d{0,2}\\\"); //2.获取文本匹配器的对象 //拿着m去读取str，找符合p规则的子串 Matcher m = p.matcher(str); //3.利用循环获取 while (m.find()) { String s = m.group(); System.out.println(s); } } private static void method1(String str) { //Pattern:表示正则表达式 //Matcher: 文本匹配器，作用按照正则表达式的规则去读取字符串，从头开始读取。 // 在大串中去找符合匹配规则的子串。 //获取正则表达式的对象 Pattern p = Pattern.compile(\\\"Java\\\\\\\\d{0,2}\\\"); //获取文本匹配器的对象 //m:文本匹配器的对象 //str:大串 //p:规则 //m要在str中找符合p规则的小串 Matcher m = p.matcher(str); //拿着文本匹配器从头开始读取，寻找是否有满足规则的子串 //如果没有，方法返回false //如果有，返回true。在底层记录子串的起始索引和结束索引+1 // 0,4 boolean b = m.find(); //方法底层会根据find方法记录的索引进行字符串的截取 // substring(起始索引，结束索引);包头不包尾 // (0,4)但是不包含4索引 // 会把截取的小串进行返回。 String s1 = m.group(); System.out.println(s1); //第二次在调用find的时候，会继续读取后面的内容 //读取到第二个满足要求的子串，方法会继续返回true //并把第二个子串的起始索引和结束索引+1，进行记录 b = m.find(); //第二次调用group方法的时候，会根据find方法记录的索引再次截取子串 String s2 = m.group(); System.out.println(s2); } } \"]},{\"header\":\"18 时间、包装类\",\"slug\":\"_18-时间、包装类\",\"contents\":[]},{\"header\":\"18.1 时间\",\"slug\":\"_18-1-时间\",\"contents\":[]},{\"header\":\"18.1.1 Date类\",\"slug\":\"_18-1-1-date类\",\"contents\":[\"java.util.Date类 表示特定的瞬间，精确到毫秒。\",\"Date拥有多个构造函数，只是部分已经过时\",\"public Date()：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象\",\"public Date(long date)：将指定参数的毫秒值date，转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\",\"tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间/格林尼治时间（GMT）快8小时的时区 当格林尼治标准时间为0:00时，东八区的标准时间为08:00。\",\"例如：\",\"import java.util.Date; public class Demo01Date { public static void main(String[] args) { // 创建日期对象，把当前的时间 System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2020 // 创建日期对象，把当前的毫秒值转成日期对象 System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 } } \",\"tips: 在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串\"]},{\"header\":\"18.1.2 Date常用方法\",\"slug\":\"_18-1-2-date常用方法\",\"contents\":[\"Date类中的多数方法已经过时，常用的方法有：\",\"public long getTime() 把日期对象转换成对应的时间毫秒值。\",\"public void setTime(long time) 把方法参数给定的毫秒值设置给日期对象\",\"示例代码\",\"public class DateDemo02 { public static void main(String[] args) { //创建日期对象 Date d = new Date(); //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 System.out.println(d.getTime()); System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + \\\"年\\\"); //public void setTime(long time):设置时间，给的是毫秒值 //long time = 1000*60*60; long time = System.currentTimeMillis(); d.setTime(time); System.out.println(d); } } \",\"小结： Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。\"]},{\"header\":\"18.1.3 SimpleDateFormat类\",\"slug\":\"_18-1-3-simpledateformat类\",\"contents\":[\"java.text.SimpleDateFormat 是日期/时间格式化类，可以在Date对象与String对象之间进行来回转换\",\"格式化：按照指定的格式，把Date对象转换为String对象。\",\"解析：按照指定的格式，把String对象转换为Date对象。\"]},{\"header\":\"构造方法\",\"slug\":\"构造方法\",\"contents\":[\"由于DateFormat为抽象类，不能直接使用，所以需要常用的子类java.text.SimpleDateFormat。\",\"public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。\"]},{\"header\":\"格式规则\",\"slug\":\"格式规则\",\"contents\":[\"标识字母（区分大小写）\",\"含义\",\"y\",\"年\",\"M\",\"月\",\"d\",\"日\",\"H\",\"时\",\"m\",\"分\",\"s\",\"秒\"]},{\"header\":\"常用方法\",\"slug\":\"常用方法\",\"contents\":[\"DateFormat类的常用方法有：\",\"public String format(Date date)：将Date对象格式化为字符串。\",\"public Date parse(String source)：将字符串解析为Date对象。\",\"package com.demo.a01jdk7datedemo; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class A03_SimpleDateFormatDemo1 { public static void main(String[] args) throws ParseException { //1.定义一个字符串表示时间 String str = \\\"2023-11-11 11:11:11\\\"; //2.利用空参构造创建simpleDateFormat对象 //创建对象的格式要跟字符串的格式完全一致 SimpleDateFormat sdf = new SimpleDateFormat(\\\"yyyy-MM-dd HH:mm:ss\\\"); Date date = sdf.parse(str); //3.打印结果 System.out.println(date.getTime());//1699672271000 } private static void method1() { //1.利用空参构造创建simpleDateFormat对象，默认格式 SimpleDateFormat sdf1 = new SimpleDateFormat(); Date d1 = new Date(0L); String str1 = sdf1.format(d1); System.out.println(str1);//1970/1/1 上午8:00 //2.利用带参构造创建simpleDateFormat对象，指定格式 SimpleDateFormat sdf2 = new SimpleDateFormat(\\\"yyyy年MM月dd日HH:mm:ss\\\"); String str2 = sdf2.format(d1); System.out.println(str2);//1970年01月01日 08:00:00 } } \",\"小结：DateFormat可以将Date对象和字符串相互转换。\"]},{\"header\":\"练习1(初恋女友的出生日期)\",\"slug\":\"练习1-初恋女友的出生日期\",\"contents\":[\"/* 假设，你初恋的出生年月日为:2000-11-11 请用字符串表示这个数据，并将其转换为:2000年11月11日 创建一个Date对象表示2000年11月11日 创建一个SimpleDateFormat对象，并定义格式为年月日把时间变成:2000年11月11日 */ //1.可以通过2000-11-11进行解析，解析成一个Date对象 String str = \\\"2000-11-11\\\"; //2.解析 SimpleDateFormat sdf1 = new SimpleDateFormat(\\\"yyyy-MM-dd\\\"); Date date = sdf1.parse(str); //3.格式化 SimpleDateFormat sdf2 = new SimpleDateFormat(\\\"yyyy年MM月dd日\\\"); String result = sdf2.format(date); System.out.println(result); \"]},{\"header\":\"练习2(秒杀活动)\",\"slug\":\"练习2-秒杀活动\",\"contents\":[\"/* 需求: 秒杀活动开始时间:2023年11月11日 0:0:0(毫秒值) 秒杀活动结束时间:2023年11月11日 0:10:0(毫秒值) 小贾下单并付款的时间为:2023年11月11日 0:01:0 小皮下单并付款的时间为:2023年11月11日 0:11:0 用代码说明这两位同学有没有参加上秒杀活动? */ //1.定义字符串表示三个时间 String startstr = \\\"2023年11月11日 0:0:0\\\"; String endstr = \\\"2023年11月11日 0:10:0\\\"; String orderstr = \\\"2023年11月11日 0:01:00\\\"; //2.解析上面的三个时间，得到Date对象 SimpleDateFormat sdf = new SimpleDateFormat(\\\"yyyy年MM月dd日HH:mm:ss\\\"); Date startDate = sdf.parse(startstr); Date endDate = sdf.parse(endstr); Date orderDate = sdf.parse(orderstr); //3.得到三个时间的毫秒值 long startTime = startDate.getTime(); long endTime = endDate.getTime(); long orderTime = orderDate.getTime(); //4.判断 if (orderTime >= startTime && orderTime <= endTime) { System.out.println(\\\"参加秒杀活动成功\\\"); } else { System.out.println(\\\"参加秒杀活动失败\\\"); } \"]},{\"header\":\"18.1.3 Calendar类\",\"slug\":\"_18-1-3-calendar类\",\"contents\":[\"java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。\",\"有两种方式可以获取GregorianCalendar对象： \",\"直接创建GregorianCalendar对象；\",\"通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象\",\"常用方法：\",\"方法名\",\"说明\",\"public static Calendar getInstance()\",\"获取一个它的子类GregorianCalendar对象。\",\"public int get(int field)\",\"获取某个字段的值。field参数表示获取哪个字段的值，可以使用Calender中定义的常量来表示：Calendar.YEAR : 年Calendar.MONTH ：月Calendar.DAY_OF_MONTH：月中的日期Calendar.HOUR：小时Calendar.MINUTE：分钟Calendar.SECOND：秒Calendar.DAY_OF_WEEK：星期\",\"public void set(int field,int value)\",\"设置某个字段的值\",\"public void add(int field,int amount)\",\"为某个字段增加/减少指定的值\"]},{\"header\":\"18.1.4 JDK8时间相关类\",\"slug\":\"_18-1-4-jdk8时间相关类\",\"contents\":[\"JDK8时间类类名\",\"作用\",\"ZoneId\",\"时区\",\"Instant\",\"时间戳\",\"ZoneDateTime\",\"带时区的时间\",\"DateTimeFormatter\",\"用于时间的格式化和解析\",\"LocalDate\",\"年、月、日\",\"LocalTime\",\"时、分、秒\",\"LocalDateTime\",\"年、月、日、时、分、秒\",\"Duration\",\"时间间隔（秒，纳，秒）\",\"Period\",\"时间间隔（年，月，日）\",\"ChronoUnit\",\"时间间隔（所有单位）\"]},{\"header\":\"ZoneId 时区\",\"slug\":\"zoneid-时区\",\"contents\":[\"/* static Set<string> getAvailableZoneIds() 获取Java中支持的所有时区 static ZoneId systemDefault() 获取系统默认时区 static Zoneld of(string zoneld) 获取一个指定时区 */ //1.获取所有的时区名称 Set<String> zoneIds = ZoneId.getAvailableZoneIds(); System.out.println(zoneIds.size());//600 System.out.println(zoneIds);// Asia/Shanghai //2.获取当前系统的默认时区 ZoneId zoneId = ZoneId.systemDefault(); System.out.println(zoneId);//Asia/Shanghai //3.获取指定的时区 ZoneId zoneId1 = ZoneId.of(\\\"Asia/Pontianak\\\"); System.out.println(zoneId1);//Asia/Pontianak \"]},{\"header\":\"Instant 时间戳\",\"slug\":\"instant-时间戳\",\"contents\":[\"/* static Instant now() 获取当前时间的Instant对象(标准时间) static Instant ofXxxx(long epochMilli) 根据(秒/毫秒/纳秒)获取Instant对象 ZonedDateTime atZone(ZoneIdzone) 指定时区 boolean isxxx(Instant otherInstant) 判断系列的方法 Instant minusXxx(long millisToSubtract) 减少时间系列的方法 Instant plusXxx(long millisToSubtract) 增加时间系列的方法 */ //1.获取当前时间的Instant对象(标准时间) Instant now = Instant.now(); System.out.println(now); //2.根据(秒/毫秒/纳秒)获取Instant对象 Instant instant1 = Instant.ofEpochMilli(0L); System.out.println(instant1);//1970-01-01T00:00:00z Instant instant2 = Instant.ofEpochSecond(1L); System.out.println(instant2);//1970-01-01T00:00:01Z Instant instant3 = Instant.ofEpochSecond(1L, 1000000000L); System.out.println(instant3);//1970-01-01T00:00:027 //3. 指定时区 ZonedDateTime time = Instant.now().atZone(ZoneId.of(\\\"Asia/Shanghai\\\")); System.out.println(time); //4.isXxx 判断 Instant instant4=Instant.ofEpochMilli(0L); Instant instant5 =Instant.ofEpochMilli(1000L); //5.用于时间的判断 //isBefore:判断调用者代表的时间是否在参数表示时间的前面 boolean result1=instant4.isBefore(instant5); System.out.println(result1);//true //isAfter:判断调用者代表的时间是否在参数表示时间的后面 boolean result2 = instant4.isAfter(instant5); System.out.println(result2);//false //6.Instant minusXxx(long millisToSubtract) 减少时间系列的方法 Instant instant6 =Instant.ofEpochMilli(3000L); System.out.println(instant6);//1970-01-01T00:00:03Z Instant instant7 =instant6.minusSeconds(1); System.out.println(instant7);//1970-01-01T00:00:02Z \"]},{\"header\":\"ZoneDateTime 带时区的时间\",\"slug\":\"zonedatetime-带时区的时间\",\"contents\":[\"/* static ZonedDateTime now() 获取当前时间的ZonedDateTime对象 static ZonedDateTime ofXxxx(。。。) 获取指定时间的ZonedDateTime对象 ZonedDateTime withXxx(时间) 修改时间系列的方法 ZonedDateTime minusXxx(时间) 减少时间系列的方法 ZonedDateTime plusXxx(时间) 增加时间系列的方法 */ //1.获取当前时间对象(带时区) ZonedDateTime now = ZonedDateTime.now(); System.out.println(now); //2.获取指定的时间对象(带时区)1/年月日时分秒纳秒方式指定 ZonedDateTime time1 = ZonedDateTime.of(2023, 10, 1, 11, 12, 12, 0, ZoneId.of(\\\"Asia/Shanghai\\\")); System.out.println(time1); //通过Instant + 时区的方式指定获取时间对象 Instant instant = Instant.ofEpochMilli(0L); ZoneId zoneId = ZoneId.of(\\\"Asia/Shanghai\\\"); ZonedDateTime time2 = ZonedDateTime.ofInstant(instant, zoneId); System.out.println(time2); //3.withXxx 修改时间系列的方法 ZonedDateTime time3 = time2.withYear(2000); System.out.println(time3); //4. 减少时间 ZonedDateTime time4 = time3.minusYears(1); System.out.println(time4); //5.增加时间 ZonedDateTime time5 = time4.plusYears(1); System.out.println(time5); \"]},{\"header\":\"DateTimeFormatter 用于时间的格式化和解析\",\"slug\":\"datetimeformatter-用于时间的格式化和解析\",\"contents\":[\"/* static DateTimeFormatter ofPattern(格式) 获取格式对象 String format(时间对象) 按照指定方式格式化 */ //获取时间对象 ZonedDateTime time = Instant.now().atZone(ZoneId.of(\\\"Asia/Shanghai\\\")); // 解析/格式化器 DateTimeFormatter dtf1=DateTimeFormatter.ofPattern(\\\"yyyy-MM-dd HH:mm;ss EE a\\\"); // 格式化 System.out.println(dtf1.format(time)); \"]},{\"header\":\"LocalDate 年、月、日\",\"slug\":\"localdate-年、月、日\",\"contents\":[\"//1.获取当前时间的日历对象(包含 年月日) LocalDate nowDate = LocalDate.now(); //System.out.println(\\\"今天的日期:\\\" + nowDate); //2.获取指定的时间的日历对象 LocalDate ldDate = LocalDate.of(2023, 1, 1); System.out.println(\\\"指定日期:\\\" + ldDate); System.out.println(\\\"=============================\\\"); //3.get系列方法获取日历中的每一个属性值//获取年 int year = ldDate.getYear(); System.out.println(\\\"year: \\\" + year); //获取月//方式一: Month m = ldDate.getMonth(); System.out.println(m); System.out.println(m.getValue()); //方式二: int month = ldDate.getMonthValue(); System.out.println(\\\"month: \\\" + month); //获取日 int day = ldDate.getDayOfMonth(); System.out.println(\\\"day:\\\" + day); //获取一年的第几天 int dayofYear = ldDate.getDayOfYear(); System.out.println(\\\"dayOfYear:\\\" + dayofYear); //获取星期 DayOfWeek dayOfWeek = ldDate.getDayOfWeek(); System.out.println(dayOfWeek); System.out.println(dayOfWeek.getValue()); //is开头的方法表示判断 System.out.println(ldDate.isBefore(ldDate)); System.out.println(ldDate.isAfter(ldDate)); //with开头的方法表示修改，只能修改年月日 LocalDate withLocalDate = ldDate.withYear(2000); System.out.println(withLocalDate); //minus开头的方法表示减少，只能减少年月日 LocalDate minusLocalDate = ldDate.minusYears(1); System.out.println(minusLocalDate); //plus开头的方法表示增加，只能增加年月日 LocalDate plusLocalDate = ldDate.plusDays(1); System.out.println(plusLocalDate); //------------- // 判断今天是否是你的生日 LocalDate birDate = LocalDate.of(2000, 1, 1); LocalDate nowDate1 = LocalDate.now(); MonthDay birMd = MonthDay.of(birDate.getMonthValue(), birDate.getDayOfMonth()); MonthDay nowMd = MonthDay.from(nowDate1); System.out.println(\\\"今天是你的生日吗? \\\" + birMd.equals(nowMd));//今天是你的生日吗? \"]},{\"header\":\"LocalTime 时、分、秒\",\"slug\":\"localtime-时、分、秒\",\"contents\":[\"// 获取本地时间的日历对象。(包含 时分秒) LocalTime nowTime = LocalTime.now(); System.out.println(\\\"今天的时间:\\\" + nowTime); int hour = nowTime.getHour();//时 System.out.println(\\\"hour: \\\" + hour); int minute = nowTime.getMinute();//分 System.out.println(\\\"minute: \\\" + minute); int second = nowTime.getSecond();//秒 System.out.println(\\\"second:\\\" + second); int nano = nowTime.getNano();//纳秒 System.out.println(\\\"nano:\\\" + nano); System.out.println(\\\"------------------------------------\\\"); System.out.println(LocalTime.of(8, 20));//时分 System.out.println(LocalTime.of(8, 20, 30));//时分秒 System.out.println(LocalTime.of(8, 20, 30, 150));//时分秒纳秒 LocalTime mTime = LocalTime.of(8, 20, 30, 150); //is系列的方法 System.out.println(nowTime.isBefore(mTime)); System.out.println(nowTime.isAfter(mTime)); //with系列的方法，只能修改时、分、秒 System.out.println(nowTime.withHour(10)); //plus系列的方法，只能修改时、分、秒 System.out.println(nowTime.plusHours(10)); \"]},{\"header\":\"LocalDateTime 年、月、日、时、分、秒\",\"slug\":\"localdatetime-年、月、日、时、分、秒\",\"contents\":[\"// 当前时间的的日历对象(包含年月日时分秒) LocalDateTime nowDateTime = LocalDateTime.now(); System.out.println(\\\"今天是:\\\" + nowDateTime);//今天是： System.out.println(nowDateTime.getYear());//年 System.out.println(nowDateTime.getMonthValue());//月 System.out.println(nowDateTime.getDayOfMonth());//日 System.out.println(nowDateTime.getHour());//时 System.out.println(nowDateTime.getMinute());//分 System.out.println(nowDateTime.getSecond());//秒 System.out.println(nowDateTime.getNano());//纳秒 // 日:当年的第几天 System.out.println(\\\"dayofYear:\\\" + nowDateTime.getDayOfYear()); //星期 System.out.println(nowDateTime.getDayOfWeek()); System.out.println(nowDateTime.getDayOfWeek().getValue()); //月份 System.out.println(nowDateTime.getMonth()); System.out.println(nowDateTime.getMonth().getValue()); LocalDate ld = nowDateTime.toLocalDate(); System.out.println(ld); LocalTime lt = nowDateTime.toLocalTime(); System.out.println(lt.getHour()); System.out.println(lt.getMinute()); System.out.println(lt.getSecond()); \"]},{\"header\":\"Duration 时间间隔（秒，纳，秒）\",\"slug\":\"duration-时间间隔-秒-纳-秒\",\"contents\":[\"// 本地日期时间对象。 LocalDateTime today = LocalDateTime.now(); System.out.println(today); // 出生的日期时间对象 LocalDateTime birthDate = LocalDateTime.of(2000, 1, 1, 0, 0, 0); System.out.println(birthDate); Duration duration = Duration.between(birthDate, today);//第二个参数减第一个参数 System.out.println(\\\"相差的时间间隔对象:\\\" + duration); System.out.println(\\\"============================================\\\"); System.out.println(duration.toDays());//两个时间差的天数 System.out.println(duration.toHours());//两个时间差的小时数 System.out.println(duration.toMinutes());//两个时间差的分钟数 System.out.println(duration.toMillis());//两个时间差的毫秒数 System.out.println(duration.toNanos());//两个时间差的纳秒数 \"]},{\"header\":\"Period 时间间隔（年，月，日）\",\"slug\":\"period-时间间隔-年-月-日\",\"contents\":[\"// 当前本地 年月日 LocalDate today = LocalDate.now(); System.out.println(today); // 生日的 年月日 LocalDate birthDate = LocalDate.of(2000, 1, 1); System.out.println(birthDate); Period period = Period.between(birthDate, today);//第二个参数减第一个参数 System.out.println(\\\"相差的时间间隔对象:\\\" + period); System.out.println(period.getYears()); System.out.println(period.getMonths()); System.out.println(period.getDays()); System.out.println(period.toTotalMonths()); \"]},{\"header\":\"ChronoUnit 时间间隔（所有单位）\",\"slug\":\"chronounit-时间间隔-所有单位\",\"contents\":[\"// 当前时间 LocalDateTime today = LocalDateTime.now(); System.out.println(today); // 生日时间 LocalDateTime birthDate = LocalDateTime.of(2000, 1, 1,0, 0, 0); System.out.println(birthDate); System.out.println(\\\"相差的年数:\\\" + ChronoUnit.YEARS.between(birthDate, today)); System.out.println(\\\"相差的月数:\\\" + ChronoUnit.MONTHS.between(birthDate, today)); System.out.println(\\\"相差的周数:\\\" + ChronoUnit.WEEKS.between(birthDate, today)); System.out.println(\\\"相差的天数:\\\" + ChronoUnit.DAYS.between(birthDate, today)); System.out.println(\\\"相差的时数:\\\" + ChronoUnit.HOURS.between(birthDate, today)); System.out.println(\\\"相差的分数:\\\" + ChronoUnit.MINUTES.between(birthDate, today)); System.out.println(\\\"相差的秒数:\\\" + ChronoUnit.SECONDS.between(birthDate, today)); System.out.println(\\\"相差的毫秒数:\\\" + ChronoUnit.MILLIS.between(birthDate, today)); System.out.println(\\\"相差的微秒数:\\\" + ChronoUnit.MICROS.between(birthDate, today)); System.out.println(\\\"相差的纳秒数:\\\" + ChronoUnit.NANOS.between(birthDate, today)); System.out.println(\\\"相差的半天数:\\\" + ChronoUnit.HALF_DAYS.between(birthDate, today)); System.out.println(\\\"相差的十年数:\\\" + ChronoUnit.DECADES.between(birthDate, today)); System.out.println(\\\"相差的世纪(百年)数:\\\" + ChronoUnit.CENTURIES.between(birthDate, today)); System.out.println(\\\"相差的千年数:\\\" + ChronoUnit.MILLENNIA.between(birthDate, today)); System.out.println(\\\"相差的纪元数:\\\" + ChronoUnit.ERAS.between(birthDate, today)); \"]},{\"header\":\"18.2 包装类\",\"slug\":\"_18-2-包装类\",\"contents\":[\"Java提供了两个类型，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：\",\"基本类型\",\"对应的包装类（位于java.lang包中）\",\"byte\",\"Byte\",\"short\",\"Short\",\"int\",\"Integer\",\"long\",\"Long\",\"float\",\"Float\",\"double\",\"Double\",\"char\",\"Character\",\"boolean\",\"Boolean\"]},{\"header\":\"18.2.1 Integer类\",\"slug\":\"_18-2-1-integer类\",\"contents\":[\"Integer类概述\",\"包装一个对象中的原始类型 int 的值\",\"Integer类构造方法及静态方法\",\"方法名\",\"说明\",\"public Integer(int value)\",\"根据 int 值创建 Integer 对象(过时)\",\"public Integer(String s)\",\"根据 String 值创建 Integer 对象(过时)\",\"public static Integer valueOf(int i)\",\"返回表示指定的 int 值的 Integer 实例\",\"public static Integer valueOf(String s)\",\"返回保存指定String值的 Integer 对象\",\"static string tobinarystring(int i)\",\"得到二进制\",\"static string tooctalstring(int i)\",\"得到八进制\",\"static string toHexstring(int i)\",\"得到十六进制\",\"static int parseInt(string s)\",\"将字符串类型的整数转成int类型的整数\",\"示例代码\",\"//public Integer(int value)：根据 int 值创建 Integer 对象(过时) Integer i1 = new Integer(100); System.out.println(i1); //public Integer(String s)：根据 String 值创建 Integer 对象(过时) Integer i2 = new Integer(\\\"100\\\"); //Integer i2 = new Integer(\\\"abc\\\"); //NumberFormatException System.out.println(i2); System.out.println(\\\"--------\\\"); //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例 Integer i3 = Integer.valueOf(100); System.out.println(i3); //public static Integer valueOf(String s)：返回保存指定String值的Integer对象 Integer i4 = Integer.valueOf(\\\"100\\\"); System.out.println(i4); \"]},{\"header\":\"18.2.2 装箱与拆箱\",\"slug\":\"_18-2-2-装箱与拆箱\",\"contents\":[\"基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\",\"装箱：从基本类型转换为对应的包装类对象。\",\"拆箱：从包装类对象转换为对应的基本类型。\",\"基本数值---->包装对象\",\"Integer i = new Integer(4);//使用构造函数函数 Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法 \",\"包装对象---->基本数值\",\"int num = i.intValue(); \"]},{\"header\":\"18.2.3 自动装箱与自动拆箱\",\"slug\":\"_18-2-3-自动装箱与自动拆箱\",\"contents\":[\"由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\",\"Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4); i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; //加法运算完成后，再次装箱，把基本数值转成对象。 \"]},{\"header\":\"18.2.4 基本类型与字符串之间的转换\",\"slug\":\"_18-2-4-基本类型与字符串之间的转换\",\"contents\":[]},{\"header\":\"基本类型转换为String\",\"slug\":\"基本类型转换为string\",\"contents\":[\"方式一：直接在数字后加一个空字符串\",\"方式二：通过String类静态方法valueOf()\",\"示例代码\",\"public class IntegerDemo { public static void main(String[] args) { //int --- String int number = 100; //方式1 String s1 = number + \\\"\\\"; System.out.println(s1); //方式2 //public static String valueOf(int i) String s2 = String.valueOf(number); System.out.println(s2); } } \"]},{\"header\":\"String转换成基本类型\",\"slug\":\"string转换成基本类型\",\"contents\":[\"方式一：先将字符串数字转成Integer，再调用valueOf()方法\",\"方式二：通过Integer静态方法parseInt()进行转换\",\"除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\",\"public static byte parseByte(String s)：将字符串参数转换为对应的byte基本类型。\",\"public static short parseShort(String s)：将字符串参数转换为对应的short基本类型。\",\"public static int parseInt(String s)：将字符串参数转换为对应的int基本类型。\",\"public static long parseLong(String s)：将字符串参数转换为对应的long基本类型。\",\"public static float parseFloat(String s)：将字符串参数转换为对应的float基本类型。\",\"public static double parseDouble(String s)：将字符串参数转换为对应的double基本类型。\",\"public static boolean parseBoolean(String s)：将字符串参数转换为对应的boolean基本类型。\",\"示例代码\",\"public class IntegerDemo { public static void main(String[] args) { //String --- int String s = \\\"100\\\"; //方式1：String --- Integer --- int Integer i = Integer.valueOf(s); //public int intValue() int x = i.intValue(); System.out.println(x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(y); } } \"]},{\"header\":\"18.2.5 底层原理\",\"slug\":\"_18-2-5-底层原理\",\"contents\":[\"建议：获取Integer对象的时候不要自己new，而是采取直接赋值或者静态方法valueOf的方式\",\"因为在实际开发中，-128~127之间的数据，用的比较多。如果每次使用都是new对象，那么太浪费内存了。\",\"所以，提前把这个范围之内的每一个数据都创建好对象，如果要用到了不会创建新的，而是返回已经创建好的对象。\",\"//1.利用构造方法获取Integer的对象(JDK5以前的方式) /*Integer i1 = new Integer(1); Integer i2 = new Integer(\\\"1\\\"); System.out.println(i1); System.out.println(i2);*/ //2.利用静态方法获取Integer的对象(JDK5以前的方式) Integer i3 = Integer.valueOf(123); Integer i4 = Integer.valueOf(\\\"123\\\"); Integer i5 = Integer.valueOf(\\\"123\\\", 8); System.out.println(i3); System.out.println(i4); System.out.println(i5); //3.这两种方式获取对象的区别(掌握) //底层原理： //因为在实际开发中，-128~127之间的数据，用的比较多。 //如果每次使用都是new对象，那么太浪费内存了 //所以，提前把这个范围之内的每一个数据都创建好对象 //如果要用到了不会创建新的，而是返回已经创建好的对象。 Integer i6 = Integer.valueOf(127); Integer i7 = Integer.valueOf(127); System.out.println(i6 == i7);//true Integer i8 = Integer.valueOf(128); Integer i9 = Integer.valueOf(128); System.out.println(i8 == i9);//false //因为看到了new关键字，在Java中，每一次new都是创建了一个新的对象 //所以下面的两个对象都是new出来，地址值不一样。 /*Integer i10 = new Integer(127); Integer i11 = new Integer(127); System.out.println(i10 == i11); Integer i12 = new Integer(128); Integer i13 = new Integer(128); System.out.println(i12 == i13);*/ \"]}]},\"/BackEnd/JavaSE/Javase05.html\":{\"title\":\"JDK8新特性\",\"contents\":[{\"header\":\"19 内部类\",\"slug\":\"_19-内部类\",\"contents\":[\"将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类。可以把内部类理解成寄生，外部类理解成宿主。\"]},{\"header\":\"19.1 内部类分类\",\"slug\":\"_19-1-内部类分类\",\"contents\":[\"成员内部内，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)\",\"静态内部类，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)\",\"局部内部类，类定义在方法内\",\"匿名内部类，没有名字的内部类，可以在方法中，也可以在类中方法外。\"]},{\"header\":\"19.2 成员内部类\",\"slug\":\"_19-2-成员内部类\",\"contents\":[\"成员内部类特点：\",\"无static修饰的内部类，属于外部类对象的。\",\"宿主：外部类对象。\",\"内部类的使用格式：\",\" 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类 \",\"获取成员内部类对象的两种方式：\",\"方式一：外部直接创建成员内部类的对象\",\"外部类.内部类 变量 = new 外部类（）.new 内部类（）; \",\"方式二：在外部类中定义一个方法提供内部类的对象\",\"案例演示:\",\"方式一： public class Test { public static void main(String[] args) { // 宿主：外部类对象。 // Outer out = new Outer(); // 创建内部类对象。 Outer.Inner oi = new Outer().new Inner(); oi.method(); } } class Outer { // 成员内部类，属于外部类对象的。 // 拓展：成员内部类不能定义静态成员。 public class Inner{ // 这里面的东西与类是完全一样的。 public void method(){ System.out.println(\\\"内部类中的方法被调用了\\\"); } } } 方式二： public class Outer { String name; private class Inner{ static int a = 10; } public Inner getInstance(){ return new Inner(); } } public class Test { public static void main(String[] args) { Outer o = new Outer(); System.out.println(o.getInstance()); } } \"]},{\"header\":\"19.3 静态内部类\",\"slug\":\"_19-3-静态内部类\",\"contents\":[\"静态内部类特点：静态内部类是一种特殊的成员内部类。\",\"有static修饰，属于外部类本身的。\",\"总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。\",\"拓展1:静态内部类可以直接访问外部类的静态成员。\",\"拓展2:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。\",\"拓展3:静态内部类中没有银行的Outer.this。\",\"静态内部类对象的创建格式：\",\"外部类.内部类 变量 = new 外部类.内部类构造器; \",\"调用方法的格式：\",\"调用非静态方法的格式：先创建对象，用对象调用\",\"调用静态方法的格式：外部类名.内部类名.方法名();\",\"案例演示：\",\"// 外部类：Outer01 class Outer01{ private static String sc_name = \\\"黑马程序\\\"; // 内部类: Inner01 public static class Inner01{ // 这里面的东西与类是完全一样的。 private String name; public Inner01(String name) { this.name = name; } public void showName(){ System.out.println(this.name); // 拓展:静态内部类可以直接访问外部类的静态成员。 System.out.println(sc_name); } } } public class InnerClassDemo01 { public static void main(String[] args) { // 创建静态内部类对象。 // 外部类.内部类 变量 = new 外部类.内部类构造器; Outer01.Inner01 in = new Outer01.Inner01(\\\"张三\\\"); in.showName(); } } \"]},{\"header\":\"19.4 局部内部类\",\"slug\":\"_19-4-局部内部类\",\"contents\":[\"局部内部类 ：定义在方法中的类。\",\"定义格式:\",\"class 外部类名 { 数据类型 变量名; 修饰符 返回值类型 方法名(参数列表) { // … class 内部类 { // 成员变量 // 成员方法 } } } \"]},{\"header\":\"19.5 匿名内部类\",\"slug\":\"_19-5-匿名内部类\",\"contents\":[\"匿名内部类 ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。\",\"格式\",\"new 类名或者接口名() { 重写方法; }; \",\"包含了：\",\"继承或者实现关系\",\"方法重写\",\"创建对象\",\"所以从语法上来讲，这个整体其实是匿名内部类对象\"]},{\"header\":\"什么时候用到匿名内部类\",\"slug\":\"什么时候用到匿名内部类\",\"contents\":[\"实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用是为了简化代码。\",\"匿名内部类必须继承一个父类或者实现一个父接口。\",\"匿名内部类格式：\",\"new 父类名或者接口名(){ // 方法重写 @Override public void method() { // 执行语句 } }; \"]},{\"header\":\"匿名内部类的特点\",\"slug\":\"匿名内部类的特点\",\"contents\":[\"定义一个没有名字的内部类\",\"这个类实现了父类，或者父类接口\",\"匿名内部类会创建这个没有名字的类的对象\"]},{\"header\":\"匿名内部类的使用场景\",\"slug\":\"匿名内部类的使用场景\",\"contents\":[\"interface Swim { public abstract void swimming(); } public class Demo07 { public static void main(String[] args) { // 普通方式传入对象 // 创建实现类对象 Student s = new Student(); goSwimming(s); // 匿名内部类使用场景:作为方法参数传递 Swim s3 = new Swim() { @Override public void swimming() { System.out.println(\\\"蝶泳...\\\"); } }; // 传入匿名内部类 goSwimming(s3); // 完美方案: 一步到位 goSwimming(new Swim() { public void swimming() { System.out.println(\\\"大学生, 蛙泳...\\\"); } }); goSwimming(new Swim() { public void swimming() { System.out.println(\\\"小学生, 自由泳...\\\"); } }); } // 定义一个方法,模拟请一些人去游泳 public static void goSwimming(Swim s) { s.swimming(); } } \"]},{\"header\":\"20 lambda\",\"slug\":\"_20-lambda\",\"contents\":[]},{\"header\":\"20.1 lambda\",\"slug\":\"_20-1-lambda\",\"contents\":[]},{\"header\":\"20.1.1 Lambda表达式标准格式\",\"slug\":\"_20-1-1-lambda表达式标准格式\",\"contents\":[\"匿名内部类中重写show()方法的代码分析：\",\"方法形式参数为空，说明调用方法时不需要传递参数\",\"方法返回值类型为void，说明方法执行没有结果返回\",\"方法体中的内容，是我们具体要做的事情\",\"1640937934823\",\"Lambda表达式的代码分析：\",\"()：里面没有内容，可以看成是方法形式参数为空\",\"->：用箭头指向后面要做的事情\",\"{ }：包含一段代码，我们称之为代码块，可以看成是方法体中的内容\",\"1640937940842\",\"组成Lambda表达式的三要素：形式参数，箭头，代码块\",\"Lambda表达式的格式:\",\"格式：(形式参数) -> {代码块}\",\"形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可\",\"->：由英文中划线和大于符号组成，固定写法。代表指向动作\",\"代码块：是我们具体要做的事情，也就是以前我们写的方法体内容\",\"总结起来就是一句话：拿着形式参数去做代码块中的事情\",\"Lambda表达式的使用前提：:\",\"有一个接口\",\"接口中只能有一个抽象方法\",\"练习1:\",\"定义一个接口(Eatable)，里面定义一个抽象方法：void eat();\",\"定义一个测试类(EatableDemo)，在测试类中提供两个方法 \",\"一个方法是：useEatable(Eatable e)\",\"一个方法是主方法，在主方法中调用useEatable方法\",\"public interface Eatable { void eat(); } \",\"/* Lambda表达式的格式：(形式参数) -> {代码块} */ public class EatableDemo { public static void main(String[] args) { //在主方法中调用useEatable方法 //匿名内部类 useEatable(new Eatable() { @Override public void eat() { System.out.println(\\\"一天一苹果，医生远离我\\\"); } }); //Lambda表达式 useEatable(() -> { System.out.println(\\\"一天一苹果，医生远离我\\\"); }); } private static void useEatable(Eatable e) { e.eat(); } } \",\"练习2(带参无返回值):\",\"定义一个接口(Flyable)，里面定义一个抽象方法：void fly(String s);\",\"定义一个测试类(FlyableDemo)，在测试类中提供两个方法\",\"一个方法是：useFlyable(Flyable f)\",\"一个方法是主方法，在主方法中调用useFlyable方法\",\"知道了要做什么之后，下面我们到IDEA中去演示一下：\",\"public interface Flyable { void fly(String s); } /* Lambda表达式的格式：(形式参数) -> {代码块} */ public class FlyableDemo { public static void main(String[] args) { //在主方法中调用useFlyable方法 //匿名内部类 useFlyable(new Flyable() { @Override public void fly(String s) { System.out.println(s); System.out.println(\\\"飞机自驾游\\\"); } }); System.out.println(\\\"--------\\\"); //Lambda useFlyable((String s) -> { System.out.println(s); System.out.println(\\\"飞机自驾游\\\"); }); } private static void useFlyable(Flyable f) { f.fly(\\\"风和日丽，晴空万里\\\"); } } \",\"练习3(带参带返回值):\",\"定义一个接口(Addable)，里面定义一个抽象方法：int add(int x,int y);\",\"定义一个测试类(AddableDemo)，在测试类中提供两个方法\",\"一个方法是：useAddable(Addable a)\",\"一个方法是主方法，在主方法中调用useAddable方法\",\"public interface Addable { int add(int x,int y); } \",\"/* Lambda表达式的格式：(形式参数) -> {代码块} */ public class AddableDemo { public static void main(String[] args) { //在主方法中调用useAddable方法 useAddable((int x,int y) -> { return x + y; // return x - y; }); } private static void useAddable(Addable a) { int sum = a.add(10, 20); System.out.println(sum); } } \"]},{\"header\":\"20.1.2 Lambda的省略模式\",\"slug\":\"_20-1-2-lambda的省略模式\",\"contents\":[\"public interface Addable { int add(int x, int y); } \",\"public interface Flyable { void fly(String s); } \",\"/* Lambda表达式的省略模式 */ public class LambdaDemo { public static void main(String[] args) { // useAddable((int x,int y) -> { // return x + y; // }); //参数的类型可以省略 useAddable((x, y) -> { return x + y; }); //但是有多个参数的情况下，不能只省略一个 // useAddable((x,int y) -> { // return x + y; // }); // useFlyable((String s) -> { // System.out.println(s); // }); // useFlyable((s) -> { // System.out.println(s); // }); //如果参数有且仅有一个，那么小括号可以省略 // useFlyable(s -> { // System.out.println(s); // }); //如果代码块的语句只有一条，可以省略大括号和分号 useFlyable(s -> System.out.println(s)); //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉 useAddable((x, y) -> x + y); } private static void useFlyable(Flyable f) { f.fly(\\\"风和日丽，晴空万里\\\"); } private static void useAddable(Addable a) { int sum = a.add(10, 20); System.out.println(sum); } } \",\"省略规则：\",\"参数类型可以省略。但是有多个参数的情况下，不能只省略一个\",\"如果参数有且仅有一个，那么小括号可以省略\",\"如果代码块的语句只有一条，可以省略大括号和分号，甚至是return\"]},{\"header\":\"20.1.3 Lambda和匿名内部类的区别\",\"slug\":\"_20-1-3-lambda和匿名内部类的区别\",\"contents\":[\"public interface Inter { void show(); // void show2(); } \",\"public abstract class Animal { public abstract void method(); } \",\"public class Student { public void study() { System.out.println(\\\"爱生活，爱Java\\\"); } } \",\"/* Lambda表达式和匿名内部类的区别 */ public class LambdaDemo { public static void main(String[] args) { //匿名内部类 /* useInter(new Inter() { @Override public void show() { System.out.println(\\\"接口\\\"); } }); useAnimal(new Animal() { @Override public void method() { System.out.println(\\\"抽象类\\\"); } }); useStudent(new Student(){ @Override public void study() { System.out.println(\\\"具体类\\\"); } }); */ useInter(new Inter() { @Override public void show() { System.out.println(\\\"接口\\\"); } }); //Lambda // useInter(() -> System.out.println(\\\"接口\\\")); // useAnimal(() -> System.out.println(\\\"抽象类\\\")); // useStudent(() -> System.out.println(\\\"具体类\\\")); // useInter(() -> System.out.println(\\\"接口\\\")); // useInter(new Inter() { // @Override // public void show() { // System.out.println(\\\"show\\\"); // } // // @Override // public void show2() { // System.out.println(\\\"show2\\\"); // } // }); } private static void useStudent(Student s) { s.study(); } private static void useAnimal(Animal a) { a.method(); } private static void useInter(Inter i) { i.show(); } } \",\"所需类型不同\",\"匿名内部类：可以是接口，也可以是抽象类，还可以是具体类\",\"Lambda表达式：只能是接口\",\"使用限制不同\",\"如果接口中仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类\",\"如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式\",\"实现原理不同\",\"匿名内部类：编译之后，产生一个单独的.class字节码文件\",\"Lambda表达式：编译之后，你没有看到一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成\"]},{\"header\":\"21 Stream流、方法引用\",\"slug\":\"_21-stream流、方法引用\",\"contents\":[]},{\"header\":\"21.1 Stream流\",\"slug\":\"_21-1-stream流\",\"contents\":[\"Stream流的好处\",\"直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤、逐一打印\",\"Stream流把真正的函数式编程风格引入到Java中\",\"代码简洁\"]},{\"header\":\"21.1.1 Stream流的常见生成方式\",\"slug\":\"_21-1-1-stream流的常见生成方式\",\"contents\":[\"01_Stream流思想\",\"Stream流的三类方法\",\"获取Stream流 \",\"创建一条流水线,并把数据放到流水线上准备进行操作\",\"中间方法 \",\"流水线上的操作\",\"一次操作完毕之后,还可以继续进行其他操作\",\"终结方法 \",\"一个Stream流只能有一个终结方法\",\"是流水线上的最后一个操作\"]},{\"header\":\"生成Stream流的方式\",\"slug\":\"生成stream流的方式\",\"contents\":[\"public class StreamDemo { public static void main(String[] args) { //Collection体系的集合可以使用默认方法stream()生成流 List<String> list = new ArrayList<String>(); Stream<String> listStream = list.stream(); Set<String> set = new HashSet<String>(); Stream<String> setStream = set.stream(); //Map体系的集合间接的生成流 Map<String,Integer> map = new HashMap<String, Integer>(); Stream<String> keyStream = map.keySet().stream(); Stream<Integer> valueStream = map.values().stream(); Stream<Map.Entry<String, Integer>> entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = {\\\"hello\\\",\\\"world\\\",\\\"java\\\"}; Stream<String> strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream<String> strArrayStream2 = Stream.of(\\\"hello\\\", \\\"world\\\", \\\"java\\\"); Stream<Integer> intStream = Stream.of(10, 20, 30); } } \"]},{\"header\":\"Stream流中间操作方法\",\"slug\":\"stream流中间操作方法\",\"contents\":[\"filter代码演示\",\"public class MyStream3 { public static void main(String[] args) { // Stream<T> filter(Predicate predicate)：过滤 // Predicate接口中的方法boolean test(T t)：对给定的参数进行判断，返回一个布尔值 ArrayList<String> list = new ArrayList<>(); list.add(\\\"张三丰\\\"); list.add(\\\"张无忌\\\"); list.add(\\\"张翠山\\\"); list.add(\\\"王二麻子\\\"); list.add(\\\"张良\\\"); list.add(\\\"谢广坤\\\"); //filter方法获取流中的 每一个数据. //而test方法中的s,就依次表示流中的每一个数据. //我们只要在test方法中对s进行判断就可以了. //如果判断的结果为true,则当前的数据留下 //如果判断的结果为false,则当前数据就不要. // list.stream().filter( // new Predicate<String>() { // @Override // public boolean test(String s) { // boolean result = s.startsWith(\\\"张\\\"); // return result; // } // } // ).forEach(s-> System.out.println(s)); //因为Predicate接口中只有一个抽象方法test //所以我们可以使用lambda表达式来简化 // list.stream().filter( // (String s)->{ // boolean result = s.startsWith(\\\"张\\\"); // return result; // } // ).forEach(s-> System.out.println(s)); list.stream().filter(s ->s.startsWith(\\\"张\\\")).forEach(s-> System.out.println(s)); } } \",\"limit&skip代码演示\",\"public class StreamDemo02 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList<String> list = new ArrayList<String>(); list.add(\\\"林青霞\\\"); list.add(\\\"张曼玉\\\"); list.add(\\\"王祖贤\\\"); list.add(\\\"柳岩\\\"); list.add(\\\"张敏\\\"); list.add(\\\"张无忌\\\"); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(s-> System.out.println(s)); System.out.println(\\\"--------\\\"); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(s-> System.out.println(s)); System.out.println(\\\"--------\\\"); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(s-> System.out.println(s)); } } \",\"concat&distinct代码演示\",\"public class StreamDemo03 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList<String> list = new ArrayList<String>(); list.add(\\\"林青霞\\\"); list.add(\\\"张曼玉\\\"); list.add(\\\"王祖贤\\\"); list.add(\\\"柳岩\\\"); list.add(\\\"张敏\\\"); list.add(\\\"张无忌\\\"); //需求1：取前4个数据组成一个流 Stream<String> s1 = list.stream().limit(4); //需求2：跳过2个数据组成一个流 Stream<String> s2 = list.stream().skip(2); //需求3：合并需求1和需求2得到的流，并把结果在控制台输出 // Stream.concat(s1,s2).forEach(s-> System.out.println(s)); //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复 Stream.concat(s1,s2).distinct().forEach(s-> System.out.println(s)); } } \"]},{\"header\":\"Stream流终结操作方法\",\"slug\":\"stream流终结操作方法\",\"contents\":[\"概念\",\"终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作\",\"常见方法\",\"方法名\",\"说明\",\"void forEach(Consumer action)\",\"对此流的每个元素执行操作\",\"long count()\",\"返回此流中的元素数\",\"代码演示\",\"public class MyStream5 { public static void main(String[] args) { ArrayList<String> list = new ArrayList<>(); list.add(\\\"张三丰\\\"); list.add(\\\"张无忌\\\"); list.add(\\\"张翠山\\\"); list.add(\\\"王二麻子\\\"); list.add(\\\"张良\\\"); list.add(\\\"谢广坤\\\"); //method1(list); // long count()：返回此流中的元素数 long count = list.stream().count(); System.out.println(count); } private static void method1(ArrayList<String> list) { // void forEach(Consumer action)：对此流的每个元素执行操作 // Consumer接口中的方法void accept(T t)：对给定的参数执行此操作 //在forEach方法的底层,会循环获取到流中的每一个数据. //并循环调用accept方法,并把每一个数据传递给accept方法 //s就依次表示了流中的每一个数据. //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了. list.stream().forEach( new Consumer<String>() { @Override public void accept(String s) { System.out.println(s); } } ); System.out.println(\\\"====================\\\"); //lambda表达式的简化格式 //是因为Consumer接口中,只有一个accept方法 list.stream().forEach( (String s)->{ System.out.println(s); } ); System.out.println(\\\"====================\\\"); //lambda表达式还是可以进一步简化的. list.stream().forEach(s->System.out.println(s)); } } \"]},{\"header\":\"Stream流的收集操作\",\"slug\":\"stream流的收集操作\",\"contents\":[\"概念\",\"对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中\",\"常用方法\",\"方法名\",\"说明\",\"R collect(Collector collector)\",\"把结果收集到集合中\",\"工具类Collectors提供了具体的收集方式\",\"方法名\",\"说明\",\"public static <T> Collector toList()\",\"把元素收集到List集合中\",\"public static <T> Collector toSet()\",\"把元素收集到Set集合中\",\"public static Collector toMap(Function keyMapper,Function valueMapper)\",\"把元素收集到Map集合中\",\"代码演示\",\"// toList和toSet方法演示 public class MyStream7 { public static void main(String[] args) { ArrayList<Integer> list1 = new ArrayList<>(); for (int i = 1; i <= 10; i++) { list1.add(i); } list1.add(10); list1.add(10); list1.add(10); list1.add(10); list1.add(10); //filter负责过滤数据的. //collect负责收集数据. //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中. //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中. List<Integer> list = list1.stream().filter(number -> number % 2 == 0) .collect(Collectors.toList()); System.out.println(list); Set<Integer> set = list1.stream().filter(number -> number % 2 == 0) .collect(Collectors.toSet()); System.out.println(set); } } /** Stream流的收集方法 toMap方法演示 创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄 \\\"zhangsan,23\\\" \\\"lisi,24\\\" \\\"wangwu,25\\\" 保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值 */ public class MyStream8 { public static void main(String[] args) { ArrayList<String> list = new ArrayList<>(); list.add(\\\"zhangsan,23\\\"); list.add(\\\"lisi,24\\\"); list.add(\\\"wangwu,25\\\"); Map<String, Integer> map = list.stream().filter( s -> { String[] split = s.split(\\\",\\\"); int age = Integer.parseInt(split[1]); return age >= 24; } // collect方法只能获取到流中剩余的每一个数据. //在底层不能创建容器,也不能把数据添加到容器当中 //Collectors.toMap 创建一个map集合并将数据添加到集合当中 // s 依次表示流中的每一个数据 //第一个lambda表达式就是如何获取到Map中的键 //第二个lambda表达式就是如何获取Map中的值 ).collect(Collectors.toMap( s -> s.split(\\\",\\\")[0], s -> Integer.parseInt(s.split(\\\",\\\")[1]) )); System.out.println(map); } } \"]},{\"header\":\"Stream流综合练习\",\"slug\":\"stream流综合练习\",\"contents\":[\"案例需求\",\"现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作\",\"男演员只要名字为3个字的前三人\",\"女演员只要姓林的，并且不要第一个\",\"把过滤后的男演员姓名和女演员姓名合并到一起\",\"把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据\",\"演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法\",\"代码实现\",\"演员类\",\"public class Actor { private String name; public Actor(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } \",\"测试类\",\"public class StreamTest { public static void main(String[] args) { //创建集合 ArrayList<String> manList = new ArrayList<String>(); manList.add(\\\"周润发\\\"); manList.add(\\\"成龙\\\"); manList.add(\\\"刘德华\\\"); manList.add(\\\"吴京\\\"); manList.add(\\\"周星驰\\\"); manList.add(\\\"李连杰\\\"); ArrayList<String> womanList = new ArrayList<String>(); womanList.add(\\\"林心如\\\"); womanList.add(\\\"张曼玉\\\"); womanList.add(\\\"林青霞\\\"); womanList.add(\\\"柳岩\\\"); womanList.add(\\\"林志玲\\\"); womanList.add(\\\"王祖贤\\\"); //男演员只要名字为3个字的前三人 Stream<String> manStream = manList.stream().filter(s -> s.length() == 3).limit(3); //女演员只要姓林的，并且不要第一个 Stream<String> womanStream = womanList.stream().filter(s -> s.startsWith(\\\"林\\\")).skip(1); //把过滤后的男演员姓名和女演员姓名合并到一起 Stream<String> stream = Stream.concat(manStream, womanStream); // 将流中的数据封装成Actor对象之后打印 stream.forEach(name -> { Actor actor = new Actor(name); System.out.println(actor); }); } } \"]},{\"header\":\"21.2 方法引用\",\"slug\":\"_21-2-方法引用\",\"contents\":[]},{\"header\":\"21.2.1 体验方法引用\",\"slug\":\"_21-2-1-体验方法引用\",\"contents\":[\"方法引用的出现原因\",\"在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作\",\"那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要\",\"那我们又是如何使用已经存在的方案的呢？\",\"这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案\",\"代码演示\",\" public interface Printable { void printString(String s); } public class PrintableDemo { public static void main(String[] args) { //在主方法中调用usePrintable方法 // usePrintable((String s) -> { // System.out.println(s); // }); //Lambda简化写法 usePrintable(s -> System.out.println(s)); //方法引用 usePrintable(System.out::println); } private static void usePrintable(Printable p) { p.printString(\\\"爱生活爱Java\\\"); } } \"]},{\"header\":\"21.2.2 方法引用符\",\"slug\":\"_21-2-2-方法引用符\",\"contents\":[\"方法引用符\",\":: 该符号为引用运算符，而它所在的表达式被称为方法引用\",\"推导与省略\",\"如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导\",\"如果使用方法引用，也是同样可以根据上下文进行推导\",\"方法引用是Lambda的孪生兄弟\"]}]},\"/BackEnd/JavaSE/Javase06.html\":{\"title\":\"集合框架\",\"contents\":[{\"header\":\"22 Collection、List\",\"slug\":\"_22-collection、list\",\"contents\":[]},{\"header\":\"22.1 Collection\",\"slug\":\"_22-1-collection\",\"contents\":[]},{\"header\":\"22.1.1 数组和集合的区别\",\"slug\":\"_22-1-1-数组和集合的区别\",\"contents\":[\"相同点\",\"都是容器,可以存储多个数据\",\"不同点\",\"数组的长度是不可变的,集合的长度是可变的\",\"数组可以存基本数据类型和引用数据类型\",\"集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类\"]},{\"header\":\"22.1.2 集合类体系结构\",\"slug\":\"_22-1-2-集合类体系结构\",\"contents\":[\"01_集合类体系结构图\"]},{\"header\":\"22.1.3 Collection 集合概述和使用\",\"slug\":\"_22-1-3-collection-集合概述和使用\",\"contents\":[\"Collection集合概述\",\"是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素\",\"JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现\",\"创建Collection集合的对象\",\"多态的方式\",\"具体的实现类ArrayList\",\"Collection集合常用方法\",\"方法名\",\"说明\",\"boolean add(E e)\",\"添加元素\",\"boolean remove(Object o)\",\"从集合中移除指定的元素\",\"boolean removeIf(Object o)\",\"根据条件进行移除\",\"void clear()\",\"清空集合中的元素\",\"boolean contains(Object o)\",\"判断集合中是否存在指定的元素\",\"boolean isEmpty()\",\"判断集合是否为空\",\"int size()\",\"集合的长度，也就是集合中元素的个数\"]},{\"header\":\"22.1.4 Collection集合的遍历\",\"slug\":\"_22-1-4-collection集合的遍历\",\"contents\":[\"迭代器,集合的专用遍历方式\",\"Iterator<E> iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到\",\"Iterator中的常用方法\",\"boolean hasNext(): 判断当前位置是否有元素可以被取出\",\"E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置\",\"Collection集合的遍历:\",\"public class IteratorDemo1 { public static void main(String[] args) { //创建集合对象 Collection<String> c = new ArrayList<>(); //添加元素 c.add(\\\"hello\\\"); c.add(\\\"world\\\"); c.add(\\\"java\\\"); c.add(\\\"javaee\\\"); //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 Iterator<String> it = c.iterator(); //用while循环改进元素的判断和获取 while (it.hasNext()) { String s = it.next(); System.out.println(s); } } } \"]},{\"header\":\"增强for循环\",\"slug\":\"增强for循环\",\"contents\":[\"介绍\",\"它是JDK5之后出现的,其内部原理是一个Iterator迭代器\",\"实现Iterable接口的类才可以使用迭代器和增强for\",\"简化数组和Collection集合的遍历\",\"格式\",\" for(集合/数组中元素的数据类型 变量名 : 集合/数组名) { // 已经将当前遍历到的元素封装到变量中了,直接使用变量即可 } \",\"代码\",\"public class MyCollectonDemo1 { public static void main(String[] args) { ArrayList<String> list = new ArrayList<>(); list.add(\\\"a\\\"); list.add(\\\"b\\\"); list.add(\\\"c\\\"); list.add(\\\"d\\\"); list.add(\\\"e\\\"); list.add(\\\"f\\\"); //1,数据类型一定是集合或者数组中元素的类型 //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素 //3,list就是要遍历的集合或者数组 for(String str : list){ System.out.println(str); } } } \"]},{\"header\":\"22.2 List\",\"slug\":\"_22-2-list\",\"contents\":[]},{\"header\":\"22.2.1 List集合的概述和特点\",\"slug\":\"_22-2-1-list集合的概述和特点\",\"contents\":[\"List集合的概述 \",\"有序集合,这里的有序指的是存取顺序\",\"用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素\",\"与Set集合不同,列表通常允许重复的元素\",\"List集合的特点 \",\"存取有序\",\"可以重复\",\"有索引\"]},{\"header\":\"22.2.2 List集合的特有方法\",\"slug\":\"_22-2-2-list集合的特有方法\",\"contents\":[\"方法名\",\"描述\",\"void add(int index,E element)\",\"在此集合中的指定位置插入指定的元素\",\"E remove(int index)\",\"删除指定索引处的元素，返回被删除的元素\",\"E set(int index,E element)\",\"修改指定索引处的元素，返回被修改的元素\",\"E get(int index)\",\"返回指定索引处的元素\"]},{\"header\":\"22.2.3 List集合的实现类\",\"slug\":\"_22-2-3-list集合的实现类\",\"contents\":[]},{\"header\":\"List集合子类的特点\",\"slug\":\"list集合子类的特点\",\"contents\":[\"ArrayList集合\",\"底层是数组结构实现，查询快、增删慢\",\"LinkedList集合\",\"底层是链表结构实现，查询慢、增删快\"]},{\"header\":\"LinkedList集合的特有功能\",\"slug\":\"linkedlist集合的特有功能\",\"contents\":[\"方法名\",\"说明\",\"public void addFirst(E e)\",\"在该列表开头插入指定的元素\",\"public void addLast(E e)\",\"将指定的元素追加到此列表的末尾\",\"public E getFirst()\",\"返回此列表中的第一个元素\",\"public E getLast()\",\"返回此列表中的最后一个元素\",\"public E removeFirst()\",\"从此列表中删除并返回第一个元素\",\"public E removeLast()\",\"从此列表中删除并返回最后一个元素\"]},{\"header\":\"23 泛型、Set\",\"slug\":\"_23-泛型、set\",\"contents\":[]},{\"header\":\"23.1 泛型\",\"slug\":\"_23-1-泛型\",\"contents\":[\"泛型的介绍\",\"泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制\",\"泛型的好处\",\"把运行时期的问题提前到了编译期间\",\"避免了强制类型转换\",\"泛型的定义格式\",\"<类型>: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: <E> <T>\",\"<类型1,类型2…>: 指定多种类型的格式,多种类型之间用逗号隔开.例如: <E,T> <K,V>\"]},{\"header\":\"23.2 Set集合\",\"slug\":\"_23-2-set集合\",\"contents\":[\"不可以存储重复元素\",\"没有索引,不能使用普通for循环遍历\"]},{\"header\":\"23.2.1 Set集合的使用\",\"slug\":\"_23-2-1-set集合的使用\",\"contents\":[\"public class MySet1 { public static void main(String[] args) { //创建集合对象 Set<String> set = new TreeSet<>(); //添加元素 set.add(\\\"ccc\\\"); set.add(\\\"aaa\\\"); set.add(\\\"aaa\\\"); set.add(\\\"bbb\\\"); // for (int i = 0; i < set.size(); i++) { // //Set集合是没有索引的，所以不能使用通过索引获取元素的方法 // } //遍历集合 Iterator<String> it = set.iterator(); while (it.hasNext()){ String s = it.next(); System.out.println(s); } System.out.println(\\\"-----------------------------------\\\"); for (String s : set) { System.out.println(s); } } } \"]},{\"header\":\"23.2.2 TreeSet集合\",\"slug\":\"_23-2-2-treeset集合\",\"contents\":[\"不可以存储重复元素\",\"没有索引\",\"可以将元素按照规则进行排序 \",\"TreeSet()：根据其元素的自然排序进行排序\",\"TreeSet(Comparator comparator) ：根据指定的比较器进行排序\"]},{\"header\":\"TreeSet集合基本使用\",\"slug\":\"treeset集合基本使用\",\"contents\":[\"public class TreeSetDemo01 { public static void main(String[] args) { //创建集合对象 TreeSet<Integer> ts = new TreeSet<Integer>(); //添加元素 ts.add(10); ts.add(40); ts.add(30); ts.add(50); ts.add(20); // ts.add(30); //遍历集合 for(Integer i : ts) { System.out.println(i); } } } \"]},{\"header\":\"自然排序Comparable的使用\",\"slug\":\"自然排序comparable的使用\",\"contents\":[\"案例需求\",\"存储学生对象并遍历，创建TreeSet集合使用无参构造方法\",\"要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\",\"实现步骤\",\"使用空参构造创建TreeSet集合 \",\"用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的\",\"自定义的Student类实现Comparable接口 \",\"自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法\",\"重写接口中的compareTo方法 \",\"重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\",\"代码实现： 学生类\",\"public class Student implements Comparable<Student>{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \\\"Student{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", age=\\\" + age + '}'; } @Override public int compareTo(Student o) { //按照对象的年龄进行排序 //主要判断条件: 按照年龄从小到大排序 int result = this.age - o.age; //次要判断条件: 年龄相同时，按照姓名的字母顺序排序 result = result == 0 ? this.name.compareTo(o.getName()) : result; return result; } } \",\"测试类\",\"public class MyTreeSet2 { public static void main(String[] args) { //创建集合对象 TreeSet<Student> ts = new TreeSet<>(); //创建学生对象 Student s1 = new Student(\\\"zhangsan\\\",28); Student s2 = new Student(\\\"lisi\\\",27); Student s3 = new Student(\\\"wangwu\\\",29); Student s4 = new Student(\\\"zhaoliu\\\",28); Student s5 = new Student(\\\"qianqi\\\",30); //把学生添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); //遍历集合 for (Student student : ts) { System.out.println(student); } } } \"]},{\"header\":\"比较器排序Comparator的使用\",\"slug\":\"比较器排序comparator的使用\",\"contents\":[\"案例需求\",\"存储老师对象并遍历，创建TreeSet集合使用带参构造方法\",\"要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\",\"实现步骤\",\"用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的\",\"比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法\",\"重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写\",\"代码实现：\",\"老师类\",\"public class Teacher { private String name; private int age; public Teacher() { } public Teacher(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \\\"Teacher{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", age=\\\" + age + '}'; } } \",\"测试类\",\"public class MyTreeSet4 { public static void main(String[] args) { //创建集合对象 TreeSet<Teacher> ts = new TreeSet<>(new Comparator<Teacher>() { @Override public int compare(Teacher o1, Teacher o2) { //o1表示现在要存入的那个元素 //o2表示已经存入到集合中的元素 //主要条件 int result = o1.getAge() - o2.getAge(); //次要条件 result = result == 0 ? o1.getName().compareTo(o2.getName()) : result; return result; } }); //创建老师对象 Teacher t1 = new Teacher(\\\"zhangsan\\\",23); Teacher t2 = new Teacher(\\\"lisi\\\",22); Teacher t3 = new Teacher(\\\"wangwu\\\",24); Teacher t4 = new Teacher(\\\"zhaoliu\\\",24); //把老师添加到集合 ts.add(t1); ts.add(t2); ts.add(t3); ts.add(t4); //遍历集合 for (Teacher teacher : ts) { System.out.println(teacher); } } } \"]},{\"header\":\"两种比较方式总结\",\"slug\":\"两种比较方式总结\",\"contents\":[\"两种比较方式小结 \",\"自然排序: 自定义类实现Comparable接口, 重写compareTo方法,根据返回值进行排序\",\"比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序\",\"在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序\",\"两种方式中关于返回值的规则 \",\"如果返回值为负数，表示当前存入的元素是较小值，存左边\",\"如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存\",\"如果返回值为正数，表示当前存入的元素是较大值，存右边\"]},{\"header\":\"23.2.3 HashSet集合\",\"slug\":\"_23-2-3-hashset集合\",\"contents\":[\"底层数据结构是哈希表\",\"存取无序\",\"不可以存储重复元素\",\"没有索引,不能使用普通for循环遍历\"]},{\"header\":\"HashSet集合的基本应用\",\"slug\":\"hashset集合的基本应用\",\"contents\":[\"public class HashSetDemo { public static void main(String[] args) { //创建集合对象 HashSet<String> set = new HashSet<String>(); //添加元素 set.add(\\\"hello\\\"); set.add(\\\"world\\\"); set.add(\\\"java\\\"); //不包含重复元素的集合 set.add(\\\"world\\\"); //遍历 for(String s : set) { System.out.println(s); } } } \"]},{\"header\":\"哈希值\",\"slug\":\"哈希值\",\"contents\":[\"哈希值简介\",\"是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\",\"如何获取哈希值\",\"Object类中的public int hashCode()：返回对象的哈希码值\",\"哈希值的特点\",\"同一个对象多次调用hashCode()方法返回的哈希值是相同的\",\"默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\"]},{\"header\":\"哈希表结构\",\"slug\":\"哈希表结构\",\"contents\":[\"JDK1.8以前\",\"数组 + 链表\",\"14_JKD8以前哈希表\",\"JDK1.8以后\",\"节点个数少于等于8个\",\"数组 + 链表\",\"节点个数多于8个\",\"数组 + 红黑树\",\"15_JKD8以后哈希表\"]},{\"header\":\"HashSet集合存储学生对象并遍历\",\"slug\":\"hashset集合存储学生对象并遍历\",\"contents\":[\"案例需求\",\"创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\",\"要求：学生对象的成员变量值相同，我们就认为是同一个对象\",\"代码实现\",\"学生类\",\"public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } } \",\"测试类\",\"public class HashSetDemo02 { public static void main(String[] args) { //创建HashSet集合对象 HashSet<Student> hs = new HashSet<Student>(); //创建学生对象 Student s1 = new Student(\\\"林青霞\\\", 30); Student s2 = new Student(\\\"张曼玉\\\", 35); Student s3 = new Student(\\\"王祖贤\\\", 33); Student s4 = new Student(\\\"王祖贤\\\", 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) { System.out.println(s.getName() + \\\",\\\" + s.getAge()); } } } \",\"总结\",\"HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法\"]},{\"header\":\"24 Map、可变参数、集合工具类\",\"slug\":\"_24-map、可变参数、集合工具类\",\"contents\":[]},{\"header\":\"24.1 Map\",\"slug\":\"_24-1-map\",\"contents\":[\"Map集合概述\",\"interface Map<K,V> K：键的类型；V：值的类型 \",\"Map集合的特点\",\"双列集合,一个键对应一个值\",\"键不可以重复,值可以重复\",\"Map集合的基本使用\",\"public class MapDemo01 { public static void main(String[] args) { //创建集合对象 Map<String,String> map = new HashMap<String,String>(); //V put(K key, V value) 将指定的值与该映射中的指定键相关联 map.put(\\\"itheima001\\\",\\\"林青霞\\\"); map.put(\\\"itheima002\\\",\\\"张曼玉\\\"); map.put(\\\"itheima003\\\",\\\"王祖贤\\\"); map.put(\\\"itheima003\\\",\\\"柳岩\\\"); //输出集合对象 System.out.println(map); } } \"]},{\"header\":\"24.1.1 Map集合的基本功能\",\"slug\":\"_24-1-1-map集合的基本功能\",\"contents\":[\"方法名\",\"说明\",\"V put(K key,V value)\",\"添加元素\",\"V remove(Object key)\",\"根据键删除键值对元素\",\"void clear()\",\"移除所有的键值对元素\",\"boolean containsKey(Object key)\",\"判断集合是否包含指定的键\",\"boolean containsValue(Object value)\",\"判断集合是否包含指定的值\",\"boolean isEmpty()\",\"判断集合是否为空\",\"int size()\",\"集合的长度，也就是集合中键值对的个数\",\"示例代码\",\"public class MapDemo02 { public static void main(String[] args) { //创建集合对象 Map<String,String> map = new HashMap<String,String>(); //V put(K key,V value)：添加元素 map.put(\\\"张无忌\\\",\\\"赵敏\\\"); map.put(\\\"郭靖\\\",\\\"黄蓉\\\"); map.put(\\\"杨过\\\",\\\"小龙女\\\"); //V remove(Object key)：根据键删除键值对元素 // System.out.println(map.remove(\\\"郭靖\\\")); // System.out.println(map.remove(\\\"郭襄\\\")); //void clear()：移除所有的键值对元素 // map.clear(); //boolean containsKey(Object key)：判断集合是否包含指定的键 // System.out.println(map.containsKey(\\\"郭靖\\\")); // System.out.println(map.containsKey(\\\"郭襄\\\")); //boolean isEmpty()：判断集合是否为空 // System.out.println(map.isEmpty()); //int size()：集合的长度，也就是集合中键值对的个数 System.out.println(map.size()); //输出集合对象 System.out.println(map); } } \"]},{\"header\":\"24.1.2 集合的获取功能\",\"slug\":\"_24-1-2-集合的获取功能\",\"contents\":[\"方法名\",\"说明\",\"V get(Object key)\",\"根据键获取值\",\"Set<K> keySet()\",\"获取所有键的集合\",\"Collection<V> values()\",\"获取所有值的集合\",\"Set<Map.Entry<K,V>> entrySet()\",\"获取所有键值对对象的集合\",\"示例代码\",\"public class MapDemo03 { public static void main(String[] args) { //创建集合对象 Map<String, String> map = new HashMap<String, String>(); //添加元素 map.put(\\\"张无忌\\\", \\\"赵敏\\\"); map.put(\\\"郭靖\\\", \\\"黄蓉\\\"); map.put(\\\"杨过\\\", \\\"小龙女\\\"); //V get(Object key):根据键获取值 // System.out.println(map.get(\\\"张无忌\\\")); // System.out.println(map.get(\\\"张三丰\\\")); //Set<K> keySet():获取所有键的集合 // Set<String> keySet = map.keySet(); // for(String key : keySet) { // System.out.println(key); // } //Collection<V> values():获取所有值的集合 Collection<String> values = map.values(); for(String value : values) { System.out.println(value); } } } \"]},{\"header\":\"Map集合的遍历(方式1)\",\"slug\":\"map集合的遍历-方式1\",\"contents\":[\"遍历思路\",\"我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 \",\"把所有的丈夫给集中起来\",\"遍历丈夫的集合，获取到每一个丈夫\",\"根据丈夫去找对应的妻子\",\"步骤分析\",\"获取所有键的集合。用keySet()方法实现\",\"遍历键的集合，获取到每一个键。用增强for实现\",\"根据键去找值。用get(Object key)方法实现\",\"代码实现\",\"public class MapDemo01 { public static void main(String[] args) { //创建集合对象 Map<String, String> map = new HashMap<String, String>(); //添加元素 map.put(\\\"张无忌\\\", \\\"赵敏\\\"); map.put(\\\"郭靖\\\", \\\"黄蓉\\\"); map.put(\\\"杨过\\\", \\\"小龙女\\\"); //获取所有键的集合。用keySet()方法实现 Set<String> keySet = map.keySet(); //遍历键的集合，获取到每一个键。用增强for实现 for (String key : keySet) { //根据键去找值。用get(Object key)方法实现 String value = map.get(key); System.out.println(key + \\\",\\\" + value); } } } \"]},{\"header\":\"Map集合的遍历(方式2)\",\"slug\":\"map集合的遍历-方式2\",\"contents\":[\"遍历思路\",\"我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 \",\"获取所有结婚证的集合\",\"遍历结婚证的集合，得到每一个结婚证\",\"根据结婚证获取丈夫和妻子\",\"步骤分析\",\"获取所有键值对对象的集合 \",\"Set<Map.Entry<K,V>> entrySet()：获取所有键值对对象的集合\",\"遍历键值对对象的集合，得到每一个键值对对象 \",\"用增强for实现，得到每一个Map.Entry\",\"根据键值对对象获取键和值 \",\"用getKey()得到键\",\"用getValue()得到值\",\"代码实现\",\"public class MapDemo02 { public static void main(String[] args) { //创建集合对象 Map<String, String> map = new HashMap<String, String>(); //添加元素 map.put(\\\"张无忌\\\", \\\"赵敏\\\"); map.put(\\\"郭靖\\\", \\\"黄蓉\\\"); map.put(\\\"杨过\\\", \\\"小龙女\\\"); //获取所有键值对对象的集合 Set<Map.Entry<String, String>> entrySet = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for (Map.Entry<String, String> me : entrySet) { //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + \\\",\\\" + value); } } } \"]},{\"header\":\"24.1.3 HashMap集合\",\"slug\":\"_24-1-3-hashmap集合\",\"contents\":[\"HashMap底层是哈希表结构的\",\"依赖hashCode方法和equals方法保证键的唯一\",\"如果键要存储的是自定义对象，需要重写hashCode和equals方法\"]},{\"header\":\"HashMap集合应用案例\",\"slug\":\"hashmap集合应用案例\",\"contents\":[\"案例需求\",\"创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。\",\"要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象\",\"代码实现\",\"学生类\",\"public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } } \",\"测试类\",\"public class HashMapDemo { public static void main(String[] args) { //创建HashMap集合对象 HashMap<Student, String> hm = new HashMap<Student, String>(); //创建学生对象 Student s1 = new Student(\\\"林青霞\\\", 30); Student s2 = new Student(\\\"张曼玉\\\", 35); Student s3 = new Student(\\\"王祖贤\\\", 33); Student s4 = new Student(\\\"王祖贤\\\", 33); //把学生添加到集合 hm.put(s1, \\\"西安\\\"); hm.put(s2, \\\"武汉\\\"); hm.put(s3, \\\"郑州\\\"); hm.put(s4, \\\"北京\\\"); //遍历集合 Set<Student> keySet = hm.keySet(); for (Student key : keySet) { String value = hm.get(key); System.out.println(key.getName() + \\\",\\\" + key.getAge() + \\\",\\\" + value); } } } \"]},{\"header\":\"24.1.4 TreeMap集合\",\"slug\":\"_24-1-4-treemap集合\",\"contents\":[\"TreeMap底层是红黑树结构\",\"依赖自然排序或者比较器排序,对键进行排序\",\"如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则\"]},{\"header\":\"TreeMap集合应用案例\",\"slug\":\"treemap集合应用案例\",\"contents\":[\"案例需求\",\"创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历\",\"要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序\",\"代码实现\",\"学生类\",\"public class Student implements Comparable<Student>{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \\\"Student{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", age=\\\" + age + '}'; } @Override public int compareTo(Student o) { //按照年龄进行排序 int result = o.getAge() - this.getAge(); //次要条件，按照姓名排序。 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; } } \",\"测试类\",\"public class Test1 { public static void main(String[] args) { // 创建TreeMap集合对象 TreeMap<Student,String> tm = new TreeMap<>(); // 创建学生对象 Student s1 = new Student(\\\"xiaohei\\\",23); Student s2 = new Student(\\\"dapang\\\",22); Student s3 = new Student(\\\"xiaomei\\\",22); // 将学生对象添加到TreeMap集合中 tm.put(s1,\\\"江苏\\\"); tm.put(s2,\\\"北京\\\"); tm.put(s3,\\\"天津\\\"); // 遍历TreeMap集合,打印每个学生的信息 tm.forEach( (Student key, String value)->{ System.out.println(key + \\\"---\\\" + value); } ); } } \"]},{\"header\":\"24.2 可变参数\",\"slug\":\"_24-2-可变参数\",\"contents\":[\"格式：\",\"修饰符 返回值类型 方法名(参数类型... 形参名){ }\",\"底层：\",\"其实就是一个数组\",\"代码演示:\",\" public class ChangeArgs { public static void main(String[] args) { int sum = getSum(6, 7, 2, 12, 2121); System.out.println(sum); } public static int getSum(int... arr) { int sum = 0; for (int a : arr) { sum += a; } return sum; } } \",\"注意：\",\"1.一个方法只能有一个可变参数\",\"2.如果方法中有多个参数，可变参数要放到最后。\",\"应用场景: Collections:\",\"在Collections中也提供了添加一些元素方法： public static <T> boolean addAll(Collection<T> c, T... elements) :往集合中添加一些元素。\",\"public class CollectionsDemo{ public static void main(String[] args) { ArrayList<Integer> list = new ArrayList<Integer>(); //原来写法 //list.add(12); //list.add(14); //list.add(15); //list.add(1000); //采用工具类 完成 往集合中添加元素 Collections.addAll(list, 5, 222, 1，2); System.out.println(list); } } \"]},{\"header\":\"24.3 Collections类\",\"slug\":\"_24-3-collections类\",\"contents\":[\"java.utils.Collections是集合工具类，用来对集合进行操作。\",\"常用方法如下：\",\"public static void shuffle(List<?> list):打乱集合顺序。\",\"public static <T> void sort(List<T> list):将集合中元素按照默认规则排序。\",\"public static <T> void sort(List<T> list，Comparator<? super T> ):将集合中元素按照指定规则排序。\",\"代码演示：\",\"public class CollectionsDemo { public static void main(String[] args) { ArrayList<Integer> list = new ArrayList<Integer>(); list.add(100); list.add(300); list.add(200); list.add(50); //排序方法 Collections.sort(list); System.out.println(list); } } 结果： [50,100, 200, 300] \"]},{\"header\":\"24.3.1 Comparator比较器\",\"slug\":\"_24-3-1-comparator比较器\",\"contents\":[\"创建一个学生类，存储到ArrayList集合中完成指定排序操作。\",\"Student 类\",\"public class Student{ private String name; private int age; //构造方法 //get/set //toString } \",\"测试类：\",\"public class Demo { public static void main(String[] args) { // 创建四个学生对象 存储到集合中 ArrayList<Student> list = new ArrayList<Student>(); list.add(new Student(\\\"rose\\\",18)); list.add(new Student(\\\"jack\\\",16)); list.add(new Student(\\\"abc\\\",20)); Collections.sort(list, new Comparator<Student>() { @Override public int compare(Student o1, Student o2) { return o1.getAge()-o2.getAge();//以学生的年龄升序 } }); for (Student student : list) { System.out.println(student); } } } Student{name='jack', age=16} Student{name='rose', age=18} Student{name='abc', age=20} \"]},{\"header\":\"25 不可变集合、综合练习\",\"slug\":\"_25-不可变集合、综合练习\",\"contents\":[]},{\"header\":\"25.1 不可变集合\",\"slug\":\"_25-1-不可变集合\",\"contents\":[\"是一个长度不可变，内容也无法修改的集合\"]},{\"header\":\"25.1.1 使用场景\",\"slug\":\"_25-1-1-使用场景\",\"contents\":[\"如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。\",\"当集合对象被不可信的库调用时，不可变形式是安全的。\"]},{\"header\":\"25.1.2 不可变集合分类\",\"slug\":\"_25-1-2-不可变集合分类\",\"contents\":[\"不可变的list集合\",\"不可变的set集合\",\"不可变的map集合\"]},{\"header\":\"不可变的list集合\",\"slug\":\"不可变的list集合\",\"contents\":[\"public class ImmutableDemo1 { public static void main(String[] args) { /* 创建不可变的List集合 \\\"张三\\\", \\\"李四\\\", \\\"王五\\\", \\\"赵六\\\" */ //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作 List<String> list = List.of(\\\"张三\\\", \\\"李四\\\", \\\"王五\\\", \\\"赵六\\\"); System.out.println(list.get(0)); System.out.println(list.get(1)); System.out.println(list.get(2)); System.out.println(list.get(3)); System.out.println(\\\"---------------------------\\\"); for (String s : list) { System.out.println(s); } System.out.println(\\\"---------------------------\\\"); Iterator<String> it = list.iterator(); while(it.hasNext()){ String s = it.next(); System.out.println(s); } System.out.println(\\\"---------------------------\\\"); for (int i = 0; i < list.size(); i++) { String s = list.get(i); System.out.println(s); } System.out.println(\\\"---------------------------\\\"); //list.remove(\\\"李四\\\"); //list.add(\\\"aaa\\\"); list.set(0,\\\"aaa\\\"); } } \"]},{\"header\":\"不可变的Set集合\",\"slug\":\"不可变的set集合\",\"contents\":[\"public class ImmutableDemo2 { public static void main(String[] args) { /* 创建不可变的Set集合 \\\"张三\\\", \\\"李四\\\", \\\"王五\\\", \\\"赵六\\\" 细节： 当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性 */ //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作 Set<String> set = Set.of(\\\"张三\\\", \\\"张三\\\", \\\"李四\\\", \\\"王五\\\", \\\"赵六\\\"); for (String s : set) { System.out.println(s); } System.out.println(\\\"-----------------------\\\"); Iterator<String> it = set.iterator(); while(it.hasNext()){ String s = it.next(); System.out.println(s); } System.out.println(\\\"-----------------------\\\"); //set.remove(\\\"王五\\\"); } } \"]},{\"header\":\"不可变的Map集合\",\"slug\":\"不可变的map集合\",\"contents\":[\"键值对个数小于等于10\",\"public class ImmutableDemo3 { public static void main(String[] args) { /* 创建Map的不可变集合 细节1： 键是不能重复的 细节2： Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对 细节3： 如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法 */ //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作 Map<String, String> map = Map.of( \\\"张三\\\", \\\"南京\\\", \\\"张三\\\", \\\"北京\\\", \\\"王五\\\", \\\"上海\\\", \\\"赵六\\\", \\\"广州\\\", \\\"孙七\\\", \\\"深圳\\\", \\\"周八\\\", \\\"杭州\\\", \\\"吴九\\\", \\\"宁波\\\", \\\"郑十\\\", \\\"苏州\\\", \\\"刘一\\\", \\\"无锡\\\", \\\"陈二\\\", \\\"嘉兴\\\"); Set<String> keys = map.keySet(); for (String key : keys) { String value = map.get(key); System.out.println(key + \\\"=\\\" + value); } System.out.println(\\\"--------------------------\\\"); Set<Map.Entry<String, String>> entries = map.entrySet(); for (Map.Entry<String, String> entry : entries) { String key = entry.getKey(); String value = entry.getValue(); System.out.println(key + \\\"=\\\" + value); } System.out.println(\\\"--------------------------\\\"); } } \",\"键值对个数大于10\",\"public class ImmutableDemo4 { public static void main(String[] args) { /* 创建Map的不可变集合,键值对的数量超过10个 */ //1.创建一个普通的Map集合 HashMap<String, String> hm = new HashMap<>(); hm.put(\\\"张三\\\", \\\"南京\\\"); hm.put(\\\"李四\\\", \\\"北京\\\"); hm.put(\\\"王五\\\", \\\"上海\\\"); hm.put(\\\"赵六\\\", \\\"北京\\\"); hm.put(\\\"孙七\\\", \\\"深圳\\\"); hm.put(\\\"周八\\\", \\\"杭州\\\"); hm.put(\\\"吴九\\\", \\\"宁波\\\"); hm.put(\\\"郑十\\\", \\\"苏州\\\"); hm.put(\\\"刘一\\\", \\\"无锡\\\"); hm.put(\\\"陈二\\\", \\\"嘉兴\\\"); hm.put(\\\"aaa\\\", \\\"111\\\"); //2.利用上面的数据来获取一个不可变的集合 /* //获取到所有的键值对对象（Entry对象） Set<Map.Entry<String, String>> entries = hm.entrySet(); //把entries变成一个数组 Map.Entry[] arr1 = new Map.Entry[0]; //toArray方法在底层会比较集合的长度跟数组的长度两者的大小 //如果集合的长度 > 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组 //如果集合的长度 <= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用 Map.Entry[] arr2 = entries.toArray(arr1); //不可变的map集合 Map map = Map.ofEntries(arr2); map.put(\\\"bbb\\\",\\\"222\\\");*/ //Map<Object, Object> map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0])); Map<String, String> map = Map.copyOf(hm); map.put(\\\"bbb\\\",\\\"222\\\"); } } \"]},{\"header\":\"25.2 综合练习\",\"slug\":\"_25-2-综合练习\",\"contents\":[]},{\"header\":\"练习1：随机点名器\",\"slug\":\"练习1-随机点名器\",\"contents\":[\"需求：班级里有N个学生，实现随机点名器\",\"代码实现：\",\"public class Test1 { public static void main(String[] args) { /* 班级里有N个学生，学生属性:姓名，年龄，性别。 实现随机点名器。*/ //1.定义集合 ArrayList<String> list = new ArrayList<>(); //2.添加数据 Collections.addAll(list,\\\"范闲\\\",\\\"范建\\\",\\\"范统\\\",\\\"杜子腾\\\",\\\"杜琦燕\\\",\\\"宋合泛\\\",\\\"侯笼藤\\\",\\\"朱益群\\\",\\\"朱穆朗玛峰\\\",\\\"袁明媛\\\"); //3.随机点名 /* Random r = new Random(); int index = r.nextInt(list.size()); String name = list.get(index); System.out.println(name);*/ //打乱 Collections.shuffle(list); String name = list.get(0); System.out.println(name); } } \"]},{\"header\":\"练习2：带概率的随机\",\"slug\":\"练习2-带概率的随机\",\"contents\":[\"需求：\",\"班级里有N个学生\",\"要求在随机的时候，70%的概率随机到男生，30%的概率随机到女生\",\"代码实现：\",\"public class Test2 { public static void main(String[] args) { /* 班级里有N个学生 要求： 70%的概率随机到男生 30%的概率随机到女生 \\\"范闲\\\",\\\"范建\\\",\\\"范统\\\",\\\"杜子腾\\\",\\\"宋合泛\\\",\\\"侯笼藤\\\",\\\"朱益群\\\",\\\"朱穆朗玛峰\\\", \\\"杜琦燕\\\",\\\"袁明媛\\\",\\\"李猜\\\",\\\"田蜜蜜\\\", */ //1.创建集合 ArrayList<Integer> list = new ArrayList<>(); //2.添加数据 Collections.addAll(list,1,1,1,1,1,1,1); Collections.addAll(list,0,0,0); //3.打乱集合中的数据 Collections.shuffle(list); //4.从list集合中随机抽取0或者1 Random r = new Random(); int index = r.nextInt(list.size()); int number = list.get(index); System.out.println(number); //5.创建两个集合分别存储男生和女生的名字 ArrayList<String> boyList = new ArrayList<>(); ArrayList<String> girlList = new ArrayList<>(); Collections.addAll(boyList,\\\"范闲\\\",\\\"范建\\\",\\\"范统\\\",\\\"杜子腾\\\",\\\"宋合泛\\\",\\\"侯笼藤\\\",\\\"朱益群\\\",\\\"朱穆朗玛峰\\\"); Collections.addAll(girlList,\\\"杜琦燕\\\",\\\"袁明媛\\\",\\\"李猜\\\",\\\"田蜜蜜\\\"); //6.判断此时是从boyList里面抽取还是从girlList里面抽取 if(number == 1){ //boyList int boyIndex = r.nextInt(boyList.size()); String name = boyList.get(boyIndex); System.out.println(name); }else{ //girlList int girlIndex = r.nextInt(girlList.size()); String name = girlList.get(girlIndex); System.out.println(name); } } } \"]},{\"header\":\"练习3：随机不重复\",\"slug\":\"练习3-随机不重复\",\"contents\":[\"需求：\",\"班级里有N个学生，被点到的学生不会再被点到。但是如果班级中所有的学生都点完了， 需要重新开启第二轮点名。\",\"代码实现：\",\"public class Test3 { public static void main(String[] args) { /* 班级里有5个学生 要求： 被点到的学生不会再被点到。 但是如果班级中所有的学生都点完了，需要重新开启第二轮点名。*/ //1.定义集合 ArrayList<String> list1 = new ArrayList<>(); //2.添加数据 Collections.addAll(list1, \\\"范闲\\\", \\\"范建\\\", \\\"范统\\\", \\\"杜子腾\\\", \\\"杜琦燕\\\", \\\"宋合泛\\\", \\\"侯笼藤\\\", \\\"朱益群\\\", \\\"朱穆朗玛峰\\\", \\\"袁明媛\\\"); //创建一个临时的集合，用来存已经被点到学生的名字 ArrayList<String> list2 = new ArrayList<>(); //外循环：表示轮数 for (int i = 1; i <= 10; i++) { System.out.println(\\\"=========第\\\" + i + \\\"轮点名开始了======================\\\"); //3.获取集合的长度 int count = list1.size(); //4.随机点名 Random r = new Random(); //内循环：每一轮中随机循环抽取的过程 for (int j = 0; j < count; j++) { int index = r.nextInt(list1.size()); String name = list1.remove(index); list2.add(name); System.out.println(name); } //此时表示一轮点名结束 //list1 空了 list2 10个学生的名字 list1.addAll(list2); list2.clear(); } } } \"]},{\"header\":\"练习4：集合的嵌套\",\"slug\":\"练习4-集合的嵌套\",\"contents\":[\"需求：\",\"定义一个Map集合，键用表示省份名称province，值表示市city，但是市会有多个。\",\"添加完毕后，遍历结果格式如下：\",\"江苏省 = 南京市，扬州市，苏州市，无锡市，常州市\",\"湖北省 = 武汉市，孝感市，十堰市，宜昌市，鄂州市\",\"河北省 = 石家庄市，唐山市，邢台市，保定市，张家口市\",\"代码实现：\",\"public class Test4 { public static void main(String[] args) { /* 需求 定义一个Map集合，键用表示省份名称province，值表示市city，但是市会有多个。 添加完毕后，遍历结果格式如下： 江苏省 = 南京市，扬州市，苏州市，无锡市，常州市 湖北省 = 武汉市，孝感市，十堰市，宜昌市，鄂州市 河北省 = 石家庄市，唐山市，邢台市，保定市，张家口市*/ //1.创建Map集合 HashMap<String, ArrayList<String>> hm = new HashMap<>(); //2.创建单列集合存储市 ArrayList<String> city1 = new ArrayList<>(); city1.add(\\\"南京市\\\"); city1.add(\\\"扬州市\\\"); city1.add(\\\"苏州市\\\"); city1.add(\\\"无锡市\\\"); city1.add(\\\"常州市\\\"); ArrayList<String> city2 = new ArrayList<>(); city2.add(\\\"武汉市\\\"); city2.add(\\\"孝感市\\\"); city2.add(\\\"十堰市\\\"); city2.add(\\\"宜昌市\\\"); city2.add(\\\"鄂州市\\\"); ArrayList<String> city3 = new ArrayList<>(); city3.add(\\\"石家庄市\\\"); city3.add(\\\"唐山市\\\"); city3.add(\\\"邢台市\\\"); city3.add(\\\"保定市\\\"); city3.add(\\\"张家口市\\\"); //3.把省份和多个市添加到map集合 hm.put(\\\"江苏省\\\",city1); hm.put(\\\"湖北省\\\",city2); hm.put(\\\"河北省\\\",city3); Set<Map.Entry<String, ArrayList<String>>> entries = hm.entrySet(); for (Map.Entry<String, ArrayList<String>> entry : entries) { //entry依次表示每一个键值对对象 String key = entry.getKey(); ArrayList<String> value = entry.getValue(); StringJoiner sj = new StringJoiner(\\\", \\\",\\\"\\\",\\\"\\\"); for (String city : value) { sj.add(city); } System.out.println(key + \\\" = \\\" + sj); } } } \"]}]},\"/BackEnd/JavaSE/Javase07.html\":{\"title\":\"异常处理\",\"contents\":[{\"header\":\"26 异常\",\"slug\":\"_26-异常\",\"contents\":[\"异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。\",\"在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。\",\"异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.\"]},{\"header\":\"26.1 异常体系\",\"slug\":\"_26-1-异常体系\",\"contents\":[\"异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。\",\"异常体系\",\"Throwable体系：\",\"Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。\",\"Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。\",\"Throwable中的常用方法：\",\"public void printStackTrace():打印异常的详细信息。\",\"包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。\",\"public String getMessage():获取发生异常的原因。\",\"提示给用户的时候,就提示错误原因。\",\"public String toString():获取异常的类型和异常描述信息(不用)。\"]},{\"header\":\"26.2 异常分类\",\"slug\":\"_26-2-异常分类\",\"contents\":[\"我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。\",\"异常(Exception)的分类:根据在编译时期还是运行时期去检查异常?\",\"编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)\",\"运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)\",\"异常的分类\"]},{\"header\":\"26.3 抛出异常throw\",\"slug\":\"_26-3-抛出异常throw\",\"contents\":[\"java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？\",\"创建一个异常对象。封装一些提示信息(信息可以自己编写)。\",\"需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。\",\"throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。\",\"使用格式：\",\"throw new 异常类名(参数);\",\"例如：\",\"throw new NullPointerException(\\\"要访问的arr数组不存在\\\"); throw new ArrayIndexOutOfBoundsException(\\\"该索引在数组中不存在，已超出范围\\\"); \",\"学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。\",\"public class ThrowDemo { public static void main(String[] args) { //创建一个数组 int[] arr = {2,4,52,2}; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\\\"over\\\"); } /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index){ //判断 索引是否越界 if(index<0 || index>arr.length-1){ /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(\\\"哥们，角标越界了```\\\"); } int element = arr[index]; return element; } } \"]},{\"header\":\"26.4 声明异常throws\",\"slug\":\"_26-4-声明异常throws\",\"contents\":[\"声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。\",\"关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).\",\"声明异常格式：\",\"修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…\",\"声明异常的代码演示：\",\"public class ThrowsDemo { public static void main(String[] args) throws FileNotFoundException { read(\\\"a.txt\\\"); } // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException { if (!path.equals(\\\"a.txt\\\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\\\"文件不存在\\\"); } } } \",\"throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。\",\"public class ThrowsDemo2 { public static void main(String[] args) throws IOException { read(\\\"a.txt\\\"); } public static void read(String path)throws FileNotFoundException, IOException { if (!path.equals(\\\"a.txt\\\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\\\"文件不存在\\\"); } if (!path.equals(\\\"b.txt\\\")) { throw new IOException(); } } } \"]},{\"header\":\"26.5 捕获异常try…catch\",\"slug\":\"_26-5-捕获异常try-catch\",\"contents\":[\"如果异常出现的话,会立刻终止程序,所以我们得处理异常:\",\"该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。\",\"在方法中使用try-catch的语句块来处理异常。\",\"try-catch的方式就是捕获异常。\",\"捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。\",\"捕获异常语法如下：\",\"try{ 编写可能会出现异常的代码 }catch(异常类型 e){ 处理异常的代码 //记录日志/打印异常信息/继续抛出异常 } \",\"try： 该代码块中编写可能产生异常的代码。\",\"catch： 用来进行某种异常的捕获，实现对捕获到的异常进行处理。\",\"注意:try和catch都不能单独使用,必须连用。\",\"演示如下：\",\"public class TryCatchDemo { public static void main(String[] args) { try {// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\\\"b.txt\\\"); } catch (FileNotFoundException e) {// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); } System.out.println(\\\"over\\\"); } /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException { if (!path.equals(\\\"a.txt\\\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\\\"文件不存在\\\"); } } } \"]},{\"header\":\"26.6 finally代码块\",\"slug\":\"_26-6-finally代码块\",\"contents\":[\"finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的\",\"什么时候的代码必须最终执行？\",\"当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。\",\"finally的语法:\",\"try...catch....finally:自身需要处理异常,最终还得关闭资源。\",\"注意:finally不能单独使用。\",\"比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。\",\"finally代码参考如下：\",\"public class TryCatchDemo4 { public static void main(String[] args) { try { read(\\\"a.txt\\\"); } catch (FileNotFoundException e) { //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); } finally { System.out.println(\\\"不管程序怎样，这里都将会被执行。\\\"); } System.out.println(\\\"over\\\"); } /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException { if (!path.equals(\\\"a.txt\\\")) {//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\\\"文件不存在\\\"); } } } \",\"当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。\"]},{\"header\":\"26.7 异常注意事项\",\"slug\":\"_26-7-异常注意事项\",\"contents\":[\"运行时异常被抛出可以不处理。即不捕获也不声明抛出。\",\"如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。\",\"父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出\",\"当多异常处理时，捕获处理，前边的类不能是后边类的父类\",\"在try/catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。\"]}]},\"/BackEnd/JavaSE/Javase08.html\":{\"title\":\"IO流体系\",\"contents\":[{\"header\":\"27 字节流、字符流\",\"slug\":\"_27-字节流、字符流\",\"contents\":[]},{\"header\":\"27.1 字节流\",\"slug\":\"_27-1-字节流\",\"contents\":[]},{\"header\":\"27.1.1 IO概述\",\"slug\":\"_27-1-1-io概述\",\"contents\":[\"以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。\",\"Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。\"]},{\"header\":\"IO的分类\",\"slug\":\"io的分类\",\"contents\":[\"根据数据的流向分为：输入流和输出流。\",\"输入流 ：把数据从其他设备上读取到内存中的流。\",\"输出流 ：把数据从内存 中写出到其他设备上的流。\",\"格局数据的类型分为：字节流和字符流。\",\"字节流 ：以字节为单位，读写数据的流。\",\"字符流 ：以字符为单位，读写数据的流。\"]},{\"header\":\"IO的流向说明图解\",\"slug\":\"io的流向说明图解\",\"contents\":[\"1_io\"]},{\"header\":\"顶级父类们\",\"slug\":\"顶级父类们\",\"contents\":[\"输入流\",\"输出流\",\"字节流\",\"InputStream\",\"OutputStream\",\"字符流\",\"Reader\",\"Writer\"]},{\"header\":\"27.1.2 字节流\",\"slug\":\"_27-1-2-字节流\",\"contents\":[]},{\"header\":\"字节输出流【OutputStream】\",\"slug\":\"字节输出流【outputstream】\",\"contents\":[\"java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。\",\"public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。\",\"public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。\",\"public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。\",\"public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。\",\"public abstract void write(int b) ：将指定的字节输出流。\"]},{\"header\":\"FileOutputStream类\",\"slug\":\"fileoutputstream类\",\"contents\":[\"OutputStream有很多子类，我们从最简单的一个子类开始。\",\"java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。\",\"构造方法:\",\"public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。\",\"public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。\",\"当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。\",\"构造举例，代码如下：\",\"public class FileOutputStreamConstructor throws IOException { public static void main(String[] args) { // 使用File对象创建流对象 File file = new File(\\\"a.txt\\\"); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\\\"b.txt\\\"); } } \"]},{\"header\":\"数据追加续写\",\"slug\":\"数据追加续写\",\"contents\":[\"经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？\",\"public FileOutputStream(File file, boolean append)： 创建文件输出流以写入由指定的 File对象表示的文件。\",\"public FileOutputStream(String name, boolean append)： 创建文件输出流以指定的名称写入文件。\",\"这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：\",\"public class FOSWrite { public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\\\"fos.txt\\\"，true); // 字符串转换为字节数组 byte[] b = \\\"abcde\\\".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是 cd。 fos.write(b); // 关闭资源 fos.close(); } } 文件操作前：cd 文件操作后：cdabcde \"]},{\"header\":\"写出换行\",\"slug\":\"写出换行\",\"contents\":[\"Windows系统里，换行符号是\\\\r\\\\n 。把\",\"以指定是否追加续写了，代码使用演示：\",\"public class FOSWrite { public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream(\\\"fos.txt\\\"); // 定义字节数组 byte[] words = {97,98,99,100,101}; // 遍历数组 for (int i = 0; i < words.length; i++) { // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write(\\\"\\\\r\\\\n\\\".getBytes()); } // 关闭资源 fos.close(); } } 输出结果： a b c d e \",\"回车符\\\\r和换行符\\\\n ： \",\"回车符：回到一行的开头（return）。\",\"换行符：下一行（newline）。\",\"系统中的换行： \",\"Windows系统里，每行结尾是 回车+换行 ，即\\\\r\\\\n；\",\"Unix系统里，每行结尾只有 换行 ，即\\\\n；\",\"Mac系统里，每行结尾是 回车 ，即\\\\r。从 Mac OS X开始与Linux统一。\"]},{\"header\":\"字节输入流【InputStream】\",\"slug\":\"字节输入流【inputstream】\",\"contents\":[\"java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\",\"public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。\",\"public abstract int read()： 从输入流读取数据的下一个字节。\",\"public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组b中。\"]},{\"header\":\"FileInputStream类\",\"slug\":\"fileinputstream类\",\"contents\":[\"java.io.FileInputStream类是文件输入流，从文件中读取字节。\",\"构造方法:\",\"FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。\",\"FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。\",\"当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。\",\"构造举例，代码如下：\",\"public class FileInputStreamConstructor throws IOException{ public static void main(String[] args) { // 使用File对象创建流对象 File file = new File(\\\"a.txt\\\"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream(\\\"b.txt\\\"); } } \"]},{\"header\":\"读取字节数据\",\"slug\":\"读取字节数据\",\"contents\":[\"public class FISRead { public static void main(String[] args) throws IOException{ // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream(\\\"read.txt\\\"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) { System.out.println((char)b); } // 关闭资源 fis.close(); } } 输出结果： a b c d e \"]},{\"header\":\"使用字节数组读取\",\"slug\":\"使用字节数组读取\",\"contents\":[\"read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1，代码使用演示：\",\"public class FISRead { public static void main(String[] args) throws IOException{ // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\\\"read. txt\\\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) { // 每次读取后,把数组变成字符串打印 System.out.println(new String(b)); } // 关闭资源 fis.close(); } } 输出结果： ab cd ed \",\"错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换，所以要通过len ，获取有效的字节，代码使用演示：\",\"public class FISRead { public static void main(String[] args) throws IOException{ // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream(\\\"read. txt\\\"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) { // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 } // 关闭资源 fis.close(); } } 输出结果： ab cd e \",\"小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。\"]},{\"header\":\"字节流练习：图片复制\",\"slug\":\"字节流练习-图片复制\",\"contents\":[\"2_copy\",\"复制图片文件，代码使用演示：\",\"public class Copy { public static void main(String[] args) throws IOException { // 1.创建流对象 // 1.1 指定数据源 FileInputStream fis = new FileInputStream(\\\"D:\\\\\\\\test.jpg\\\"); // 1.2 指定目的地 FileOutputStream fos = new FileOutputStream(\\\"test_copy.jpg\\\"); // 2.读写数据 // 2.1 定义数组 byte[] b = new byte[1024]; // 2.2 定义长度 int len; // 2.3 循环读取 while ((len = fis.read(b))!=-1) { // 2.4 写出数据 fos.write(b, 0 , len); } // 3.关闭资源 fos.close(); fis.close(); } } \",\"小贴士： 流的关闭原则：先开后关，后开先关。\"]},{\"header\":\"27.1.3 字符流\",\"slug\":\"_27-1-3-字符流\",\"contents\":[\"当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。\"]},{\"header\":\"字符输入流【Reader】\",\"slug\":\"字符输入流【reader】\",\"contents\":[\"java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\",\"public void close() ：关闭此流并释放与此流相关联的任何系统资源。\",\"public int read()： 从输入流读取一个字符。\",\"public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中。\"]},{\"header\":\"FileReader类\",\"slug\":\"filereader类\",\"contents\":[\"java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\",\"构造方法:\",\"FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。\",\"FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称。\",\"当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。\",\"构造举例，代码如下：\",\"public class FileReaderConstructor throws IOException{ public static void main(String[] args) { // 使用File对象创建流对象 File file = new File(\\\"a.txt\\\"); FileReader fr = new FileReader(file); // 使用文件名称创建流对象 FileReader fr = new FileReader(\\\"b.txt\\\"); } } \"]},{\"header\":\"读取字符数据\",\"slug\":\"读取字符数据\",\"contents\":[\"public class FISRead { public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileReader fr = new FileReader(\\\"read.txt\\\"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) { System.out.println(new String(cbuf,0,len)); } // 关闭资源 fr.close(); } } 输出结果： 黑马 程序 员 \"]},{\"header\":\"字符输出流【Writer】\",\"slug\":\"字符输出流【writer】\",\"contents\":[\"java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。\",\"void write(int c) 写入单个字符。\",\"void write(char[] cbuf)写入字符数组。\",\"abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。\",\"void write(String str)写入字符串。\",\"void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\",\"void flush()刷新该流的缓冲。\",\"void close() 关闭此流，但要先刷新它。\"]},{\"header\":\"FileWriter类\",\"slug\":\"filewriter类\",\"contents\":[\"java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\",\"构造方法:\",\"FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。\",\"FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。\",\"当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。\",\"构造举例，代码如下：\",\"public class FileWriterConstructor { public static void main(String[] args) throws IOException { // 使用File对象创建流对象 File file = new File(\\\"a.txt\\\"); FileWriter fw = new FileWriter(file); // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\\\"b.txt\\\"); } } \"]},{\"header\":\"写出字符串\",\"slug\":\"写出字符串\",\"contents\":[\"write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便，代码使用演示：\",\"public class FWWrite { public static void main(String[] args) throws IOException { // 使用文件名称创建流对象 FileWriter fw = new FileWriter(\\\"fw.txt\\\"); // 字符串 String msg = \\\"黑马程序员\\\"; // 写出字符数组 fw.write(msg); //黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(msg,2,2);// 程序 // 关闭资源 fos.close(); } } \"]},{\"header\":\"27.1.4 IO异常的处理\",\"slug\":\"_27-1-4-io异常的处理\",\"contents\":[]},{\"header\":\"JDK7的处理\",\"slug\":\"jdk7的处理\",\"contents\":[\"可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。\",\"格式：\",\"try (创建流对象语句，如果多个,使用';'隔开) { // 读写数据 } catch (IOException e) { e.printStackTrace(); } \",\"代码使用演示：\",\"public class HandleException2 { public static void main(String[] args) { // 创建流对象 try ( FileWriter fw = new FileWriter(\\\"fw.txt\\\"); ) { // 写出数据 fw.write(\\\"黑马程序员\\\"); //黑马程序员 } catch (IOException e) { e.printStackTrace(); } } } \"]},{\"header\":\"JDK9的改进\",\"slug\":\"jdk9的改进\",\"contents\":[\"JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。\",\"改进前格式：\",\"// 被final修饰的对象 final Resource resource1 = new Resource(\\\"resource1\\\"); // 普通对象 Resource resource2 = new Resource(\\\"resource2\\\"); // 引入方式：创建新的变量保存 try (Resource r1 = resource1; Resource r2 = resource2) { // 使用对象 } \",\"改进后格式：\",\"// 被final修饰的对象 final Resource resource1 = new Resource(\\\"resource1\\\"); // 普通对象 Resource resource2 = new Resource(\\\"resource2\\\"); // 引入方式：直接引入 try (resource1; resource2) { // 使用对象 } \",\"改进后，代码使用演示：\",\"public class TryDemo { public static void main(String[] args) throws IOException { // 创建流对象 final FileReader fr = new FileReader(\\\"in.txt\\\"); FileWriter fw = new FileWriter(\\\"out.txt\\\"); // 引入到try中 try (fr; fw) { // 定义变量 int b; // 读取数据 while ((b = fr.read())!=-1) { // 写出数据 fw.write(b); } } catch (IOException e) { e.printStackTrace(); } } } \"]},{\"header\":\"27.1.5 综合练习\",\"slug\":\"_27-1-5-综合练习\",\"contents\":[\"练习1：拷贝文件夹\",\"public class Test01 { public static void main(String[] args) throws IOException { //拷贝一个文件夹，考虑子文件夹 //1.创建对象表示数据源 File src = new File(\\\"D:\\\\\\\\aaa\\\\\\\\src\\\"); //2.创建对象表示目的地 File dest = new File(\\\"D:\\\\\\\\aaa\\\\\\\\dest\\\"); //3.调用方法开始拷贝 copydir(src,dest); } /* * 作用：拷贝文件夹 * 参数一：数据源 * 参数二：目的地 * * */ private static void copydir(File src, File dest) throws IOException { dest.mkdirs(); //递归 //1.进入数据源 File[] files = src.listFiles(); //2.遍历数组 for (File file : files) { if(file.isFile()){ //3.判断文件，拷贝 FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(new File(dest,file.getName())); byte[] bytes = new byte[1024]; int len; while((len = fis.read(bytes)) != -1){ fos.write(bytes,0,len); } fos.close(); fis.close(); }else { //4.判断文件夹，递归 copydir(file, new File(dest,file.getName())); } } } } \",\"练习2：文件加密\",\"public class Test02 { public static void main(String[] args) throws IOException { /* 为了保证文件的安全性，就需要对原始文件进行加密存储，再使用的时候再对其进行解密处理。 加密原理： 对原始文件中的每一个字节数据进行更改，然后将更改以后的数据存储到新的文件中。 解密原理： 读取加密之后的文件，按照加密的规则反向操作，变成原始文件。 ^ : 异或 两边相同：false 两边不同：true 0：false 1：true 100:1100100 10: 1010 1100100 ^ 0001010 __________ 1101110 ^ 0001010 __________ 1100100 */ } public static void encryptionAndReduction(File src, File dest) throws IOException { FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(dest); int b; while ((b = fis.read()) != -1) { fos.write(b ^ 2); } //4.释放资源 fos.close(); fis.close(); } } \",\"练习3：数字排序\",\"文本文件中有以下的数据： 2-1-9-4-7-8 将文件中的数据进行排序，变成以下的数据： 1-2-4-7-8-9\",\"实现方式一：\",\"public class Test03 { public static void main(String[] args) throws IOException { /* 文本文件中有以下的数据： 2-1-9-4-7-8 将文件中的数据进行排序，变成以下的数据： 1-2-4-7-8-9 */ //1.读取数据 FileReader fr = new FileReader(\\\"myio\\\\\\\\a.txt\\\"); StringBuilder sb = new StringBuilder(); int ch; while((ch = fr.read()) != -1){ sb.append((char)ch); } fr.close(); System.out.println(sb); //2.排序 String str = sb.toString(); String[] arrStr = str.split(\\\"-\\\");//2-1-9-4-7-8 ArrayList<Integer> list = new ArrayList<>(); for (String s : arrStr) { int i = Integer.parseInt(s); list.add(i); } Collections.sort(list); System.out.println(list); //3.写出 FileWriter fw = new FileWriter(\\\"myio\\\\\\\\a.txt\\\"); for (int i = 0; i < list.size(); i++) { if(i == list.size() - 1){ fw.write(list.get(i) + \\\"\\\"); }else{ fw.write(list.get(i) + \\\"-\\\"); } } fw.close(); } } \",\"实现方式二：\",\"public class Test04 { public static void main(String[] args) throws IOException { /* 文本文件中有以下的数据： 2-1-9-4-7-8 将文件中的数据进行排序，变成以下的数据： 1-2-4-7-8-9 细节1： 文件中的数据不要换行 细节2: bom头 */ //1.读取数据 FileReader fr = new FileReader(\\\"myio\\\\\\\\a.txt\\\"); StringBuilder sb = new StringBuilder(); int ch; while((ch = fr.read()) != -1){ sb.append((char)ch); } fr.close(); System.out.println(sb); //2.排序 Integer[] arr = Arrays.stream(sb.toString() .split(\\\"-\\\")) .map(Integer::parseInt) .sorted() .toArray(Integer[]::new); //3.写出 FileWriter fw = new FileWriter(\\\"myio\\\\\\\\a.txt\\\"); String s = Arrays.toString(arr).replace(\\\", \\\",\\\"-\\\"); String result = s.substring(1, s.length() - 1); fw.write(result); fw.close(); } } \"]},{\"header\":\"28 IO(其他流)\",\"slug\":\"_28-io-其他流\",\"contents\":[]},{\"header\":\"28.1 缓冲流\",\"slug\":\"_28-1-缓冲流\",\"contents\":[\"缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强，所以也是4个流，按照数据类型分类：\",\"字节缓冲流：BufferedInputStream，BufferedOutputStream\",\"字符缓冲流：BufferedReader，BufferedWriter\",\"缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\"]},{\"header\":\"28.1.1 字节缓冲流\",\"slug\":\"_28-1-1-字节缓冲流\",\"contents\":[\"构造方法:\",\"public BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流。\",\"public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。\",\"构造举例，代码如下：\",\"// 创建字节缓冲输入流 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\\\"bis.txt\\\")); // 创建字节缓冲输出流 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\\\"bos.txt\\\")); \"]},{\"header\":\"效率测试\",\"slug\":\"效率测试\",\"contents\":[\"public class BufferedDemo { public static void main(String[] args) throws FileNotFoundException { // 记录开始时间 long start = System.currentTimeMillis(); // 创建流对象 try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\\\"jdk9.exe\\\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\\\"copy.exe\\\")); ){ // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) { bos.write(bytes, 0 , len); } } catch (IOException e) { e.printStackTrace(); } // 记录结束时间 long end = System.currentTimeMillis(); System.out.println(\\\"缓冲流使用数组复制时间:\\\"+(end - start)+\\\" 毫秒\\\"); } } 缓冲流使用数组复制时间:666 毫秒 \"]},{\"header\":\"28.1.2 字符缓冲流\",\"slug\":\"_28-1-2-字符缓冲流\",\"contents\":[\"构造方法：\",\"public BufferedReader(Reader in) ：创建一个新的缓冲输入流。\",\"public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。\",\"构造举例，代码如下：\",\"// 创建字符缓冲输入流 BufferedReader br = new BufferedReader(new FileReader(\\\"br.txt\\\")); // 创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\\\"bw.txt\\\")); \"]},{\"header\":\"特有方法\",\"slug\":\"特有方法\",\"contents\":[\"字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\",\"BufferedReader：public String readLine(): 读一行文字。\",\"BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。\",\"readLine方法演示，代码如下：\",\"public class BufferedReaderDemo { public static void main(String[] args) throws IOException { // 创建流对象 BufferedReader br = new BufferedReader(new FileReader(\\\"in.txt\\\")); // 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) { System.out.print(line); System.out.println(\\\"------\\\"); } // 释放资源 br.close(); } } \",\"newLine方法演示，代码如下：\",\"public class BufferedWriterDemo throws IOException { public static void main(String[] args) throws IOException { // 创建流对象 BufferedWriter bw = new BufferedWriter(new FileWriter (\\\"out.txt\\\")); // 写出数据 bw.write(\\\"黑马\\\"); // 写出换行 bw.newLine(); bw.write(\\\"程序\\\"); bw.newLine(); bw.write(\\\"员\\\"); bw.newLine(); // 释放资源 bw.close(); } } 输出效果: 黑马 程序 员 \"]},{\"header\":\"练习:文本排序\",\"slug\":\"练习-文本排序\",\"contents\":[\"请将文本信息恢复顺序。\",\"3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。 8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。 4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。 2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。 1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。 9.今当远离，临表涕零，不知所言。 6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。 7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。 5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 \"]},{\"header\":\"案例分析\",\"slug\":\"案例分析\",\"contents\":[\"逐行读取文本信息。\",\"把读取到的文本存储到集合中\",\"对集合中的文本进行排序\",\"遍历集合，按顺序，写出文本信息。\"]},{\"header\":\"案例实现\",\"slug\":\"案例实现\",\"contents\":[\"public class Demo05Test { public static void main(String[] args) throws IOException { //1.创建ArrayList集合,泛型使用String ArrayList<String> list = new ArrayList<>(); //2.创建BufferedReader对象,构造方法中传递FileReader对象 BufferedReader br = new BufferedReader(new FileReader(\\\"10_IO\\\\\\\\in.txt\\\")); //3.创建BufferedWriter对象,构造方法中传递FileWriter对象 BufferedWriter bw = new BufferedWriter(new FileWriter(\\\"10_IO\\\\\\\\out.txt\\\")); //4.使用BufferedReader对象中的方法readLine,以行的方式读取文本 String line; while((line = br.readLine())!=null){ //5.把读取到的文本存储到ArrayList集合中 list.add(line); } //6.使用Collections集合工具类中的方法sort,对集合中的元素按照自定义规则排序 Collections.sort(list, new Comparator<String>() { /* o1-o2:升序 o2-o1:降序 */ @Override public int compare(String o1, String o2) { //依次比较集合中两个元素的首字母,升序排序 return o1.charAt(0)-o2.charAt(0); } }); //7.遍历ArrayList集合,获取每一个元素 for (String s : list) { //8.使用BufferedWriter对象中的方法wirte,把遍历得到的元素写入到文本中(内存缓冲区中) bw.write(s); //9.写换行 bw.newLine(); } //10.释放资源 bw.close(); br.close(); } } \"]},{\"header\":\"28.2 转换流\",\"slug\":\"_28-2-转换流\",\"contents\":[\"字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\",\"计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。\",\"1_charset\",\"可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。\",\"ASCII字符集 ： \",\"ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\",\"基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\",\"ISO-8859-1字符集： \",\"拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\",\"ISO-8859-1使用单字节编码，兼容ASCII编码。\",\"GBxxx字符集： \",\"GB就是国标的意思，是为了显示中文而设计的一套字符集。\",\"GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\\\"全角\\\"字符，而原来在127号以下的那些就叫\\\"半角\\\"字符了。\",\"GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\",\"GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\",\"Unicode字符集 ： \",\"Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\",\"它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。\",\"UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则： \",\"128个US-ASCII字符，只需一个字节编码。\",\"拉丁文等字符，需要二个字节编码。\",\"大部分常用字（含中文），使用三个字节编码。\",\"其他极少使用的Unicode辅助字符，使用四字节编码。\"]},{\"header\":\"28.2.1 InputStreamReader类\",\"slug\":\"_28-2-1-inputstreamreader类\",\"contents\":[\"转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\",\"构造方法:\",\"InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。\",\"InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。\",\"构造举例，代码如下：\",\"InputStreamReader isr = new InputStreamReader(new FileInputStream(\\\"in.txt\\\")); InputStreamReader isr2 = new InputStreamReader(new FileInputStream(\\\"in.txt\\\") , \\\"GBK\\\"); \"]},{\"header\":\"指定编码读取\",\"slug\":\"指定编码读取\",\"contents\":[\"public class ReaderDemo2 { public static void main(String[] args) throws IOException { // 定义文件路径,文件为gbk编码 String FileName = \\\"E:\\\\\\\\file_gbk.txt\\\"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \\\"GBK\\\"); // 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) { System.out.print((char)read); // ��Һ� } isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) { System.out.print((char)read);// 大家好 } isr2.close(); } } \"]},{\"header\":\"28.2.2 OutputStreamWriter类\",\"slug\":\"_28-2-2-outputstreamwriter类\",\"contents\":[\"转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\",\"构造方法:\",\"OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。\",\"OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。\",\"构造举例，代码如下：\",\"OutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\\\"out.txt\\\")); OutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\\\"out.txt\\\") , \\\"GBK\\\"); \"]},{\"header\":\"指定编码写出\",\"slug\":\"指定编码写出\",\"contents\":[\"public class OutputDemo { public static void main(String[] args) throws IOException { // 定义文件路径 String FileName = \\\"E:\\\\\\\\out.txt\\\"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write(\\\"你好\\\"); // 保存为6个字节 osw.close(); // 定义文件路径 String FileName2 = \\\"E:\\\\\\\\out2.txt\\\"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\\\"GBK\\\"); // 写出数据 osw2.write(\\\"你好\\\");// 保存为4个字节 osw2.close(); } } \"]},{\"header\":\"转换流理解图解\",\"slug\":\"转换流理解图解\",\"contents\":[\"转换流是字节与字符间的桥梁！\",\"2_zhuanhuan\",\"案例分析\",\"指定GBK编码的转换流，读取文本文件。\",\"使用UTF-8编码的转换流，写出文本文件。\",\"案例实现\",\"public class TransDemo { public static void main(String[] args) { // 1.定义文件路径 String srcFile = \\\"file_gbk.txt\\\"; String destFile = \\\"file_utf8.txt\\\"; // 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , \\\"GBK\\\"); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile)); // 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) { // 循环写出 osw.write(cbuf,0,len); } // 4.释放资源 osw.close(); isr.close(); } } \"]},{\"header\":\"28.3 序列化\",\"slug\":\"_28-3-序列化\",\"contents\":[\"Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。\",\"反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化：\",\"3_xuliehua\"]},{\"header\":\"28.3.1 ObjectOutputStream类\",\"slug\":\"_28-3-1-objectoutputstream类\",\"contents\":[\"java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\",\"构造方法:\",\"public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。\",\"构造举例，代码如下：\",\"FileOutputStream fileOut = new FileOutputStream(\\\"employee.txt\\\"); ObjectOutputStream out = new ObjectOutputStream(fileOut); \"]},{\"header\":\"序列化操作\",\"slug\":\"序列化操作\",\"contents\":[\"一个对象要想序列化，必须满足两个条件:\",\"该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\",\"该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\",\"public class Employee implements java.io.Serializable { public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() { System.out.println(\\\"Address check : \\\" + name + \\\" -- \\\" + address); } } \",\"2.写出对象方法\",\"public final void writeObject (Object obj) : 将指定的对象写出。\",\"public class SerializeDemo{ public static void main(String [] args) { Employee e = new Employee(); e.name = \\\"zhangsan\\\"; e.address = \\\"beiqinglu\\\"; e.age = 20; try { // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\\\"employee.txt\\\")); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println(\\\"Serialized data is saved\\\"); // 姓名，地址被序列化，年龄没有被序列化。 } catch(IOException i) { i.printStackTrace(); } } } 输出结果： Serialized data is saved \"]},{\"header\":\"28.3.1 ObjectInputStream类\",\"slug\":\"_28-3-1-objectinputstream类\",\"contents\":[\"ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。\",\"构造方法:\",\"public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。\"]},{\"header\":\"反序列化操作1\",\"slug\":\"反序列化操作1\",\"contents\":[\"如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：\",\"public final Object readObject () : 读取一个对象。\",\"public class DeserializeDemo { public static void main(String [] args) { Employee e = null; try { // 创建反序列化流 FileInputStream fileIn = new FileInputStream(\\\"employee.txt\\\"); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close(); }catch(IOException i) { // 捕获其他异常 i.printStackTrace(); return; }catch(ClassNotFoundException c) { // 捕获类找不到异常 System.out.println(\\\"Employee class not found\\\"); c.printStackTrace(); return; } // 无异常,直接打印输出 System.out.println(\\\"Name: \\\" + e.name);// zhangsan System.out.println(\\\"Address: \\\" + e.address); // beiqinglu System.out.println(\\\"age: \\\" + e.age); // 0 } } \",\"对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\"]},{\"header\":\"反序列化操作2\",\"slug\":\"反序列化操作2\",\"contents\":[\"**另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。**发生这个异常的原因如下：\",\"该类的序列版本号与从流中读取的类描述符的版本号不匹配\",\"该类包含未知数据类型\",\"该类没有可访问的无参数构造方法\",\"Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\",\"public class Employee implements java.io.Serializable { // 加入序列版本号 private static final long serialVersionUID = 1L; public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; public void addressCheck() { System.out.println(\\\"Address check : \\\" + name + \\\" -- \\\" + address); } } \"]},{\"header\":\"28.4 打印流\",\"slug\":\"_28-4-打印流\",\"contents\":[\"平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\",\"构造方法:\",\"public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。\",\"构造举例，代码如下：\",\"PrintStream ps = new PrintStream(\\\"ps.txt\\\")； \",\"改变打印流向:\",\"System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个\\\"小把戏\\\"，改变它的流向。\",\"public class PrintDemo { public static void main(String[] args) throws IOException { // 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream(\\\"ps.txt\\\"); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); } } ### 28.5 压缩流和解压缩流 压缩流：负责压缩文件或者文件夹 解压缩流：负责把压缩包中的文件和文件夹解压出来 ```java /* * 解压缩流 * * */ public class ZipStreamDemo1 { public static void main(String[] args) throws IOException { //1.创建一个File表示要解压的压缩包 File src = new File(\\\"D:\\\\\\\\aaa.zip\\\"); //2.创建一个File表示解压的目的地 File dest = new File(\\\"D:\\\\\\\\\\\"); //调用方法 unzip(src,dest); } //定义一个方法用来解压 public static void unzip(File src,File dest) throws IOException { //解压的本质：把压缩包里面的每一个文件或者文件夹读取出来，按照层级拷贝到目的地当中 //创建一个解压缩流用来读取压缩包中的数据 ZipInputStream zip = new ZipInputStream(new FileInputStream(src)); //要先获取到压缩包里面的每一个zipentry对象 //表示当前在压缩包中获取到的文件或者文件夹 ZipEntry entry; while((entry = zip.getNextEntry()) != null){ System.out.println(entry); if(entry.isDirectory()){ //文件夹：需要在目的地dest处创建一个同样的文件夹 File file = new File(dest,entry.toString()); file.mkdirs(); }else{ //文件：需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放） FileOutputStream fos = new FileOutputStream(new File(dest,entry.toString())); int b; while((b = zip.read()) != -1){ //写到目的地 fos.write(b); } fos.close(); //表示在压缩包中的一个文件处理完毕了。 zip.closeEntry(); } } zip.close(); } } \",\"public class ZipStreamDemo2 { public static void main(String[] args) throws IOException { /* * 压缩流 * 需求： * 把D:\\\\\\\\a.txt打包成一个压缩包 * */ //1.创建File对象表示要压缩的文件 File src = new File(\\\"D:\\\\\\\\a.txt\\\"); //2.创建File对象表示压缩包的位置 File dest = new File(\\\"D:\\\\\\\\\\\"); //3.调用方法用来压缩 toZip(src,dest); } /* * 作用：压缩 * 参数一：表示要压缩的文件 * 参数二：表示压缩包的位置 * */ public static void toZip(File src,File dest) throws IOException { //1.创建压缩流关联压缩包 ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(dest,\\\"a.zip\\\"))); //2.创建ZipEntry对象，表示压缩包里面的每一个文件和文件夹 //参数：压缩包里面的路径 ZipEntry entry = new ZipEntry(\\\"aaa\\\\\\\\bbb\\\\\\\\a.txt\\\"); //3.把ZipEntry对象放到压缩包当中 zos.putNextEntry(entry); //4.把src文件中的数据写到压缩包当中 FileInputStream fis = new FileInputStream(src); int b; while((b = fis.read()) != -1){ zos.write(b); } zos.closeEntry(); zos.close(); } } \",\"public class ZipStreamDemo3 { public static void main(String[] args) throws IOException { /* * 压缩流 * 需求： * 把D:\\\\\\\\aaa文件夹压缩成一个压缩包 * */ //1.创建File对象表示要压缩的文件夹 File src = new File(\\\"D:\\\\\\\\aaa\\\"); //2.创建File对象表示压缩包放在哪里（压缩包的父级路径） File destParent = src.getParentFile();//D:\\\\\\\\ //3.创建File对象表示压缩包的路径 File dest = new File(destParent,src.getName() + \\\".zip\\\"); //4.创建压缩流关联压缩包 ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dest)); //5.获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中 toZip(src,zos,src.getName());//aaa //6.释放资源 zos.close(); } /* * 作用：获取src里面的每一个文件，变成ZipEntry对象，放入到压缩包当中 * 参数一：数据源 * 参数二：压缩流 * 参数三：压缩包内部的路径 * */ public static void toZip(File src,ZipOutputStream zos,String name) throws IOException { //1.进入src文件夹 File[] files = src.listFiles(); //2.遍历数组 for (File file : files) { if(file.isFile()){ //3.判断-文件，变成ZipEntry对象，放入到压缩包当中 ZipEntry entry = new ZipEntry(name + \\\"\\\\\\\\\\\" + file.getName());//aaa\\\\\\\\no1\\\\\\\\a.txt zos.putNextEntry(entry); //读取文件中的数据，写到压缩包 FileInputStream fis = new FileInputStream(file); int b; while((b = fis.read()) != -1){ zos.write(b); } fis.close(); zos.closeEntry(); }else{ //4.判断-文件夹，递归 toZip(file,zos,name + \\\"\\\\\\\\\\\" + file.getName()); // no1 aaa \\\\\\\\ no1 } } } } \"]},{\"header\":\"28.6 工具包\",\"slug\":\"_28-6-工具包\",\"contents\":[\"Commons是apache开源基金组织提供的工具包，里面有很多帮助我们提高开发效率的API。\",\"其中：Commons-io是apache开源基金组织提供的一组有关IO操作的开源工具包。\",\"作用：提高IO流的开发效率\",\"hutool是国人开发的开源工具包，里面有很多帮助我们提高开发效率的API。\"]}]},\"/BackEnd/JavaSE/Javase09.html\":{\"title\":\"特殊文件、日志框架\",\"contents\":[]},\"/BackEnd/JavaSE/Javase10.html\":{\"title\":\"多线程技术\",\"contents\":[{\"header\":\"31. 多线程\",\"slug\":\"_31-多线程\",\"contents\":[\"是指从软件或者硬件上实现多个线程并发执行的技术。 具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。\",\"01_简单了解多线程\"]},{\"header\":\"31.1 并发和并行\",\"slug\":\"_31-1-并发和并行\",\"contents\":[\"并行：在同一时刻，有多个指令在多个CPU上同时执行。\",\"并发：在同一时刻，有多个指令在单个CPU上交替执行。\"]},{\"header\":\"31.2 进程和线程\",\"slug\":\"_31-2-进程和线程\",\"contents\":[\"进程：是正在运行的程序\",\"独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位 动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的 并发性：任何进程都可以同其他进程一起并发执行\",\"线程：是进程中的单个顺序控制流，是一条执行路径\",\"单线程：一个进程如果只有一条执行路径，则称为单线程程序 多线程：一个进程如果有多条执行路径，则称为多线程程序\",\"线程休眠:\",\"方法名\",\"说明\",\"static void sleep(long millis)\",\"使当前正在执行的线程停留（暂停执行）指定的毫秒数\",\"线程优先级:\",\"线程调度\",\"两种调度方式 \",\"分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片\",\"抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些\",\"Java使用的是抢占式调度模型\"]},{\"header\":\"32. 线程池\",\"slug\":\"_32-线程池\",\"contents\":[]},{\"header\":\"32.1 线程状态介绍\",\"slug\":\"_32-1-线程状态介绍\",\"contents\":[\"当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程\",\"状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：\",\"public class Thread { public enum State { /* 新建 */ NEW , /* 可运行状态 */ RUNNABLE , /* 阻塞状态 */ BLOCKED , /* 无限等待状态 */ WAITING , /* 计时等待 */ TIMED_WAITING , /* 终止 */ TERMINATED; } // 获取当前线程的状态 public State getState() { return jdk.internal.misc.VM.toThreadState(threadStatus); } } \",\"通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下\",\"线程状态\",\"具体含义\",\"NEW\",\"一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread()只有线程象，没有线程特征。\",\"RUNNABLE\",\"当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。\",\"BLOCKED\",\"当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。\",\"WAITING\",\"一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。\",\"TIMED_WAITING\",\"一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。\",\"TERMINATED\",\"一个完全运行完成的线程的状态。也称之为终止状态、结束状态\",\"各个状态的转换，如下图所示：\",\"1591163781941\"]}]},\"/BackEnd/JavaSE/Javase11.html\":{\"title\":\"网络编程\",\"contents\":[{\"header\":\"33. 网络编程\",\"slug\":\"_33-网络编程\",\"contents\":[]},{\"header\":\"33.1 计算机网络\",\"slug\":\"_33-1-计算机网络\",\"contents\":[\"是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和调下，实现资源共享和信息传递的计算机系统\",\"网络编程\",\"在网络通信协议下，不同计算机上运行的程序，可以进行数据传输\"]},{\"header\":\"32.2 网络编程三要素\",\"slug\":\"_32-2-网络编程三要素\",\"contents\":[\"IP地址\",\"要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识\",\"端口\",\"网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识\",\"协议\",\"通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议\"]}]},\"/BackEnd/JavaSE/Javase12.html\":{\"title\":\"Java基础加强\",\"contents\":[{\"header\":\"34. 反射\",\"slug\":\"_34-反射\",\"contents\":[\"专业的解释（了解一下）：\",\"是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；\",\"对于任意一个对象，都能够调用它的任意属性和方法；\",\"这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。\",\"通俗的理解：\",\"利用反射创建的对象可以无视修饰符调用类里面的内容\",\"可以跟配置文件结合起来使用，把要创建的对象信息和方法写在配置文件中。\",\"读取到什么类，就创建什么类的对象\",\"读取到什么方法，就调用什么方法\",\"此时当需求变更的时候不需要修改代码，只要修改配置文件即可。\"]},{\"header\":\"34.1 字节码文件和字节码文件对象\",\"slug\":\"_34-1-字节码文件和字节码文件对象\",\"contents\":[\"java文件：就是我们自己编写的java代码。\",\"字节码文件：就是通过java文件编译之后的class文件（是在硬盘上真实存在的，用眼睛能看到的）\",\"字节码文件对象：当class文件加载到内存之后，虚拟机自动创建出来的对象。\",\"这个对象里面至少包含了：构造方法，成员变量，成员方法。\",\"而我们的反射获取的是什么？字节码文件对象，这个对象在内存中是唯一的。\"]},{\"header\":\"35. 动态代理\",\"slug\":\"_35-动态代理\",\"contents\":[\"无侵入式的给方法增强功能\"]},{\"header\":\"35.1 动态代理三要素\",\"slug\":\"_35-1-动态代理三要素\",\"contents\":[\"1，真正干活的对象\",\"2，代理对象\",\"3，利用代理调用方法\",\"切记一点：代理可以增强或者拦截的方法都在接口中，接口需要写在newProxyInstance的第二个参数里。\",\"代码实现：\",\"public class Test { public static void main(String[] args) { /* 需求： 外面的人想要大明星唱一首歌 1. 获取代理的对象 代理对象 = ProxyUtil.createProxy(大明星的对象); 2. 再调用代理的唱歌方法 代理对象.唱歌的方法(\\\"只因你太美\\\"); */ //1. 获取代理的对象 BigStar bigStar = new BigStar(\\\"鸡哥\\\"); Star proxy = ProxyUtil.createProxy(bigStar); //2. 调用唱歌的方法 String result = proxy.sing(\\\"只因你太美\\\"); System.out.println(result); } } \",\"/* * * 类的作用： * 创建一个代理 * * */ public class ProxyUtil { /* * * 方法的作用： * 给一个明星的对象，创建一个代理 * * 形参： * 被代理的明星对象 * * 返回值： * 给明星创建的代理 * * * * 需求： * 外面的人想要大明星唱一首歌 * 1. 获取代理的对象 * 代理对象 = ProxyUtil.createProxy(大明星的对象); * 2. 再调用代理的唱歌方法 * 代理对象.唱歌的方法(\\\"只因你太美\\\"); * */ public static Star createProxy(BigStar bigStar){ /* java.lang.reflect.Proxy类：提供了为对象产生代理对象的方法： public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类 参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 参数三：用来指定生成的代理对象要干什么事情*/ Star star = (Star) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(),//参数一：用于指定用哪个类加载器，去加载生成的代理类 new Class[]{Star.class},//参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 //参数三：用来指定生成的代理对象要干什么事情 new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /* * 参数一：代理的对象 * 参数二：要运行的方法 sing * 参数三：调用sing方法时，传递的实参 * */ if(\\\"sing\\\".equals(method.getName())){ System.out.println(\\\"准备话筒，收钱\\\"); }else if(\\\"dance\\\".equals(method.getName())){ System.out.println(\\\"准备场地，收钱\\\"); } //去找大明星开始唱歌或者跳舞 //代码的表现形式：调用大明星里面唱歌或者跳舞的方法 return method.invoke(bigStar,args); } } ); return star; } } \",\"public interface Star { //我们可以把所有想要被代理的方法定义在接口当中 //唱歌 public abstract String sing(String name); //跳舞 public abstract void dance(); } \",\"public class BigStar implements Star { private String name; public BigStar() { } public BigStar(String name) { this.name = name; } //唱歌 @Override public String sing(String name){ System.out.println(this.name + \\\"正在唱\\\" + name); return \\\"谢谢\\\"; } //跳舞 @Override public void dance(){ System.out.println(this.name + \\\"正在跳舞\\\"); } /** * 获取 * @return name */ public String getName() { return name; } /** * 设置 * @param name */ public void setName(String name) { this.name = name; } public String toString() { return \\\"BigStar{name = \\\" + name + \\\"}\\\"; } } \",\"额外扩展：\",\"动态代理，还可以拦截方法\",\"比如：\",\"在这个故事中，经济人作为代理，如果别人让邀请大明星去唱歌，打篮球，经纪人就增强功能。\",\"但是如果别人让大明星去扫厕所，经纪人就要拦截，不会去调用大明星的方法。\",\"/* * 类的作用： * 创建一个代理 * */ public class ProxyUtil { public static Star createProxy(BigStar bigStar){ public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) Star star = (Star) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(), new Class[]{Star.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(\\\"cleanWC\\\".equals(method.getName())){ System.out.println(\\\"拦截，不调用大明星的方法\\\"); return null; } //如果是其他方法，正常执行 return method.invoke(bigStar,args); } } ); return star; } } \"]},{\"header\":\"35.2 动态代理的练习\",\"slug\":\"_35-2-动态代理的练习\",\"contents\":[\"对add方法进行增强，对remove方法进行拦截，对其他方法不拦截也不增强\",\"public class MyProxyDemo1 { public static void main(String[] args) { //动态代码可以增强也可以拦截 //1.创建真正干活的人 ArrayList<String> list = new ArrayList<>(); //2.创建代理对象 //参数一：类加载器。当前类名.class.getClassLoader() // 找到是谁，把当前的类，加载到内存中了，我再麻烦他帮我干一件事情，把后面的代理类，也加载到内存 //参数二：是一个数组，在数组里面写接口的字节码文件对象。 // 如果写了List，那么表示代理，可以代理List接口里面所有的方法，对这些方法可以增强或者拦截 // 但是，一定要写ArrayList真实实现的接口 // 假设在第二个参数中，写了MyInter接口，那么是错误的。 // 因为ArrayList并没有实现这个接口，那么就无法对这个接口里面的方法，进行增强或拦截 //参数三：用来创建代理对象的匿名内部类 List proxyList = (List) Proxy.newProxyInstance( //参数一：类加载器 MyProxyDemo1.class.getClassLoader(), //参数二：是一个数组，表示代理对象能代理的方法范围 new Class[]{List.class}, //参数三：本质就是代理对象 new InvocationHandler() { @Override //invoke方法参数的意义 //参数一：表示代理对象，一般不用（了解） //参数二：就是方法名，我们可以对方法名进行判断，是增强还是拦截 //参数三：就是下面第三步调用方法时，传递的参数。 //举例1： //list.add(\\\"阿玮好帅\\\"); //此时参数二就是add这个方法名 //此时参数三 args[0] 就是 阿玮好帅 //举例2： //list.set(1, \\\"aaa\\\"); //此时参数二就是set这个方法名 //此时参数三 args[0] 就是 1 args[1]\\\"aaa\\\" public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //对add方法做一个增强，统计耗时时间 if (method.getName().equals(\\\"add\\\")) { long start = System.currentTimeMillis(); //调用集合的方法，真正的添加数据 method.invoke(list, args); long end = System.currentTimeMillis(); System.out.println(\\\"耗时时间：\\\" + (end - start)); //需要进行返回，返回值要跟真正增强或者拦截的方法保持一致 return true; }else if(method.getName().equals(\\\"remove\\\") && args[0] instanceof Integer){ System.out.println(\\\"拦截了按照索引删除的方法\\\"); return null; }else if(method.getName().equals(\\\"remove\\\")){ System.out.println(\\\"拦截了按照对象删除的方法\\\"); return false; }else{ //如果当前调用的是其他方法,我们既不增强，也不拦截 method.invoke(list,args); return null; } } } ); //3.调用方法 //如果调用者是list，就好比绕过了第二步的代码，直接添加元素 //如果调用者是代理对象，此时代理才能帮我们增强或者拦截 //每次调用方法的时候，都不会直接操作集合 //而是先调用代理里面的invoke，在invoke方法中进行判断，可以增强或者拦截 proxyList.add(\\\"aaa\\\"); proxyList.add(\\\"bbb\\\"); proxyList.add(\\\"ccc\\\"); proxyList.add(\\\"ddd\\\"); proxyList.remove(0); proxyList.remove(\\\"aaa\\\"); //打印集合 System.out.println(list); } } \"]},{\"header\":\"36. 日志\",\"slug\":\"_36-日志\",\"contents\":[\"跟输出语句一样，可以把程序在运行过程中的详细信息都打印在控制台上。\",\"利用log日志还可以把这些详细信息保存到文件和数据库中。\"]},{\"header\":\"36.1 使用步骤\",\"slug\":\"_36-1-使用步骤\",\"contents\":[\"不是java的，也不是自己写的，是第三方提供的代码，所以我们要导入jar包。\",\"把第三方的代码导入到当前的项目当中\",\"新建lib文件夹，把jar粘贴到lib文件夹当中，全选后右键点击选择add as a ....\",\"检测导入成功：导入成功后jar包可以展开。在项目重构界面可以看到导入的内容\",\"把配置文件粘贴到src文件夹下\",\"在代码中获取日志对象\",\"调用方法打印日志\"]},{\"header\":\"36.2 日志级别\",\"slug\":\"_36-2-日志级别\",\"contents\":[\"TRACE, DEBUG, INFO, WARN, ERROR \",\"还有两个特殊的：\",\"ALL：输出所有日志\",\"OFF：关闭所有日志\",\"日志级别从小到大的关系：\",\"TRACE < DEBUG < INFO < WARN < ERR\"]},{\"header\":\"36.2 配置文件\",\"slug\":\"_36-2-配置文件\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <configuration> <!-- CONSOLE ：表示当前的日志信息是可以输出到控制台的。 --> <appender name=\\\"CONSOLE\\\" class=\\\"ch.qos.logback.core.ConsoleAppender\\\"> <!--输出流对象 默认 System.out 改为 System.err--> <target>System.out</target> <encoder> <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--> <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%-5level] %c [%thread] : %msg%n</pattern> </encoder> </appender> <!-- File是输出的方向通向文件的 --> <appender name=\\\"FILE\\\" class=\\\"ch.qos.logback.core.rolling.RollingFileAppender\\\"> <encoder> <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern> <charset>utf-8</charset> </encoder> <!--日志输出路径--> <file>C:/code/itheima-data.log</file> <!--指定日志文件拆分和压缩规则--> <rollingPolicy class=\\\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\\\"> <!--通过指定压缩文件名称，来确定分割文件方式--> <fileNamePattern>C:/code/itheima-data2-%d{yyyy-MMdd}.log%i.gz</fileNamePattern> <!--文件拆分大小--> <maxFileSize>1MB</maxFileSize> </rollingPolicy> </appender> <!-- level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF ， 默认debug <root>可以包含零个或多个<appender-ref>元素，标识这个输出位置将会被本日志级别控制。 --> <root level=\\\"info\\\"> <appender-ref ref=\\\"CONSOLE\\\"/> <appender-ref ref=\\\"FILE\\\" /> </root> </configuration> \"]},{\"header\":\"37. 类加载器\",\"slug\":\"_37-类加载器\",\"contents\":[\"基础加强包含了：\",\"反射，动态代理，类加载器，xml，注解，日志，单元测试等知识点\",\"其中最难的是反射和动态代理，其他知识点都非常简单\",\"略\"]},{\"header\":\"38. xml\",\"slug\":\"_38-xml\",\"contents\":[\"略\"]},{\"header\":\"39. 单元测试\",\"slug\":\"_39-单元测试\",\"contents\":[\"对部分代码进行测试。\"]},{\"header\":\"39.1 Junit的特点？\",\"slug\":\"_39-1-junit的特点\",\"contents\":[\"是一个第三方的工具。（把别人写的代码导入项目中）（专业叫法：导jar包）\",\"如果运行结果显示绿色，表示运行结果是正确的。\",\"如果运行结果显示红色，表示运行结果是错误的\"]},{\"header\":\"39.2 运行测试代码\",\"slug\":\"_39-2-运行测试代码\",\"contents\":[\"只能直接运行无参无返回值的非静态方法\",\"想要运行谁，就右键点击哪个方法。如果想要运行一个类里面所有的测试方法，选择类名，有点点击即可。\"]},{\"header\":\"39.3 正确使用方式\",\"slug\":\"_39-3-正确使用方式\",\"contents\":[\"1，新建测试类\",\"2，新建测试方法（要测试的方法名 + Test） methodTest\",\"3，在这个方法中直接调用要测试的方法\",\"4，在测试方法的上面写@Test\",\"代码示例：\",\" //真正用来测试的类 //测试用例（测试类） public class JunitTest { //在这个类里面再写无参无返回值的非静态方法 //在方法中调用想要测试的方法 @Test public void method2Test(){ //调用要测试的方法 JunitDemo1 jd = new JunitDemo1(); jd.method2(10); } } \"]},{\"header\":\"39.4 实际开发中单元测试的使用方式\",\"slug\":\"_39-4-实际开发中单元测试的使用方式\",\"contents\":[\"需求：测试File中的delete方法，写的是否正确（掌握）\",\"开发中的测试原则：\",\"不污染原数据。\",\"代码示例：\",\"public class JunitDemo3 { //在实际开发中，真正完整的单元测试该怎么写？ //前提： //以后在工作的时候，测试代码不能污染原数据。（修改，篡改） //1.利用Before去对数据做一个初始化的动作 //2.利用Test真正的去测试方法 //3.利用After去还原数据 //需求：测试File类中的delete方法是否书写正确？？？ @Before public void beforemethod() throws IOException { //先备份 File src = new File(\\\"C:\\\\\\\\Users\\\\\\\\moon\\\\\\\\Desktop\\\\\\\\a.txt\\\"); File dest = new File(\\\"C:\\\\\\\\Users\\\\\\\\moon\\\\\\\\Desktop\\\\\\\\copy.txt\\\"); FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(dest); int b; while((b = fis.read()) != -1){ fos.write(b); } fos.close(); fis.close(); } //作为一个标准的测试人员，运行完单元测试之后，不能污染原数据 //需要达到下面两个要求： //1.得到结果 //2.a.txt还在而且其他的备份文件消失 @Test public void method(){ File file = new File(\\\"C:\\\\\\\\Users\\\\\\\\moon\\\\\\\\Desktop\\\\\\\\a.txt\\\"); boolean delete = file.delete(); //检查a.txt是否存在 boolean exists = file.exists(); //只有同时满足了下面所有的断言，才表示delete方法编写正确 Assert.assertEquals(\\\"delete方法出错了\\\",delete,true); Assert.assertEquals(\\\"delete方法出错了\\\",exists,false); } @After public void aftermethod() throws IOException { //还要对a.txt做一个还原 File src = new File(\\\"C:\\\\\\\\Users\\\\\\\\moon\\\\\\\\Desktop\\\\\\\\copy.txt\\\"); File dest = new File(\\\"C:\\\\\\\\Users\\\\\\\\moon\\\\\\\\Desktop\\\\\\\\a.txt\\\"); FileInputStream fis = new FileInputStream(src); FileOutputStream fos = new FileOutputStream(dest); int b; while((b = fis.read()) != -1){ fos.write(b); } fos.close(); fis.close(); //备份数据要删除 src.delete(); } } \"]},{\"header\":\"40. 注解\",\"slug\":\"_40-注解\",\"contents\":[]},{\"header\":\"40.1 注释和注解的区别？\",\"slug\":\"_40-1-注释和注解的区别\",\"contents\":[\"共同点：都可以对程序进行解释说明。\",\"不同点：注释，是给程序员看的。只在Java中有效。在class文件中不存在注释的。\",\"当编译之后，会进行注释擦除。\",\"注解，是给虚拟机看的。当虚拟机看到注解之后，就知道要做什么事情了。\"]},{\"header\":\"40.2 Java中已经存在的注解\",\"slug\":\"_40-2-java中已经存在的注解\",\"contents\":[\"@Override：表示方法的重写\",\"@Deprecated：表示修饰的方法已过时\",\"@SuppressWarnings(\\\"all\\\")：压制警告\",\"除此之外，还需要掌握第三方框架中提供的注解：\",\"比如：Junit\",\"@Test 表示运行测试方法\",\"@Before 表示在Test之前运行，进行数据的初始化\",\"@After 表示在Test之后运行，进行数据的还原\"]},{\"header\":\"40.3 特殊属性\",\"slug\":\"_40-3-特殊属性\",\"contents\":[\"value：当注解中只有\\\"一个属性\\\",并且属性名是\\\"value\\\",使用注解时,可以省略value属性名\",\"代码示例：\",\"//注解的定义 public @interface Anno2 { public String value(); public int age() default 23; } //注解的使用 @Anno2(\\\"123\\\") public class AnnoDemo2 { @Anno2(\\\"123\\\") public void method(){ } } \"]},{\"header\":\"40.4 元注解\",\"slug\":\"_40-4-元注解\",\"contents\":[\"可以写在注解上面的注解\",\"@Target ：指定注解能在哪里使用\",\"@Retention ：可以理解为保留时间(生命周期)\",\"Target：\",\"作用：用来标识注解使用的位置，如果没有使用该注解标识，则自定义的注解可以使用在任意位置。\",\"可使用的值定义在ElementType枚举类中，常用值如下\",\"TYPE，类，接口\",\"FIELD, 成员变量\",\"METHOD, 成员方法\",\"PARAMETER, 方法参数\",\"CONSTRUCTOR, 构造方法\",\"LOCAL_VARIABLE, 局部变量\",\"Retention：\",\"作用：用来标识注解的生命周期(有效范围)\",\"可使用的值定义在RetentionPolicy枚举类中，常用值如下\",\"SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在\",\"CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值\",\"RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段\"]}]},\"/BackEnd/JavaSE/\":{\"title\":\"JavaSE大纲\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"提示\",\"基本语法\",\"面向对象\",\"基础API\",\"常用API\",\"JDK8新特性 （Lambda表达式、Stream流、方法引用）\",\"集合框架 （集合体系、数据结构、 Stream流）\",\"异常处理 （虚拟机如何处理异常、自己处理异常的两种方式）\",\"IO流体系 （文件相关的类File、以及常见的流）\",\"特殊文件、日志框架 （常见的文件、Properties、XML文件，介绍日志技术）\",\"多线程技术\",\"网络编程\",\"Java基础加强 主要介绍了Java中的框架级技术，为将来学习框架，理解源码打下基础\"]}]},\"/BackEnd/JavaWeb/\":{\"title\":\"JavaWeb\",\"contents\":[{\"header\":\"什么是 web 开发\",\"slug\":\"什么是-web-开发\",\"contents\":[\"Web：全球广域网，也称为万维网 ( www World Wide Web ) ，能够通过浏览器访问的网站。\"]},{\"header\":\"网站的工作流程\",\"slug\":\"网站的工作流程\",\"contents\":[\"首先我们需要通过浏览器访问发布到前端服务器中的前端程序，这时候前端程序会将前端代码返回给浏览器\",\"浏览器得到前端代码，此时浏览器会将前端代码进行解析，展示到浏览器的窗口中，这时候我们就看到了网站的页面\",\"但是此时页面是没有数据的，因为数据在数据库中，所以浏览器需要根据前端代码中指定的后台服务器的地址向后台服务器（内部有java程序）发起请求，后台服务器再去从数据库中获取数据，随后返回给浏览器。\",\"浏览器拿到后台返回的数据后，将数据展示在前端资源也就是网页上\",\"整个流程如下：\",\"浏览器先向前端服务器请求前端资源，也就是我们所说的网页\",\"浏览器再向后台服务器发起请求，获取数据\",\"浏览器将得到的后台数据填充到网页上，展示给用户去看\"]},{\"header\":\"网站的开发模式\",\"slug\":\"网站的开发模式\",\"contents\":[\"主要有2种：前后端分离和混合开发\",\"前后端分离： 目前企业开发的主流\",\"特点\",\"前端人员开发前端程序，前端程序单独部署到前端服务器上\",\"后端人员开发后端程序，后端程序单独部署到后端服务器上\",\"混合开发：早期开发技术\",\"特点\",\"前端人员开发的代码和后端人员开发的代码在同一个项目中，一起打包部署。\"]},{\"header\":\"网站的开发技术\",\"slug\":\"网站的开发技术\",\"contents\":[\"前端web开发：\",\"技术\",\"描述\",\"HTML\",\"用于构建网站的基础结构\",\"CSS\",\"用于美化页面\",\"JavaScript\",\"实现网页和用户的交互\",\"Vue\",\"将数据填充到html页面上的\",\"Element\",\"提供一些美观的组件\",\"Nginx\",\"一款web服务器软件，用于部署前端工程\",\"后端web开发：\",\"技术\",\"描述\",\"Maven\",\"管理项目的软件\",\"Mysql\",\"数据库软件之一\",\"SpringBoot\",\"spring家族的产品，当前最为主流的项目开发技术。\",\"Mybatis\",\"操作数据库的框架\"]}]},\"/BackEnd/JavaWeb/javaweb01.html\":{\"title\":\"Maven\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Maven是专门用于构建和管理Java项目的工具\",\"主要功能：\",\"提供了一套标准化的 项目结构 提供了一套标准化的 构建流程 （编译，测试，打包，发布……） 提供了一套 依赖管理 机制\",\"Maven使用标准的 坐标 配置来管理各种依赖\"]},{\"header\":\"1 Maven简介\",\"slug\":\"_1-maven简介\",\"contents\":[\"Apache Maven 是一个项目管理和构建的工具，它基于项目对象模型 ( POM ) 的概念，通过一小段描述信息来管理项目的构建、报告和文档。\"]},{\"header\":\"1.1 Maven模型\",\"slug\":\"_1-1-maven模型\",\"contents\":[\"项目对象模型 (Project Object Model)\",\"依赖管理模型(Dependency)\",\"插件(Plugin)\",\"上图就是Maven的模型，紫色部分，是用来完成 标准化构建流程 。如我们需要编译，Maven提供了一个编译插件，我们需要打包，Maven就提供了一个打包插件。\",\"上图紫色部分，项目对象模型就是将自己抽象成一个对象模型，有自己专属的坐标，如下图所示\",\"依赖管理模型则是使用坐标来描述当前项目依赖哪些第三方 jar 包\"]},{\"header\":\"1.2 仓库分类\",\"slug\":\"_1-2-仓库分类\",\"contents\":[\"本地仓库：自己计算机上的一个目录\",\"中央仓库：由Maven团队维护的全球唯一的仓库\",\"远程仓库(私服)：一般由公司团队搭建的私有仓库\"]},{\"header\":\"2 Maven安装配置\",\"slug\":\"_2-maven安装配置\",\"contents\":[\"目录结构：\",\"bin目录 ： 可执行命令。mvn 命令（重点关注）。\",\"conf目录 ： Maven的配置文件。settings.xml\",\"lib目录 ： Maven依赖的jar包。Maven也是使用java开发的，所以它也依赖其他的jar包。\",\"配置本地仓库：\",\"修改 conf/settings.xml 中的 <localRepository> 为一个指定目录作为本地仓库，用来存储jar包。\",\"配置阿里云私服： 修改 conf/settings.xml 中的 <mirrors> 标签，添加子标签：\",\"<mirror> <id>alimaven</id> <name>aliyun maven</name> <url>http://maven.aliyun.com/nexus/content/groups/public/</url> <mirrorOf>central</mirrorOf> </mirror> \"]},{\"header\":\"3 Maven基本使用\",\"slug\":\"_3-maven基本使用\",\"contents\":[]},{\"header\":\"3.1 Maven 常用命令\",\"slug\":\"_3-1-maven-常用命令\",\"contents\":[\"5个常用命令\",\"compile ：编译 （ 编译项目源代码 ） clean：清理（ 移除上一次构建生成的文件 ） test：测试 （ 使用合适的单元测试框架运行测试(junit) ） package：打包 （ 将编译后的文件打包，如：jar、war等 ） install：安装 （ 安装项目到本地仓库 ）\",\"安装命令演示：\",\"mvn install \",\"该命令会将当前项目打成jar包，并安装到本地仓库。\"]},{\"header\":\"3.2 Maven 生命周期\",\"slug\":\"_3-2-maven-生命周期\",\"contents\":[\"Maven对项目构建的生命周期划分为3套（相互独立）：\",\"clean ：清理工作。\",\"default ：核心工作，例如编译、测试、打包、安装、部署等。\",\"site ： 产生报告，发布站点等。这套声明周期一般不会使用。\",\"同一套生命周期内，执行后边的命令，前面的所有命令会自动执行。例如默认（default）生命周期如下：\",\"当我们执行 install（安装）命令时，它会先执行 compile命令，再执行 test 命令，再执行 package 命令，最后执行 install 命令。\",\"三套生命周期又包含哪些具体的阶段呢？\"]},{\"header\":\"4 IDEA使用Maven\",\"slug\":\"_4-idea使用maven\",\"contents\":[\"什么是坐标？\",\"Maven 中的坐标是资源的唯一标识\",\"使用坐标来定义项目或引入项目中需要的依赖\",\"Maven 坐标主要组成:\",\"groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.baidu）\",\"artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）\",\"version：定义当前项目版本号\",\"注意\",\"上面所说的资源可以是插件、依赖、当前项目。 项目如果被其他的项目依赖时，也是需要坐标来引入的。\"]},{\"header\":\"5 依赖管理\",\"slug\":\"_5-依赖管理\",\"contents\":[\"Maven坐标网站\"]},{\"header\":\"5.1 添加依赖的几种方式\",\"slug\":\"_5-1-添加依赖的几种方式\",\"contents\":[\"利用中央仓库搜索的依赖坐标\",\"利用IDEA工具搜索依赖坐标\",\"快速导入依赖坐标\"]},{\"header\":\"5.2 依赖范围\",\"slug\":\"_5-2-依赖范围\",\"contents\":[\"设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境。\",\"下图给 junit 依赖通过 scope 标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。\",\"那么 scope 都可以有哪些取值呢？\",\"依赖范围\",\"编译classpath\",\"测试classpath\",\"运行classpath\",\"例子\",\"compile\",\"Y\",\"Y\",\"Y\",\"logback\",\"test\",\"-\",\"Y\",\"-\",\"Junit\",\"provided\",\"Y\",\"Y\",\"-\",\"servlet-api\",\"runtime\",\"-\",\"Y\",\"Y\",\"jdbc驱动\",\"system\",\"Y\",\"Y\",\"-\",\"存储在本地的jar包\",\"compile ：作用于编译环境、测试环境、运行环境。\",\"test ： 作用于测试环境。典型的就是Junit坐标，以后使用Junit时，都会将scope指定为该值\",\"provided ：作用于编译环境、测试环境。servlet-api ，在使用它时，必须将 scope 设置为该值，不然运行时就会报错\",\"runtime ： 作用于测试环境、运行环境。jdbc驱动一般将 scope 设置为该值，当然不设置也没有任何问题\"]},{\"header\":\"5.3 更新依赖索引\",\"slug\":\"_5-3-更新依赖索引\",\"contents\":[\"有时候idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中，这个时候要更新idea中maven的索引。\",\"具体做法：打开设置----> 搜索maven----> Repositories----> 选中本地仓库-----> 点击Update\"]}]},\"/BackEnd/JavaWeb/javaweb02.html\":{\"title\":\"HTTP协议\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"SpringFramework中提供很多实用功能 如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。\"]},{\"header\":\"1. Web分析\",\"slug\":\"_1-web分析\",\"contents\":[]},{\"header\":\"2. HTTP协议\",\"slug\":\"_2-http协议\",\"contents\":[]},{\"header\":\"2.1 HTTP-概述\",\"slug\":\"_2-1-http-概述\",\"contents\":[\"介绍:\",\"HTTP：Hyper Text Transfer Protocol（ 超文本传输协议 ），规定了浏览器与服务器之间数据传输的规则。\",\"浏览器向服务器进行请求时：\",\"服务器向浏览器进行响应时：\",\"特点\",\"基于TCP协议: 面向连接，安全\",\"基于请求-响应模型: 一次请求对应一次响应（先请求后响应）\",\"HTTP协议是无状态协议: 对于数据没有记忆能力。每次请求-响应都是独立的\"]},{\"header\":\"2.2 HTTP-请求协议\",\"slug\":\"_2-2-http-请求协议\",\"contents\":[\"浏览器和服务器是按照HTTP协议进行数据通信的。\",\"HTTP协议又分为：请求协议和响应协议\",\"请求协议：浏览器将数据以请求格式发送到服务器 \",\"包括：请求行、请求头 、请求体\",\"响应协议：服务器将数据以响应格式返回给浏览器 \",\"包括：响应行 、响应头 、响应体\",\"GET请求和POST请求的区别：\",\"区别方式\",\"GET请求\",\"POST请求\",\"请求参数\",\"请求参数在请求行中。例：/brand/findAll?name=OPPO&status=1\",\"请求参数在请求体中\",\"请求参数长度\",\"请求参数长度有限制(浏览器不同限制也不同)\",\"请求参数长度没有限制\",\"安全性\",\"安全性低。原因：请求参数暴露在浏览器地址栏中。\",\"安全性相对高\"]},{\"header\":\"2.3 HTTP-响应协议\",\"slug\":\"_2-3-http-响应协议\",\"contents\":[\"与HTTP的请求一样，HTTP响应的数据也分为3部分：响应行、响应头 、响应体\",\"响应行由协议及版本、响应状态码、状态码描述组成\"]},{\"header\":\"响应状态码\",\"slug\":\"响应状态码\",\"contents\":[\"状态码分类\",\"说明\",\"1xx\",\"响应中 --- 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略\",\"2xx\",\"成功 --- 表示请求已经被成功接收，处理已完成\",\"3xx\",\"重定向 --- 重定向到其它地方，让客户端再发起一个请求以完成整个处理\",\"4xx\",\"客户端错误 --- 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等\",\"5xx\",\"服务器端错误 --- 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等\"]},{\"header\":\"3. WEB服务器-Tomcat\",\"slug\":\"_3-web服务器-tomcat\",\"contents\":[]},{\"header\":\"3.1 服务器概述\",\"slug\":\"_3-1-服务器概述\",\"contents\":[\"服务器硬件:\",\"服务器是提供计算服务的设备。\",\"服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。\",\"在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。\",\"服务器软件:\",\"基于ServerSocket编写的程序\",\"服务器软件本质是一个运行在服务器设备上的应用程序\",\"能够接收客户端请求，并根据请求给客户端响应数据\"]},{\"header\":\"Web服务器\",\"slug\":\"web服务器\",\"contents\":[\"Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装。主要功能是\\\"提供网上信息浏览服务\\\"。\"]},{\"header\":\"Tomcat\",\"slug\":\"tomcat\",\"contents\":[\"Tomcat服务器软件是一个免费的开源的web应用服务器\",\"因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。JavaWeb程序需要依赖Tomcat才能运行。\"]}]},\"/BackEnd/JavaWeb/javaweb03.html\":{\"title\":\"Maven高级\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Maven 是一款 构建和管理 Java 项目的工具\"]},{\"header\":\"1. 分模块设计与开发\",\"slug\":\"_1-分模块设计与开发\",\"contents\":[]},{\"header\":\"1.1 介绍\",\"slug\":\"_1-1-介绍\",\"contents\":[\"在设计一个 Java 项目的时候，将一个 Java 项目拆分成多个模块进行开发。\",\"1. 未分模块设计的问题:\",\"总结，两点问题：不方便项目的维护和管理、项目中的通用组件难以复用。\",\"2. 分模块设计:\",\"项目设计阶段，将一个大的项目拆分成若干个模块，每一个模块都是独立的\",\"分模块设计就是将项目按照功能/结构拆分成若干个子模块，方便项目的管理维护、拓展，也方便模块键的相互调用、资源共享。\"]},{\"header\":\"1.2 实践\",\"slug\":\"_1-2-实践\",\"contents\":[]},{\"header\":\"1.2.1 分析\",\"slug\":\"_1-2-1-分析\",\"contents\":[\"在这个项目当中，除了开发的部门管理以及员工管理、登录认证等相关业务功能以外，也定义了一些实体类，也就是pojo包下存放的一些类，像分页结果的封装类PageBean、 统一响应结果Result，还定义了一些通用的工具类，像Jwts、阿里云OSS操作的工具类等等。\",\"如果在当前公司的其他项目组当中，也想使用封装的公共的组件，该怎么办？\",\"方案一：直接依赖当前项目 tlias-web-management ，但是存在两大缺点：\",\"这个项目当中包含所有的业务功能代码，而想共享的资源，仅仅是pojo下的实体类，以及 utils 下的工具类。如果全部都依赖进来，项目在启动时将会把所有的类都加载进来，会影响性能。\",\"如果直接把这个项目都依赖进来了，那也就意味着所有的业务代码都对外公开了，是非常不安全的。\",\"方案二：分模块设计\",\"将pojo包下的实体类，抽取到一个maven模块中 tlias-pojo\",\"将utils包下的工具类，抽取到一个maven模块中 tlias-utils\",\"其他的业务代码，放在tlias-web-management这个模块中，在该模块中需要用到实体类pojo、工具类utils，直接引入对应的依赖即可。\",\"注意：分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。\"]},{\"header\":\"1.2.2 实现\",\"slug\":\"_1-2-2-实现\",\"contents\":[\"1. 创建maven模块 tlias-pojo，存放实体类:\",\"A. 创建一个正常的Maven模块，模块名tlias-pojo\",\"B. 然后在tlias-pojo中创建一个包 com.itheima.pojo (和原来案例项目中的pojo包名一致)\",\"C. 将原来案例项目 tlias-web-management 中的pojo包下的实体类，复制到tlias-pojo模块中\",\"D. 在 tlias-pojo 模块的pom.xml文件中引入依赖\",\"<dependencies> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.24</version> </dependency> </dependencies> \",\"E. 删除原有案例项目tlias-web-management的pojo包【直接删除不要犹豫，已经将该模块拆分出去了】，然后在pom.xml中引入 tlias-pojo的依赖\",\"<dependency> <groupId>com.itheima</groupId> <artifactId>tlias-pojo</artifactId> <version>1.0-SNAPSHOT</version> </dependency> \",\"2. 创建Maven模块 tlias-utils，存放相关工具类:\",\"A. 创建一个正常的Maven模块，模块名tlias-utils\",\"B. 然后在 tlias-utils 中创建一个包 com.itheima.utils (和原来案例项目中的utils包名一致)\",\"C. 将原来案例项目 tlias-web-management 中的utils包下的实体类，复制到tlias-utils模块中\",\"D. 在 tlias-utils 模块的pom.xml文件中引入依赖\",\"<dependencies> <!--JWT令牌--> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt</artifactId> <version>0.9.1</version> </dependency> <!--阿里云OSS--> <dependency> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-sdk-oss</artifactId> <version>3.15.1</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>activation</artifactId> <version>1.1.1</version> </dependency> <!-- no more than 2.3.3--> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>2.3.3</version> </dependency> <!--WEB开发--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> <version>2.7.5</version> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.24</version> </dependency> </dependencies> \",\"E. 删除原有案例项目tlias-web-management的utils包【直接删除不要犹豫，已经将该模块拆分出去了】，然后在pom.xml中引入 tlias-utils的依赖\",\"<dependency> <groupId>com.itheima</groupId> <artifactId>tlias-utils</artifactId> <version>1.0-SNAPSHOT</version> </dependency> \",\"拆分出了 tlias-pojo、tlias-utils、tlias-web-management ，如果其他项目中需要用到 pojo，或者 utils工具类，就可以直接引入依赖。\"]},{\"header\":\"1.3 总结\",\"slug\":\"_1-3-总结\",\"contents\":[\"什么是分模块设计：将项目按照功能拆分成若干个子模块\",\"为什么要分模块设计：方便项目的管理维护、扩展，也方便模块间的相互调用，资源共享\",\"注意事项：分模块设计需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分\"]},{\"header\":\"2. 继承与聚合\",\"slug\":\"_2-继承与聚合\",\"contents\":[\"tlias-pojo、tlias-utils、tlias-web-management中都引入了一个依赖 lombok 的依赖\"]},{\"header\":\"2.1 继承\",\"slug\":\"_2-1-继承\",\"contents\":[\"创建一个父工程tlias-parent，让上述的三个模块tlias-pojo、tlias-utils、tlias-web-management继承父工程。再将各个模块中都共有的依赖，都提取到父工程 tlias-parent 中进行配置\",\"概念：继承描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。\",\"作用：简化依赖配置、统一管理依赖\",\"实现：\",\"<parent> <groupId>...</groupId> <artifactId>...</artifactId> <version>...</version> <relativePath>....</relativePath> </parent> \"]},{\"header\":\"2.1.1 继承关系\",\"slug\":\"_2-1-1-继承关系\",\"contents\":[\"思路分析：\",\"项目 tlias-web-management，稍微有一点特殊，因为是一个springboot项目，而所有的springboot项目都有一个统一的父工程，就是spring-boot-starter-parent。\",\"创建的三个模块，都继承tlias-parent，而tlias-parent 再继承 spring-boot-starter-parent\",\"实现：\",\"创建maven模块 tlias-parent ，该工程为父工程，设置打包方式pom(默认jar)。\",\"工程结构如下：\",\"父工程tlias-parent的pom.xml文件配置如下：\",\"<parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.7.5</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.itheima</groupId> <artifactId>tlias-parent</artifactId> <version>1.0-SNAPSHOT</version> <packaging>pom</packaging> \",\"Maven打包方式：\",\"jar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）\",\"war：普通web程序打包，需要部署在外部的tomcat服务器中运行\",\"pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理\",\"在子工程的pom.xml文件中，配置继承关系。\",\"<parent> <groupId>com.itheima</groupId> <artifactId>tlias-parent</artifactId> <version>1.0-SNAPSHOT</version> <relativePath>../tlias-parent/pom.xml</relativePath> </parent> <artifactId>tlias-utils</artifactId> <version>1.0-SNAPSHOT</version> \",\"这里是以 tlias-utils 为例，指定了其父工程。其他的模块，都是相同的配置方式。\",\"注意：\",\"在子工程中，配置了继承关系之后，坐标中的groupId是可以省略的，因为会自动继承父工程的 。\",\"relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找该工程）。\",\"在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）。\",\"<dependencies> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.24</version> </dependency> </dependencies> \",\"工程结构说明：\",\"项目开发完毕之后，基于现有项目拆分的各个模块，tlias-web-management已经存在了，然后再创建各个模块与父工程，所以父工程与模块之间是平级的。\",\"而实际项目中，可能还会见到下面的工程结构：\",\"而在真实的企业开发中，都是先设计好模块之后，再开始创建模块，开发项目。 此时呢，一般都会先创建父工程 tlias-parent，然后将创建的各个子模块，都放在父工程parent下面。 这样层级结构会更加清晰一些。\",\"PS：上面两种工程结构，都是可以正常使用的。 只不过第二种结构，父子工程结构更加清晰、更加直观。\"]},{\"header\":\"2.1.2 版本锁定\",\"slug\":\"_2-1-2-版本锁定\",\"contents\":[\"场景：\",\"要使用的同一个依赖的版本要一致，这样便于项目依赖的统一管理。比如：这个jwt依赖，使用的是 0.9.1\",\"项目要升级，需要将依赖的版本升级到0.9.2，该怎么做呢 ？\",\"第一步：去找当前项目中所有的模块的pom.xml配置文件，看哪些模块用到了jwt的依赖。\",\"第二步：找到这个依赖之后，将其版本version，更换为 0.9.2。\",\"问题：如果项目拆分的模块比较多，每一次更换版本，都得找到这个项目中的每一个模块，一个一个的更改。 很容易就会出现，遗漏掉一个模块，忘记更换版本的情况。\",\"如何来统一管理各个依赖的版本呢？\",\"答案：Maven的版本锁定功能。\",\"介绍：\",\"在maven中，可以在父工程的pom文件中通过 <dependencyManagement> 来统一管理依赖版本。\",\"父工程：\",\"<!--统一管理依赖版本--> <dependencyManagement> <dependencies> <!--JWT令牌--> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt</artifactId> <version>0.9.1</version> </dependency> </dependencies> </dependencyManagement> \",\"子工程：\",\"<dependencies> <!--JWT令牌--> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt</artifactId> </dependency> </dependencies> \",\"注意：\",\"在父工程中所配置的 <dependencyManagement> 只能统一管理依赖版本，并不会将这个依赖直接引入进来。 这点和 <dependencies> 是不同的。\",\"子工程要使用这个依赖，还是需要引入的，只是此时就无需指定 <version> 版本号了，父工程统一管理。变更依赖版本，只需在父工程中统一变更。\",\"实现：\",\"将tlias-utils模块中单独配置的依赖，将其版本统一交给 tlias-parent 进行统一管理。\",\"具体步骤如下：\",\"tlias-parent 中的配置\",\"<!--统一管理依赖版本--> <dependencyManagement> <dependencies> <!--JWT令牌--> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt</artifactId> <version>0.9.1</version> </dependency> <!--阿里云OSS--> <dependency> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-sdk-oss</artifactId> <version>3.15.1</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>activation</artifactId> <version>1.1.1</version> </dependency> <!-- no more than 2.3.3--> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>2.3.3</version> </dependency> </dependencies> </dependencyManagement> \",\"tlias-utils中的pom.xml配置\",\"如果依赖的版本已经在父工程进行了统一管理，在子工程中就无需再配置依赖的版本了。\",\"<dependencies> <!--JWT令牌--> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt</artifactId> </dependency> <!--阿里云OSS--> <dependency> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-sdk-oss</artifactId> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>activation</artifactId> </dependency> <!-- no more than 2.3.3--> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> </dependency> <!--WEB开发--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> \",\"之所以在springboot项目中很多时候，引入依赖坐标，都不需要指定依赖的版本 <version> ，是因为在父工程 spring-boot-starter-parent中已经通过 <dependencyManagement>对依赖的版本进行了统一的管理维护。\",\"属性配置：\",\"也可以通过自定义属性及属性引用的形式，在父工程中将依赖的版本号进行集中管理维护。 具体语法为：\",\"自定义属性\",\"<properties> <lombok.version>1.18.24</lombok.version> </properties> \",\"引用属性\",\"<dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>${lombok.version}</version> </dependency> \",\"在父工程中，将所有的版本号，都集中管理维护起来。\",\"<properties> <maven.compiler.source>11</maven.compiler.source> <maven.compiler.target>11</maven.compiler.target> <lombok.version>1.18.24</lombok.version> <jjwt.version>0.9.1</jjwt.version> <aliyun.oss.version>3.15.1</aliyun.oss.version> <jaxb.version>2.3.1</jaxb.version> <activation.version>1.1.1</activation.version> <jaxb.runtime.version>2.3.3</jaxb.runtime.version> </properties> <dependencies> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>${lombok.version}</version> </dependency> </dependencies> <!--统一管理依赖版本--> <dependencyManagement> <dependencies> <!--JWT令牌--> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt</artifactId> <version>${jjwt.version}</version> </dependency> <!--阿里云OSS--> <dependency> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-sdk-oss</artifactId> <version>${aliyun.oss.version}</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>${jaxb.version}</version> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>activation</artifactId> <version>${activation.version}</version> </dependency> <!-- no more than 2.3.3--> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>${jaxb.runtime.version}</version> </dependency> </dependencies> </dependencyManagement> \",\"版本集中管理之后，修改依赖的版本，就只需要在父工程中自定义属性的位置，修改对应的属性值即可。\",\"面试题：<dependencyManagement> 与 <dependencies> 的区别是什么?\",\"<dependencies> 是直接依赖，在父工程配置了依赖，子工程会直接继承下来。\",\"<dependencyManagement> 是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖(无需指定版本)\"]},{\"header\":\"2.2 聚合\",\"slug\":\"_2-2-聚合\",\"contents\":[\"分模块设计与开发之后项目被拆分为多个模块，而模块之间的关系，可能错综复杂\",\"通过maven的聚合可以轻松实现项目的一键构建（清理、编译、测试、打包、安装等）。\"]},{\"header\":\"2.2.1 介绍\",\"slug\":\"_2-2-1-介绍\",\"contents\":[\"聚合： 将多个模块组织成一个整体，同时进行项目的构建。\",\"聚合工程： 一个不具有业务功能的“空”工程（有且仅有一个pom文件） 【PS：一般来说，继承关系中的父工程与聚合关系中的聚合工程是同一个】\",\"作用： 快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）\"]},{\"header\":\"2.2.2 实现\",\"slug\":\"_2-2-2-实现\",\"contents\":[\"在maven中，聚合工程中通过 <moudules> 设置当前聚合工程所包含的子模块的名称。在 tlias-parent中，添加如下配置，来指定当前聚合工程，需要聚合的模块：\",\"<!--聚合其他模块--> <modules> <module>../tlias-pojo</module> <module>../tlias-utils</module> <module>../tlias-web-management</module> </modules> \",\"此时只需要在聚合工程上，统一进行操作就可以了。\",\"测试： 执行在聚合工程 tlias-parent 中执行 package 打包指令\",\"通过聚合实现项目的一键构建（一键清理clean、一键编译compile、一键测试test、一键打包package、一键安装install等）。\"]},{\"header\":\"2.3 继承与聚合对比\",\"slug\":\"_2-3-继承与聚合对比\",\"contents\":[\"作用\",\"聚合用于快速构建项目\",\"继承用于简化依赖配置、统一管理依赖\",\"相同点：\",\"聚合与继承的pom.xml文件打包方式均为pom，通常将两种关系制作到同一个pom文件中\",\"聚合与继承均属于设计型模块，并无实际的模块内容\",\"不同点：\",\"聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些\",\"继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己\"]},{\"header\":\"3. 私服\",\"slug\":\"_3-私服\",\"contents\":[]},{\"header\":\"3.1 场景\",\"slug\":\"_3-1-场景\",\"contents\":[\"同一个公司，两个项目组之间如何基于私服进行资源的共享。\",\"假设现在有两个团队，A 和 B。 A 开发了一个模块 tlias-utils，模块开发完毕之后，将模块打成jar包，并安装到了A的本地仓库。\",\"那此时，该公司的B团队开发项目时，要想使用 tlias-utils 中提供的工具类，该怎么办呢？\",\"当B团队在maven项目的pom.xml配置文件中引入了依赖的坐标之后，maven是如何查找这个依赖的？ 查找顺序为：\",\"本地仓库：本地仓库中是没有这个依赖jar包的。\",\"远程中央仓库：由于该模块时自己公司开发的，远程仓库中也没有这个依赖。\",\"因为目前tlias-utils这个依赖，还在A的本地仓库中的。 B电脑上的maven项目，是不可能找得到A电脑上maven本地仓库的jar包的。\",\"私服其实就是架设在公司局域网内部的一台服务器，就是一种特殊的远程仓库。\"]},{\"header\":\"3.2 介绍\",\"slug\":\"_3-2-介绍\",\"contents\":[\"私服： 是一种特殊的远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享与资源同步问题。\",\"依赖查找顺序：\",\"本地仓库\",\"私服仓库\",\"中央仓库\",\"注意事项： 私服在企业项目开发中，一个项目/公司，只需要一台即可（无需我们自己搭建，会使用即可）。\"]},{\"header\":\"3.3 资源上传与下载\",\"slug\":\"_3-3-资源上传与下载\",\"contents\":[]},{\"header\":\"3.3.1 步骤分析\",\"slug\":\"_3-3-1-步骤分析\",\"contents\":[\"资源上传与下载，需要做三步配置，执行一条指令。\",\"第一步配置：在maven的配置文件中配置访问私服的用户名、密码。\",\"第二步配置：在maven的配置文件中配置连接私服的地址(url地址)。\",\"第三步配置：在项目的pom.xml文件中配置上传资源的位置(url地址)。\",\"要上传资源到私服仓库，执行maven生命周期：deploy。\",\"私服仓库说明：\",\"RELEASE：存储自己开发的RELEASE发布版本的资源。\",\"SNAPSHOT：存储自己开发的SNAPSHOT发布版本的资源。\",\"Central：存储的是从中央仓库下载下来的依赖。 项目版本说明：\",\"RELEASE(发布版本)：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。\",\"SNAPSHOT(快照版本)：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。\"]},{\"header\":\"3.3.2 具体操作\",\"slug\":\"_3-3-2-具体操作\",\"contents\":[\"模拟企业开发，用一台服务器将私服搭建好，访问私服测试：[http://192.168.150.101:8081]\",\"1.设置私服的访问用户名/密码（在自己maven安装目录下的conf/settings.xml中的servers中配置）:\",\"<server> <id>maven-releases</id> <username>admin</username> <password>admin</password> </server> <server> <id>maven-snapshots</id> <username>admin</username> <password>admin</password> </server> \",\"2.设置私服依赖下载的仓库组地址（在自己maven安装目录下的conf/settings.xml中的mirrors、profiles中配置）:\",\"<mirror> <id>maven-public</id> <mirrorOf>*</mirrorOf> <url>http://192.168.150.101:8081/repository/maven-public/</url> </mirror> \",\"<profile> <id>allow-snapshots</id> <activation> <activeByDefault>true</activeByDefault> </activation> <repositories> <repository> <id>maven-public</id> <url>http://192.168.150.101:8081/repository/maven-public/</url> <releases> <enabled>true</enabled> </releases> <snapshots> <enabled>true</enabled> </snapshots> </repository> </repositories> </profile> \",\"3.IDEA的maven工程的pom文件中配置上传（发布）地址(直接在tlias-parent中配置发布地址):\",\"<distributionManagement> <!-- release版本的发布地址 --> <repository> <id>maven-releases</id> <url>http://192.168.150.101:8081/repository/maven-releases/</url> </repository> <!-- snapshot版本的发布地址 --> <snapshotRepository> <id>maven-snapshots</id> <url>http://192.168.150.101:8081/repository/maven-snapshots/</url> </snapshotRepository> </distributionManagement> \",\"配置完成之后，在tlias-parent中执行deploy生命周期，将项目发布到私服仓库中。\",\"jar包上传到了私服仓库中（由于当前的项目是SNAPSHOT版本，所以jar包是上传到了snapshot仓库中）。\",\"备注说明：\",\"演示的时候使用了一台服务器192.168.150.101，并在服务器上安装了maven的私服。 这台服务器并不能直接访问。\",\"如果要测试使用私服进行资源的上传和下载。可以参照如下步骤，启动给大家准备的本地私服操作：\",\"解压： 提供的压缩包 apache-maven-nexus.zip\",\"进入目录： apache-maven-nexus\\\\nexus-3.39.0-01\\\\bin\",\"启动服务：双击 start.bat\",\"访问服务：localhost:8081\",\"私服配置说明：将上述配置私服信息的 192.168.150.101 改为 localhost\"]}]},\"/BackEnd/MyBatis/\":{\"title\":\"MyBatis概述\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"MyBatis 是一款优秀的 持久层框架 ，用于简化 JDBC 开发\",\"相关信息\",\"MyBatis 本是 Apache 的一个开源项目 iBatis\",\"2010年 这个项目由 apache software foundation 迁移到了google code，并且改名为MyBatis 。\",\"2013年11月迁移到Github\"]},{\"header\":\"持久层\",\"slug\":\"持久层\",\"contents\":[\"持久层：指的是就是数据访问层(dao)，是用来操作数据库的。\"]},{\"header\":\"框架\",\"slug\":\"框架\",\"contents\":[\"半成品软件，是一套可重用的、通用的、软件基础代码模型\",\"在框架的基础之上构建软件编写更加高效、规范、通用、可扩展\"]}]},\"/BackEnd/MyBatis/mybatis01.html\":{\"title\":\"JDBC\",\"contents\":[{\"header\":\"1 JDBC概述\",\"slug\":\"_1-jdbc概述\",\"contents\":[\"Java DataBase Connectivity ： Java 数据库连接\",\"JDBC 就是使用Java语言操作关系型数据库的一套API\",\"本质\",\"官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口 各个数据库厂商去实现这套接口，提供数据库驱动jar包 使用的接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类\",\"好处\",\"各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发 可随时替换底层数据库，访问数据库的Java代码基本不变\"]},{\"header\":\"2 JDBC快速入门\",\"slug\":\"_2-jdbc快速入门\",\"contents\":[]},{\"header\":\"2.1 编写代码步骤\",\"slug\":\"_2-1-编写代码步骤\",\"contents\":[\"注册驱动\",\"Class.forName(\\\"com.mysql.jdbc.Driver\\\"); \",\"获取连接\",\"Connection conn = DriverManager.getConnection(url, username, password); \",\"Java代码需要发送SQL给MySQL服务端，就需要先建立连接:\",\"定义SQL语句\",\"String sql = “update…” ; \",\"执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象:\",\"获取执行SQL对象\",\"Statement stmt = conn.createStatement(); \",\"执行SQL\",\"stmt.executeUpdate(sql); \",\"处理返回结果 释放资源\"]},{\"header\":\"2.2 具体操作\",\"slug\":\"_2-2-具体操作\",\"contents\":[\"public class JDBCDemo { public static void main(String[] args) throws Exception { //1. 注册驱动 //Class.forName(\\\"com.mysql.jdbc.Driver\\\"); //2. 获取连接 String url = \\\"jdbc:mysql://127.0.0.1:3306/db1\\\"; String username = \\\"root\\\"; String password = \\\"123456\\\"; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = \\\"update account set money = 2000 where id = 1\\\"; //4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //5. 执行sql int count = stmt.executeUpdate(sql);//受影响的行数 //6. 处理结果 System.out.println(count); //7. 释放资源 stmt.close(); conn.close(); } } \"]},{\"header\":\"3 JDBC API详解\",\"slug\":\"_3-jdbc-api详解\",\"contents\":[]},{\"header\":\"3.1 DriverManager\",\"slug\":\"_3-1-drivermanager\",\"contents\":[\"DriverManager（驱动管理类）作用：\",\"注册驱动\",\"获取数据库连接\",\"参数说明：\",\"url ： 连接路径\",\"语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&参数键对2…\",\"示例：jdbc:mysql://127.0.0.1:3306/db1\",\"注\",\"配置 useSSL=false 参数，禁用安全连接方式，解决警告提示\"]},{\"header\":\"3.2 Connection\",\"slug\":\"_3-2-connection\",\"contents\":[\"Connection（数据库连接对象）作用：\",\"获取执行 SQL 的对象\",\"管理事务\"]},{\"header\":\"3.2.1 获取执行对象\",\"slug\":\"_3-2-1-获取执行对象\",\"contents\":[\"普通执行SQL对象\",\"Statement createStatement() \",\"预编译SQL的执行SQL对象：防止SQL注入\",\"PreparedStatement prepareStatement(sql) \",\"执行存储过程的对象（不常用）\",\"CallableStatement prepareCall(sql) \"]},{\"header\":\"3.2.2 事务管理\",\"slug\":\"_3-2-2-事务管理\",\"contents\":[\"MySQL事务管理的操作：\",\"开启事务 ： BEGIN; 或者 START TRANSACTION;\",\"提交事务 ： COMMIT;\",\"回滚事务 ： ROLLBACK;\",\"JDBC事务管理的方法：\",\"Connection接口中定义了3个对应的方法：\",\"开启事务\",\"参与autoCommit 表示是否自动提交事务，true表示自动提交事务，false表示手动提交事务。而开启事务需要将该参数设为false。\",\"提交事务\",\"回滚事务\",\"具体代码实现如下：\",\"public class JDBCDemo3_Connection { public static void main(String[] args) throws Exception { //1. 注册驱动 //Class.forName(\\\"com.mysql.jdbc.Driver\\\"); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = \\\"jdbc:mysql:///db1?useSSL=false\\\"; String username = \\\"root\\\"; String password = \\\"1234\\\"; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql1 = \\\"update account set money = 3000 where id = 1\\\"; String sql2 = \\\"update account set money = 3000 where id = 2\\\"; //4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); try { // ============开启事务========== conn.setAutoCommit(false); //5. 执行sql int count1 = stmt.executeUpdate(sql1);//受影响的行数 //6. 处理结果 System.out.println(count1); int i = 3/0; //5. 执行sql int count2 = stmt.executeUpdate(sql2);//受影响的行数 //6. 处理结果 System.out.println(count2); // ============提交事务========== //程序运行到此处，说明没有出现任何问题，则需求提交事务 conn.commit(); } catch (Exception e) { // ============回滚事务========== //程序在出现异常时会执行到这个地方，此时就需要回滚事务 conn.rollback(); e.printStackTrace(); } //7. 释放资源 stmt.close(); conn.close(); } } \"]},{\"header\":\"3.3 Statement\",\"slug\":\"_3-3-statement\",\"contents\":[\"Statement对象的作用就是用来执行SQL语句。而针对不同类型的SQL语句使用的方法也不一样。\",\"执行DDL、DML语句\",\"执行DQL语句\",\"代码实现:\",\"执行DML语句\",\"@Test public void testDML() throws Exception { //1. 注册驱动 //Class.forName(\\\"com.mysql.jdbc.Driver\\\"); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = \\\"jdbc:mysql:///db1?useSSL=false\\\"; String username = \\\"root\\\"; String password = \\\"123456\\\"; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = \\\"update account set money = 3000 where id = 1\\\"; //4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //5. 执行sql int count = stmt.executeUpdate(sql);//执行完DML语句，受影响的行数 //6. 处理结果 //System.out.println(count); if(count > 0){ System.out.println(\\\"修改成功~\\\"); }else{ System.out.println(\\\"修改失败~\\\"); } //7. 释放资源 stmt.close(); conn.close(); } \",\"执行DDL语句\",\"@Test public void testDDL() throws Exception { //1. 注册驱动 //Class.forName(\\\"com.mysql.jdbc.Driver\\\"); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = \\\"jdbc:mysql:///db1?useSSL=false\\\"; String username = \\\"root\\\"; String password = \\\"1234\\\"; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = \\\"drop database db2\\\"; //4. 获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //5. 执行sql int count = stmt.executeUpdate(sql);//执行完DDL语句，可能是0 //6. 处理结果 System.out.println(count); //7. 释放资源 stmt.close(); conn.close(); } \"]},{\"header\":\"3.4 ResultSet\",\"slug\":\"_3-4-resultset\",\"contents\":[\"ResultSet（结果集对象）的作用：封装SQL查询语句的结果\",\"执行了DQL语句后就会返回该对象\",\"ResultSet executeQuery(sql) --执行DQL 语句，返回 ResultSet 对象 \",\"下图为执行SQL语句后的结果\",\"boolean next()\",\"将光标从当前位置向前移动一行\",\"判断当前行是否为有效行\",\"一开始光标指定于第一行前，如图所示红色箭头指向于表头行。当我们调用了 next() 方法后，光标就下移到第一行数据，并且方法返回true，此时就可以通过 getInt(\\\"id\\\") 获取当前行id字段的值，也可以通过 getString(\\\"name\\\") 获取当前行name字段的值。如果想获取下一行的数据，继续调用 next() 方法，以此类推。\",\"代码实现:\",\"@Test public void testResultSet() throws Exception { //1. 注册驱动 //Class.forName(\\\"com.mysql.jdbc.Driver\\\"); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = \\\"jdbc:mysql:///db1?useSSL=false\\\"; String username = \\\"root\\\"; String password = \\\"1234\\\"; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = \\\"select * from account\\\"; //4. 获取statement对象 Statement stmt = conn.createStatement(); //5. 执行sql ResultSet rs = stmt.executeQuery(sql); //6. 处理结果， 遍历rs中的所有数据 // 6.1 光标向下移动一行，并且判断当前行是否有数据 while (rs.next()){ //6.2 获取数据 getXxx() int id = rs.getInt(\\\"id\\\"); String name = rs.getString(\\\"name\\\"); double money = rs.getDouble(\\\"money\\\"); System.out.println(id); System.out.println(name); System.out.println(money); System.out.println(\\\"--------------\\\"); } //7. 释放资源 rs.close(); stmt.close(); conn.close(); } \"]},{\"header\":\"3.5 案例\",\"slug\":\"_3-5-案例\",\"contents\":[\"需求：查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中\",\"代码实现\",\"/** * 查询account账户表数据，封装为Account对象中，并且存储到ArrayList集合中 * 1. 定义实体类Account * 2. 查询数据，封装到Account对象中 * 3. 将Account对象存入ArrayList集合中 */ @Test public void testResultSet2() throws Exception { //1. 注册驱动 //Class.forName(\\\"com.mysql.jdbc.Driver\\\"); //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = \\\"jdbc:mysql:///db1?useSSL=false\\\"; String username = \\\"root\\\"; String password = \\\"1234\\\"; Connection conn = DriverManager.getConnection(url, username, password); //3. 定义sql String sql = \\\"select * from account\\\"; //4. 获取statement对象 Statement stmt = conn.createStatement(); //5. 执行sql ResultSet rs = stmt.executeQuery(sql); // 创建集合 List<Account> list = new ArrayList<>(); // 6.1 光标向下移动一行，并且判断当前行是否有数据 while (rs.next()){ Account account = new Account(); //6.2 获取数据 getXxx() int id = rs.getInt(\\\"id\\\"); String name = rs.getString(\\\"name\\\"); double money = rs.getDouble(\\\"money\\\"); //赋值 account.setId(id); account.setName(name); account.setMoney(money); // 存入集合 list.add(account); } System.out.println(list); //7. 释放资源 rs.close(); stmt.close(); conn.close(); } \"]},{\"header\":\"3.6 PreparedStatement\",\"slug\":\"_3-6-preparedstatement\",\"contents\":[]},{\"header\":\"3.6.1 SQL注入\",\"slug\":\"_3-6-1-sql注入\",\"contents\":[\"SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。\"]},{\"header\":\"3.6.2 代码模拟SQL注入问题\",\"slug\":\"_3-6-2-代码模拟sql注入问题\",\"contents\":[\"@Test public void testLogin() throws Exception { //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = \\\"jdbc:mysql:///db1?useSSL=false\\\"; String username = \\\"root\\\"; String password = \\\"1234\\\"; Connection conn = DriverManager.getConnection(url, username, password); // 接收用户输入 用户名和密码 String name = \\\"sjdljfld\\\"; String pwd = \\\"' or '1' = '1\\\"; String sql = \\\"select * from tb_user where username = '\\\"+name+\\\"' and password = '\\\"+pwd+\\\"'\\\"; // 获取stmt对象 Statement stmt = conn.createStatement(); // 执行sql ResultSet rs = stmt.executeQuery(sql); // 判断登录是否成功 if(rs.next()){ System.out.println(\\\"登录成功~\\\"); }else{ System.out.println(\\\"登录失败~\\\"); } //7. 释放资源 rs.close(); stmt.close(); conn.close(); } \",\"拼接后的sql语句如下\",\"select * from tb_user where username = 'sjdljfld' and password = '' or '1' = '1' \"]},{\"header\":\"3.6.3 PreparedStatement概述\",\"slug\":\"_3-6-3-preparedstatement概述\",\"contents\":[\"预编译SQL语句并执行：预防SQL注入问题\",\"获取 PreparedStatement 对象\",\"// SQL语句中的参数值，使用？占位符替代 String sql = \\\"select * from user where username = ? and password = ?\\\"; // 通过Connection对象获取，并传入对应的sql语句 PreparedStatement pstmt = conn.prepareStatement(sql); \",\"设置参数值\",\"PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值\",\"Xxx：数据类型 ； 如 setInt (参数1，参数2)\",\"参数：\",\"参数1： ？的位置编号，从1 开始\",\"参数2： ？的值\",\"执行SQL语句\",\"executeUpdate(); 执行DDL语句和DML语句\",\"executeQuery(); 执行DQL语句\",\"注意: 调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。\"]},{\"header\":\"3.6.4 使用PreparedStatement改进\",\"slug\":\"_3-6-4-使用preparedstatement改进\",\"contents\":[\" @Test public void testPreparedStatement() throws Exception { //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写 String url = \\\"jdbc:mysql:///db1?useSSL=false\\\"; String username = \\\"root\\\"; String password = \\\"1234\\\"; Connection conn = DriverManager.getConnection(url, username, password); // 接收用户输入 用户名和密码 String name = \\\"zhangsan\\\"; String pwd = \\\"' or '1' = '1\\\"; // 定义sql String sql = \\\"select * from tb_user where username = ? and password = ?\\\"; // 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); // 设置？的值 pstmt.setString(1,name); pstmt.setString(2,pwd); // 执行sql ResultSet rs = pstmt.executeQuery(); // 判断登录是否成功 if(rs.next()){ System.out.println(\\\"登录成功~\\\"); }else{ System.out.println(\\\"登录失败~\\\"); } //7. 释放资源 rs.close(); pstmt.close(); conn.close(); } \",\"PreparedStatement又是如何解决的呢？它是将特殊字符进行了转义，转义的SQL如下：\",\"select * from tb_user where username = 'sjdljfld' and password = '\\\\'or \\\\'1\\\\' = \\\\'1' \"]},{\"header\":\"3.6.5 PreparedStatement原理\",\"slug\":\"_3-6-5-preparedstatement原理\",\"contents\":[\"预编译SQL，性能更高 防止SQL注入：将敏感字符进行转义\",\"检查SQL和编译SQL花费的时间比执行SQL的时间还要长。如果我们只是重新设置参数，那么检查SQL语句和编译SQL语句将不需要重复执行，这样就提高了性能。\"]},{\"header\":\"4 数据库连接池\",\"slug\":\"_4-数据库连接池\",\"contents\":[]},{\"header\":\"4.1 简介\",\"slug\":\"_4-1-简介\",\"contents\":[\"数据库连接池是个容器，负责分配、管理数据库连接(Connection)\",\"它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个\",\"释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏\",\"好处\",\"资源重用\",\"提升系统响应速度\",\"避免数据库连接遗漏\",\"连接池是在一开始就创建好了一些连接（Connection）对象存储起来。用户需要连接数据库时，不需要自己创建连接，而只需要从连接池中获取一个连接进行使用，使用完毕后再将连接对象归还给连接池\"]},{\"header\":\"4.2 数据库连接池实现\",\"slug\":\"_4-2-数据库连接池实现\",\"contents\":[\"标准接口：DataSource\",\"Connection getConnection() \",\"以后就不需要通过 DriverManager 对象获取 Connection 对象，而是通过连接池（DataSource）获取 Connection 对象。\",\"常见的数据库连接池\",\"DBCP C3P0 Druid\",\"Druid（德鲁伊）\",\"Druid连接池是阿里巴巴开源的数据库连接池项目\",\"功能强大，性能优秀，是Java语言最好的数据库连接池之一\"]},{\"header\":\"4.3 Driud使用\",\"slug\":\"_4-3-driud使用\",\"contents\":[\"项目结构如下：\",\"编写配置文件如下：\",\"driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql:///db1?useSSL=false&useServerPrepStmts=true username=root password=1234 # 初始化连接数量 initialSize=5 # 最大连接数 maxActive=10 # 最大等待时间 maxWait=3000 \",\"使用druid的代码如下：\",\"/** * Druid数据库连接池演示 */ public class DruidDemo { public static void main(String[] args) throws Exception { //1. 导入jar包 //2. 定义配置文件 //3. 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(\\\"jdbc-demo/src/druid.properties\\\")); //4. 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //5. 获取数据库连接 Connection Connection connection = dataSource.getConnection(); System.out.println(connection); //获取到了连接后就可以继续做其他操作了 } } \"]},{\"header\":\"5 JDBC练习\",\"slug\":\"_5-jdbc练习\",\"contents\":[]},{\"header\":\"5.1 需求\",\"slug\":\"_5-1-需求\",\"contents\":[\"完成商品品牌数据的增删改查操作\",\"查询：查询所有数据\",\"添加：添加品牌\",\"修改：根据id修改\",\"删除：根据id删除\"]},{\"header\":\"5.2 案例实现\",\"slug\":\"_5-2-案例实现\",\"contents\":[\"环境准备：\",\"数据库表 tb_brand\",\"-- 删除tb_brand表 drop table if exists tb_brand; -- 创建tb_brand表 create table tb_brand ( -- id 主键 id int primary key auto_increment, -- 品牌名称 brand_name varchar(20), -- 企业名称 company_name varchar(20), -- 排序字段 ordered int, -- 描述信息 description varchar(100), -- 状态：0：禁用 1：启用 status int ); -- 添加数据 insert into tb_brand (brand_name, company_name, ordered, description, status) values ('三只松鼠', '三只松鼠股份有限公司', 5, '好吃不上火', 0), ('华为', '华为技术有限公司', 100, '华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界', 1), ('小米', '小米科技有限公司', 50, 'are you ok', 1); \",\"在pojo包下实体类 Brand\",\"/** * 品牌 * alt + 鼠标左键：整列编辑 * 在实体类中，基本数据类型建议使用其对应的包装类型 */ public class Brand { // id 主键 private Integer id; // 品牌名称 private String brandName; // 企业名称 private String companyName; // 排序字段 private Integer ordered; // 描述信息 private String description; // 状态：0：禁用 1：启用 private Integer status; //get set方法 //toString方法 } \",\"查询所有：\",\" /** * 查询所有 * 1. SQL：select * from tb_brand; * 2. 参数：不需要 * 3. 结果：List<Brand> */ @Test public void testSelectAll() throws Exception { //1. 获取Connection //3. 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(\\\"jdbc-demo/src/druid.properties\\\")); //4. 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //5. 获取数据库连接 Connection Connection conn = dataSource.getConnection(); //2. 定义SQL String sql = \\\"select * from tb_brand;\\\"; //3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); //4. 设置参数 //5. 执行SQL ResultSet rs = pstmt.executeQuery(); //6. 处理结果 List<Brand> 封装Brand对象，装载List集合 Brand brand = null; List<Brand> brands = new ArrayList<>(); while (rs.next()){ //获取数据 int id = rs.getInt(\\\"id\\\"); String brandName = rs.getString(\\\"brand_name\\\"); String companyName = rs.getString(\\\"company_name\\\"); int ordered = rs.getInt(\\\"ordered\\\"); String description = rs.getString(\\\"description\\\"); int status = rs.getInt(\\\"status\\\"); //封装Brand对象 brand = new Brand(); brand.setId(id); brand.setBrandName(brandName); brand.setCompanyName(companyName); brand.setOrdered(ordered); brand.setDescription(description); brand.setStatus(status); //装载集合 brands.add(brand); } System.out.println(brands); //7. 释放资源 rs.close(); pstmt.close(); conn.close(); } \",\"添加数据：\",\"/** * 添加 * 1. SQL：insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?); * 2. 参数：需要，除了id之外的所有参数信息 * 3. 结果：boolean */ @Test public void testAdd() throws Exception { // 接收页面提交的参数 String brandName = \\\"香飘飘\\\"; String companyName = \\\"香飘飘\\\"; int ordered = 1; String description = \\\"绕地球一圈\\\"; int status = 1; //1. 获取Connection //3. 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(\\\"jdbc-demo/src/druid.properties\\\")); //4. 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //5. 获取数据库连接 Connection Connection conn = dataSource.getConnection(); //2. 定义SQL String sql = \\\"insert into tb_brand(brand_name, company_name, ordered, description, status) values(?,?,?,?,?);\\\"; //3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); //4. 设置参数 pstmt.setString(1,brandName); pstmt.setString(2,companyName); pstmt.setInt(3,ordered); pstmt.setString(4,description); pstmt.setInt(5,status); //5. 执行SQL int count = pstmt.executeUpdate(); // 影响的行数 //6. 处理结果 System.out.println(count > 0); //7. 释放资源 pstmt.close(); conn.close(); } \",\"修改数据：\",\"/** * 修改 * 1. SQL： update tb_brand set brand_name = ?, company_name= ?, ordered = ?, description = ?, status = ? where id = ? * 2. 参数：需要，所有数据 * 3. 结果：boolean */ @Test public void testUpdate() throws Exception { // 接收页面提交的参数 String brandName = \\\"香飘飘\\\"; String companyName = \\\"香飘飘\\\"; int ordered = 1000; String description = \\\"绕地球三圈\\\"; int status = 1; int id = 4; //1. 获取Connection //3. 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(\\\"jdbc-demo/src/druid.properties\\\")); //4. 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //5. 获取数据库连接 Connection Connection conn = dataSource.getConnection(); //2. 定义SQL String sql = \\\" update tb_brand\\\\n\\\" + \\\" set brand_name = ?,\\\\n\\\" + \\\" company_name= ?,\\\\n\\\" + \\\" ordered = ?,\\\\n\\\" + \\\" description = ?,\\\\n\\\" + \\\" status = ?\\\\n\\\" + \\\" where id = ?\\\"; //3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); //4. 设置参数 pstmt.setString(1,brandName); pstmt.setString(2,companyName); pstmt.setInt(3,ordered); pstmt.setString(4,description); pstmt.setInt(5,status); pstmt.setInt(6,id); //5. 执行SQL int count = pstmt.executeUpdate(); // 影响的行数 //6. 处理结果 System.out.println(count > 0); //7. 释放资源 pstmt.close(); conn.close(); } \",\"删除数据：\",\"/** * 删除 * 1. SQL： delete from tb_brand where id = ? * 2. 参数：需要，id * 3. 结果：boolean */ @Test public void testDeleteById() throws Exception { // 接收页面提交的参数 int id = 4; //1. 获取Connection //3. 加载配置文件 Properties prop = new Properties(); prop.load(new FileInputStream(\\\"jdbc-demo/src/druid.properties\\\")); //4. 获取连接池对象 DataSource dataSource = DruidDataSourceFactory.createDataSource(prop); //5. 获取数据库连接 Connection Connection conn = dataSource.getConnection(); //2. 定义SQL String sql = \\\" delete from tb_brand where id = ?\\\"; //3. 获取pstmt对象 PreparedStatement pstmt = conn.prepareStatement(sql); //4. 设置参数 pstmt.setInt(1,id); //5. 执行SQL int count = pstmt.executeUpdate(); // 影响的行数 //6. 处理结果 System.out.println(count > 0); //7. 释放资源 pstmt.close(); conn.close(); } \"]}]},\"/BackEnd/MyBatis/mybatis02.html\":{\"title\":\"JDBC vs Mybatis\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"JDBC 缺点\",\"硬编码\",\"注册驱动、获取连接 ①\",\"SQL语句 ②\",\"操作繁琐\",\"手动设置参数 ③\",\"手动封装结果集 ④\",\"Mybatis 优化\",\"硬编码可以配置到 配置文件\",\"操作繁琐的地方mybatis都 自动完成\"]}]},\"/BackEnd/MyBatis/mybatis03.html\":{\"title\":\"lombok\",\"contents\":[{\"header\":\"1 介绍\",\"slug\":\"_1-介绍\",\"contents\":[\"Lombok是一个实用的Java类库，可以通过简单的注解来简化和消除一些必须但又显得很臃肿的Java代码。\",\"注解\",\"作用\",\"@Getter/@Setter\",\"为所有的属性提供get/set方法\",\"@ToString\",\"会给类自动生成易阅读的 toString 方法\",\"@EqualsAndHashCode\",\"根据类所拥有的非静态字段自动重写 equals 方法和 hashCode 方法\",\"@Data\",\"提供了更综合的生成代码功能（@Getter + @Setter + @ToString + @EqualsAndHashCode）\",\"@NoArgsConstructor\",\"为实体类生成无参的构造器方法\",\"@AllArgsConstructor\",\"为实体类生成除了static修饰的字段之外带有各参数的构造器方法。\"]},{\"header\":\"2 使用\",\"slug\":\"_2-使用\",\"contents\":[\"第1步：在pom.xml文件中引入依赖\",\"<!-- 在springboot的父工程中，已经集成了lombok并指定了版本号--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> \",\"第2步：在实体类上添加注解\",\"import lombok.Data; @Data public class User { private Integer id; private String name; private Short age; private Short gender; private String phone; } \"]},{\"header\":\"3 说明\",\"slug\":\"_3-说明\",\"contents\":[\"@Data注解中不包含全参构造方法，通常在实体类上，还会添加上：全参构造、无参构造\",\"import lombok.Data; @Data //getter方法、setter方法、toString方法、hashCode方法、equals方法 @NoArgsConstructor //无参构造 @AllArgsConstructor//全参构造 public class User { private Integer id; private String name; private Short age; private Short gender; private String phone; } \"]},{\"header\":\"4 注意事项\",\"slug\":\"_4-注意事项\",\"contents\":[\"Lombok的注意事项：\",\"Lombok会在编译时，会自动生成对应的java代码\",\"在使用lombok时，还需要安装一个lombok的插件（新版本的IDEA中自带）\",\"在实体类上添加了@Data注解，那么这个类在编译时期，就会生成 getter/setter、equals、hashcode、toString 等方法。\"]}]},\"/BackEnd/MyBatis/mybatis04.html\":{\"title\":\"Mybatis快速入门\",\"contents\":[{\"header\":\"1. 入门程序分析\",\"slug\":\"_1-入门程序分析\",\"contents\":[\"Mybatis操作数据库步骤：\",\"准备工作 ( 创建springboot工程、数据库表user、实体类User )\",\"引入Mybatis的相关依赖，配置Mybatis ( 数据库连接信息 )\",\"编写SQL语句 ( 注解/XML )\"]},{\"header\":\"2 入门程序实现\",\"slug\":\"_2-入门程序实现\",\"contents\":[]},{\"header\":\"2.1 项目创建\",\"slug\":\"_2-1-项目创建\",\"contents\":[\"创建springboot工程，并导入 mybatis 的起步依赖、 mysql 的驱动包。\",\"<dependencies> <!-- mybatis起步依赖 --> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>2.3.0</version> </dependency> <!-- mysql驱动包依赖 --> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <scope>runtime</scope> </dependency> <!-- spring单元测试 (集成了junit) --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> \"]},{\"header\":\"2.2 数据准备\",\"slug\":\"_2-2-数据准备\",\"contents\":[\"创建用户表user，并创建对应的实体类User。\",\"用户表：\",\"-- 用户表 create table user( id int unsigned primary key auto_increment comment 'ID', name varchar(100) comment '姓名', age tinyint unsigned comment '年龄', gender tinyint unsigned comment '性别, 1:男, 2:女', phone varchar(11) comment '手机号' ) comment '用户表'; -- 测试数据 insert into user(id, name, age, gender, phone) VALUES (null,'白眉鹰王',55,'1','18800000000'); insert into user(id, name, age, gender, phone) VALUES (null,'金毛狮王',45,'1','18800000001'); insert into user(id, name, age, gender, phone) VALUES (null,'青翼蝠王',38,'1','18800000002'); insert into user(id, name, age, gender, phone) VALUES (null,'紫衫龙王',42,'2','18800000003'); insert into user(id, name, age, gender, phone) VALUES (null,'光明左使',37,'1','18800000004'); insert into user(id, name, age, gender, phone) VALUES (null,'光明右使',48,'1','18800000005'); \",\"实体类\",\"实体类的属性名与表中的字段名一一对应。\",\"public class User { private Integer id; //id（主键） private String name; //姓名 private Short age; //年龄 private Short gender; //性别 private String phone; //手机号 //省略GET, SET方法 } \"]},{\"header\":\"2.3 配置Mybatis\",\"slug\":\"_2-3-配置mybatis\",\"contents\":[\"连接MySQL数据库时，需要配置：\",\"连接数据库的四大参数\",\"MySQL驱动类 登录名 密码 数据库连接字符串\",\"基于上述分析，在Mybatis中要连接数据库，同样也需要以上4个参数配置。\",\"application.properties:\",\"#驱动类名称 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #数据库连接的url spring.datasource.url=jdbc:mysql://localhost:3306/mybatis #连接数据库的用户名 spring.datasource.username=root #连接数据库的密码 spring.datasource.password=1234 \"]},{\"header\":\"2.4 编写SQL语句\",\"slug\":\"_2-4-编写sql语句\",\"contents\":[\"在springboot工程中，引导类所在包下，再创建一个包mapper。在mapper包下创建一个接口UserMapper，这是一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper）。\",\"UserMapper：\",\"import com.itheima.pojo.User; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Select; import java.util.List; @Mapper public interface UserMapper { //查询所有用户数据 @Select(\\\"select id, name, age, gender, phone from user\\\") public List<User> list(); } \",\"@Mapper注解：表示是mybatis中的Mapper接口\",\"程序运行时：框架会自动生成接口的实现类对象(代理对象)，并给交Spring的IOC容器管理\",\"@Select注解：代表的就是select查询，用于书写select查询语句\"]},{\"header\":\"2.5 单元测试\",\"slug\":\"_2-5-单元测试\",\"contents\":[\"在SpringBoot工程中，在src下的test目录下，已经自动帮我们创建好了测试类 ，并且在测试类上已经添加了注解 @SpringBootTest，代表该测试类已经与SpringBoot整合。\",\"该测试类在运行时，会自动通过引导类加载Spring的环境（IOC容器）。 要测试哪个bean对象，直接通过 @Autowired 注解直接将其注入就行，然后就可以测试了。\",\"测试类代码如下\",\"@SpringBootTest public class MybatisQuickstartApplicationTests { @Autowired private UserMapper userMapper; @Test public void testList(){ List<User> userList = userMapper.list(); for (User user : userList) { System.out.println(user); } } } \",\"运行结果：\",\"User{id=1, name='白眉鹰王', age=55, gender=1, phone='18800000000'} User{id=2, name='金毛狮王', age=45, gender=1, phone='18800000001'} User{id=3, name='青翼蝠王', age=38, gender=1, phone='18800000002'} User{id=4, name='紫衫龙王', age=42, gender=2, phone='18800000003'} User{id=5, name='光明左使', age=37, gender=1, phone='18800000004'} User{id=6, name='光明右使', age=48, gender=1, phone='18800000005'} \"]},{\"header\":\"3 解决SQL警告与提示\",\"slug\":\"_3-解决sql警告与提示\",\"contents\":[\"默认在UserMapper接口上加的 @Select 注解中编写SQL语句是没有提示的。 如果想让idea提示对应的SQL语句，需要在IDEA中配置与MySQL数据库的链接。\",\"配置完成之后，发现SQL语句中的关键字有提示了，但还存在不识别表名(列名)的情况\"]}]},\"/BackEnd/MyBatis/mybatis05.html\":{\"title\":\"Mybatis基础操作\",\"contents\":[{\"header\":\"1 需求\",\"slug\":\"_1-需求\",\"contents\":[\"需求说明：\",\"根据资料中提供的《tlias智能学习辅助系统》页面原型及需求，完成员工管理的需求开发。\",\"通过分析以上的页面原型和需求，确定功能列表：\",\"查询\",\"根据主键ID查询\",\"条件查询\",\"新增\",\"更新\",\"删除\",\"根据主键ID删除\",\"根据主键ID批量删除\"]},{\"header\":\"2 准备\",\"slug\":\"_2-准备\",\"contents\":[\"实施前的准备工作：\",\"准备数据库表\",\"创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）\",\"application.properties中引入数据库连接信息\",\"创建对应的实体类 Emp（实体类属性采用驼峰命名）\",\"准备Mapper接口 EmpMapper\"]},{\"header\":\"2.1 准备数据库表\",\"slug\":\"_2-1-准备数据库表\",\"contents\":[\"-- 部门管理 create table dept ( id int unsigned primary key auto_increment comment '主键ID', name varchar(10) not null unique comment '部门名称', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间' ) comment '部门表'; -- 部门表测试数据 insert into dept (id, name, create_time, update_time) values (1, '学工部', now(), now()), (2, '教研部', now(), now()), (3, '咨询部', now(), now()), (4, '就业部', now(), now()), (5, '人事部', now(), now()); -- 员工管理 create table emp ( id int unsigned primary key auto_increment comment 'ID', username varchar(20) not null unique comment '用户名', password varchar(32) default '123456' comment '密码', name varchar(10) not null comment '姓名', gender tinyint unsigned not null comment '性别, 说明: 1 男, 2 女', image varchar(300) comment '图像', job tinyint unsigned comment '职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师', entrydate date comment '入职时间', dept_id int unsigned comment '部门ID', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间' ) comment '员工表'; -- 员工表测试数据 INSERT INTO emp (id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time) VALUES (1, 'jinyong', '123456', '金庸', 1, '1.jpg', 4, '2000-01-01', 2, now(), now()), (2, 'zhangwuji', '123456', '张无忌', 1, '2.jpg', 2, '2015-01-01', 2, now(), now()), (3, 'yangxiao', '123456', '杨逍', 1, '3.jpg', 2, '2008-05-01', 2, now(), now()), (4, 'weiyixiao', '123456', '韦一笑', 1, '4.jpg', 2, '2007-01-01', 2, now(), now()), (5, 'changyuchun', '123456', '常遇春', 1, '5.jpg', 2, '2012-12-05', 2, now(), now()), (6, 'xiaozhao', '123456', '小昭', 2, '6.jpg', 3, '2013-09-05', 1, now(), now()), (7, 'jixiaofu', '123456', '纪晓芙', 2, '7.jpg', 1, '2005-08-01', 1, now(), now()), (8, 'zhouzhiruo', '123456', '周芷若', 2, '8.jpg', 1, '2014-11-09', 1, now(), now()), (9, 'dingminjun', '123456', '丁敏君', 2, '9.jpg', 1, '2011-03-11', 1, now(), now()), (10, 'zhaomin', '123456', '赵敏', 2, '10.jpg', 1, '2013-09-05', 1, now(), now()), (11, 'luzhangke', '123456', '鹿杖客', 1, '11.jpg', 5, '2007-02-01', 3, now(), now()), (12, 'hebiweng', '123456', '鹤笔翁', 1, '12.jpg', 5, '2008-08-18', 3, now(), now()), (13, 'fangdongbai', '123456', '方东白', 1, '13.jpg', 5, '2012-11-01', 3, now(), now()), (14, 'zhangsanfeng', '123456', '张三丰', 1, '14.jpg', 2, '2002-08-01', 2, now(), now()), (15, 'yulianzhou', '123456', '俞莲舟', 1, '15.jpg', 2, '2011-05-01', 2, now(), now()), (16, 'songyuanqiao', '123456', '宋远桥', 1, '16.jpg', 2, '2010-01-01', 2, now(), now()), (17, 'chenyouliang', '123456', '陈友谅', 1, '17.jpg', NULL, '2015-03-21', NULL, now(), now()); \"]},{\"header\":\"2.2 创建工程\",\"slug\":\"_2-2-创建工程\",\"contents\":[\"创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）：\"]},{\"header\":\"2.3 application.properties\",\"slug\":\"_2-3-application-properties\",\"contents\":[\"application.properties中引入数据库连接信息：\",\"#驱动类名称 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #数据库连接的url spring.datasource.url=jdbc:mysql://localhost:3306/mybatis #连接数据库的用户名 spring.datasource.username=root #连接数据库的密码 spring.datasource.password=1234 \"]},{\"header\":\"2.4 实体类Emp\",\"slug\":\"_2-4-实体类emp\",\"contents\":[\"创建对应的实体类Emp（实体类属性采用驼峰命名）：\",\"@Data @NoArgsConstructor @AllArgsConstructor public class Emp { private Integer id; private String username; private String password; private String name; private Short gender; private String image; private Short job; //LocalDate类型对应数据表中的date类型 private LocalDate entrydate; private Integer deptId; //LocalDateTime类型对应数据表中的datetime类型 private LocalDateTime createTime; private LocalDateTime updateTime; } \"]},{\"header\":\"2.5 准备Mapper接口\",\"slug\":\"_2-5-准备mapper接口\",\"contents\":[\"准备Mapper接口：EmpMapper：\",\"/* @Mapper注解：表示当前接口为mybatis中的Mapper接口 程序运行时会自动创建接口的实现类对象(代理对象)，并交给Spring的IOC容器管理 */ @Mapper public interface EmpMapper { } \",\"完成以上操作后，项目工程结构目录如下：\"]},{\"header\":\"3 删除\",\"slug\":\"_3-删除\",\"contents\":[]},{\"header\":\"3.1 功能实现\",\"slug\":\"_3-1-功能实现\",\"contents\":[\"页面原型：\",\"当我们点击后面的\\\"删除\\\"按钮时，前端页面会给服务端传递一个参数，也就是该行数据的ID。 我们接收到ID后，根据ID删除数据即可。\",\"功能：根据主键删除数据\",\"-- 删除id=17的数据 delete from emp where id = 17; \",\"接口方法\",\"@Mapper public interface EmpMapper { /** * 根据id删除数据 * @param id 用户id */ //使用#{key}方式获取方法中的参数值 @Delete(\\\"delete from emp where id = #{id}\\\") public void delete(Integer id); } \",\"测试\",\"在单元测试类中通过@Autowired注解注入EmpMapper类型对象\",\"@SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired //从Spring的IOC容器中，获取类型是EmpMapper的对象并注入 private EmpMapper empMapper; @Test public void testDel(){ //调用删除方法 empMapper.delete(16); } } \"]},{\"header\":\"3.2 日志输入\",\"slug\":\"_3-2-日志输入\",\"contents\":[\"在Mybatis当中可以借助日志，查看到sql语句的执行、执行传递的参数以及执行结果。\",\"具体操作如下：\",\"打开application.properties文件\",\"开启mybatis的日志，并指定输出到控制台\",\"#指定mybatis输出日志的位置, 输出控制台 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl \",\"再次运行单元测试，输出了以下的SQL语句信息：\",\"但是输出的SQL语句：delete from emp where id = ?，输入的参数16并没有在后面拼接，id的值是使用?进行占位。这种SQL语句我们称为预编译SQL。\"]},{\"header\":\"3.3 预编译SQL\",\"slug\":\"_3-3-预编译sql\",\"contents\":[\"预编译SQL的两个优势\",\"性能更高：预编译SQL，编译一次之后会将编译后的SQL语句缓存起来，后面再次执行这条语句时，不会再次编译。（只是输入的参数不同）\",\"更安全(防止SQL注入)：将敏感字进行转义，保障SQL的安全性。\"]},{\"header\":\"3.4 参数占位符\",\"slug\":\"_3-4-参数占位符\",\"contents\":[\"在Mybatis中提供的参数占位符有两种：#{…}、${...}\",\"提示\",\"执行SQL时，会将#{…}替换为 ? ，生成预编译SQL，会自动设置参数值\",\"使用时机：参数传递，都使用 #{…}\",\"注意\",\"拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题\",\"使用时机：如果对表名、列表进行动态设置时使用\"]},{\"header\":\"4 新增\",\"slug\":\"_4-新增\",\"contents\":[\"功能：新增员工信息\"]},{\"header\":\"4.1 基本新增\",\"slug\":\"_4-1-基本新增\",\"contents\":[\"员工表结构：\",\"SQL语句：\",\"insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values ('songyuanqiao','宋远桥',1,'1.jpg',2,'2012-10-09',2,'2022-10-01 10:00:00','2022-10-01 10:00:00'); \",\"接口方法：\",\"@Mapper public interface EmpMapper { @Insert(\\\"insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})\\\") public void insert(Emp emp); } \",\"测试类：\",\"import com.itheima.mapper.EmpMapper; import com.itheima.pojo.Emp; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.time.LocalDate; import java.time.LocalDateTime; @SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ //创建员工对象 Emp emp = new Emp(); emp.setUsername(\\\"tom\\\"); emp.setName(\\\"汤姆\\\"); emp.setImage(\\\"1.jpg\\\"); emp.setGender((short)1); emp.setJob((short)1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(1); //调用添加方法 empMapper.insert(emp); } } \"]},{\"header\":\"4.2 主键返回\",\"slug\":\"_4-2-主键返回\",\"contents\":[\"概念：在数据添加成功后，需要获取插入数据库数据的主键。\",\"如：添加套餐数据时，还需要维护套餐菜品关系表数据。\",\"业务场景：苍穹外卖菜品与套餐模块的表结构，菜品与套餐是多对多的关系，一个套餐对应多个菜品。既然是多对多的关系，是不是有一张套餐菜品中间表来维护它们之间的关系。\",\"在添加套餐的时候，我们需要在界面当中来录入套餐的基本信息，还需要来录入套餐与菜品的关联信息。这些信息录入完毕之后，我们一点保存，就需要将套餐的信息以及套餐与菜品的关联信息都需要保存到数据库当中。 其实具体的过程包括两步，首先第一步先需要将套餐的基本信息保存了，接下来第二步再来保存套餐与菜品的关联信息。套餐与菜品的关联信息就是往中间表当中来插入数据，来维护它们之间的关系。而中间表当中有两个外键字段，一个是菜品的ID，就是当前菜品的ID，还有一个就是套餐的ID，而这个套餐的 ID 指的就是此次我所添加的套餐的ID，所以我们在第一步保存完套餐的基本信息之后，就需要将套餐的主键值返回来供第二步进行使用。这个时候就需要用到主键返回功能。\",\"那要如何实现在插入数据之后返回所插入行的主键值呢？\",\"默认情况下，执行插入操作时，是不会主键值返回的。如果想要拿到主键值，需要在Mapper接口中的方法上添加一个Options注解，并在注解中指定属性useGeneratedKeys=true和keyProperty=\\\"实体类属性名\\\"\",\"主键返回代码实现：\",\"@Mapper public interface EmpMapper { //会自动将生成的主键值，赋值给emp对象的id属性 @Options(useGeneratedKeys = true,keyProperty = \\\"id\\\") @Insert(\\\"insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime})\\\") public void insert(Emp emp); } \",\"测试：\",\"@SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ //创建员工对象 Emp emp = new Emp(); emp.setUsername(\\\"jack\\\"); emp.setName(\\\"杰克\\\"); emp.setImage(\\\"1.jpg\\\"); emp.setGender((short)1); emp.setJob((short)1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(1); //调用添加方法 empMapper.insert(emp); System.out.println(emp.getDeptId()); } } \"]},{\"header\":\"5 更新\",\"slug\":\"_5-更新\",\"contents\":[\"功能：修改员工信息\",\"SQL语句：\",\"update emp set username = 'linghushaoxia', name = '令狐少侠', gender = 1 , image = '1.jpg' , job = 2, entrydate = '2012-01-01', dept_id = 2, update_time = '2022-10-01 12:12:12' where id = 18; \",\"接口方法：\",\"@Mapper public interface EmpMapper { /** * 根据id修改员工信息 * @param emp */ @Update(\\\"update emp set username=#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entrydate}, dept_id=#{deptId}, update_time=#{updateTime} where id=#{id}\\\") public void update(Emp emp); } \",\"测试类：\",\"@SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testUpdate(){ //要修改的员工信息 Emp emp = new Emp(); emp.setId(23); emp.setUsername(\\\"songdaxia\\\"); emp.setPassword(null); emp.setName(\\\"老宋\\\"); emp.setImage(\\\"2.jpg\\\"); emp.setGender((short)1); emp.setJob((short)2); emp.setEntrydate(LocalDate.of(2012,1,1)); emp.setCreateTime(null); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(2); //调用方法，修改员工数据 empMapper.update(emp); } } \"]},{\"header\":\"6 查询\",\"slug\":\"_6-查询\",\"contents\":[]},{\"header\":\"6.1 根据ID查询\",\"slug\":\"_6-1-根据id查询\",\"contents\":[\"在员工管理的页面中，当我们进行更新数据时，会点击 “编辑” 按钮，然后此时会发送一个请求到服务端，会根据Id查询该员工信息，并将员工数据回显在页面上。\",\"SQL语句：\",\"select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp; \",\"接口方法：\",\"@Mapper public interface EmpMapper { @Select(\\\"select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#{id}\\\") public Emp getById(Integer id); } \",\"测试类：\",\"@SpringBootTest class SpringbootMybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testGetById(){ Emp emp = empMapper.getById(1); System.out.println(emp); } } \"]},{\"header\":\"6.2 数据封装\",\"slug\":\"_6-2-数据封装\",\"contents\":[\"查询返回的结果中大部分字段是有值的，但是deptId，createTime，updateTime这几个字段是没有值的\",\"原因如下：\",\"实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。\",\"如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。\",\"解决方案\",\"起别名\",\"结果映射\",\"开启驼峰命名\",\"起别名：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样\",\"@Select(\\\"select id, username, password, name, gender, image, job, entrydate, \\\" + \\\"dept_id AS deptId, create_time AS createTime, update_time AS updateTime \\\" + \\\"from emp \\\" + \\\"where id=#{id}\\\") public Emp getById(Integer id); \",\"手动结果映射：通过 @Results及@Result 进行手动结果映射\",\"@Results({@Result(column = \\\"dept_id\\\", property = \\\"deptId\\\"), @Result(column = \\\"create_time\\\", property = \\\"createTime\\\"), @Result(column = \\\"update_time\\\", property = \\\"updateTime\\\")}) @Select(\\\"select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#{id}\\\") public Emp getById(Integer id); \",\"开启驼峰命名(推荐)：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射\",\"驼峰命名规则： abc_xyz => abcXyz\",\"表中字段名：abc_xyz\",\"类中属性名：abcXyz\",\"# 在application.properties中添加： mybatis.configuration.map-underscore-to-camel-case=true \",\"注意\",\"要使用驼峰命名前提是 实体类的属性 与 数据库表 中的字段名严格遵守驼峰命名。\"]},{\"header\":\"6.3 条件查询\",\"slug\":\"_6-3-条件查询\",\"contents\":[\"在员工管理的列表页面中，我们需要根据条件查询员工信息，查询条件包括：姓名、性别、入职时间。\",\"通过页面原型以及需求描述我们要实现的查询：\",\"姓名：要求支持模糊匹配\",\"性别：要求精确匹配\",\"入职时间：要求进行范围查询\",\"根据最后修改时间进行降序排序\",\"SQL语句：\",\"select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where name like '%张%' and gender = 1 and entrydate between '2010-01-01' and '2020-01-01 ' order by update_time desc; \",\"接口方法：\",\"使用MySQL提供的字符串拼接函数：concat('%' , '关键字' , '%'),解决SQL注入风险\",\"@Mapper public interface EmpMapper { @Select(\\\"select * from emp \\\" + \\\"where name like concat('%',#{name},'%') \\\" + \\\"and gender = #{gender} \\\" + \\\"and entrydate between #{begin} and #{end} \\\" + \\\"order by update_time desc\\\") public List<Emp> list(String name, Short gender, LocalDate begin, LocalDate end); } \"]}]},\"/BackEnd/MyBatis/mybatis06.html\":{\"title\":\"Mybatis的XML配置文件\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Mybatis的开发有两种方式\",\"注解\",\"XML\"]},{\"header\":\"1 XML配置文件规范\",\"slug\":\"_1-xml配置文件规范\",\"contents\":[\"使用Mybatis的注解方式，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句\",\"Mybatis中使用XML映射文件规范\",\"XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）\",\"XML映射文件的namespace属性为Mapper接口全限定名一致\",\"XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。\",\"<select>标签：就是用于编写select查询语句的。\",\"resultType属性，指的是查询返回的单条记录所封装的类型。\"]},{\"header\":\"2 XML配置文件实现\",\"slug\":\"_2-xml配置文件实现\",\"contents\":[\"第1步：创建XML映射文件\",\"第2步：编写XML映射文件\",\"xml映射文件中的dtd约束，直接从mybatis官网复制即可\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"https://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"\\\"> </mapper> \",\"配置：XML映射文件的namespace属性为Mapper接口全限定名\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"https://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"com.itheima.mapper.EmpMapper\\\"> </mapper> \",\"配置：XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"https://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"com.itheima.mapper.EmpMapper\\\"> <!--查询操作--> <select id=\\\"list\\\" resultType=\\\"com.itheima.pojo.Emp\\\"> select * from emp where name like concat('%',#{name},'%') and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc </select> </mapper> \",\"运行测试类，执行结果：\"]}]},\"/BackEnd/MyBatis/mybatis07.html\":{\"title\":\"Mybatis动态SQL\",\"contents\":[{\"header\":\"1 什么是动态SQL\",\"slug\":\"_1-什么是动态sql\",\"contents\":[\"在页面原型中，列表上方的条件是动态的，是可以不传递的，也可以只传递其中的1个或者2个或者全部。\",\"而在刚才编写的SQL语句中，如果页面只传递了参数姓名 name 字段，其他两个字段 性别 和 入职时间 没有传递，那么这两个参数的值就是null。\",\"此时，执行的SQL语句为：\",\"这个查询结果是不正确的。正确的做法应该是：传递了参数，再组装这个查询条件；如果没有传递参数，就不应该组装这个查询条件。\",\"比如：如果姓名输入了\\\"张\\\", 对应的SQL为:\",\"select * from emp where name like '%张%' order by update_time desc; \",\"如果姓名输入了\\\"张\\\"，性别选择了\\\"男\\\"，则对应的SQL为:\",\"select * from emp where name like '%张%' and gender = 1 order by update_time desc; \",\"SQL语句会随着用户的输入或外部条件的变化而变化，我们称为：动态SQL。\"]},{\"header\":\"2 动态SQL-if\",\"slug\":\"_2-动态sql-if\",\"contents\":[\"<if>：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL。\",\"<if test=\\\"条件表达式\\\"> 要拼接的sql语句 </if> \"]},{\"header\":\"2.1 条件查询\",\"slug\":\"_2-1-条件查询\",\"contents\":[\"原有的SQL语句\",\"<select id=\\\"list\\\" resultType=\\\"com.itheima.pojo.Emp\\\"> select * from emp where name like concat('%',#{name},'%') and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc </select> \",\"动态SQL语句\",\"<select id=\\\"list\\\" resultType=\\\"com.itheima.pojo.Emp\\\"> select * from emp where <if test=\\\"name != null\\\"> name like concat('%',#{name},'%') </if> <if test=\\\"gender != null\\\"> and gender = #{gender} </if> <if test=\\\"begin != null and end != null\\\"> and entrydate between #{begin} and #{end} </if> order by update_time desc </select> \",\"测试方法：\",\"@Test public void testList(){ //性别数据为null、开始时间和结束时间也为null List<Emp> list = empMapper.list(\\\"张\\\", null, null, null); for(Emp emp : list){ System.out.println(emp); } } \",\"执行的SQL语句：\",\"修改测试方法中的代码，再次进行测试：\",\"@Test public void testList(){ //姓名为null List<Emp> list = empMapper.list(null, (short)1, null, null); for(Emp emp : list){ System.out.println(emp); } } \",\"执行结果：\",\"再次修改测试方法中的代码，再次进行测试：\",\"@Test public void testList(){ //传递的数据全部为null List<Emp> list = empMapper.list(null, null, null, null); for(Emp emp : list){ System.out.println(emp); } } \",\"执行的SQL语句：\",\"以上问题的解决方案：使用<where>标签代替SQL语句中的where关键字\",\"<where>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR\",\"<select id=\\\"list\\\" resultType=\\\"com.itheima.pojo.Emp\\\"> select * from emp <where> <!-- if做为where标签的子元素 --> <if test=\\\"name != null\\\"> and name like concat('%',#{name},'%') </if> <if test=\\\"gender != null\\\"> and gender = #{gender} </if> <if test=\\\"begin != null and end != null\\\"> and entrydate between #{begin} and #{end} </if> </where> order by update_time desc </select> \",\"测试方法：\",\"@Test public void testList(){ //只有性别 List<Emp> list = empMapper.list(null, (short)1, null, null); for(Emp emp : list){ System.out.println(emp); } } \",\"执行的SQL语句：\"]},{\"header\":\"2.2 更新员工\",\"slug\":\"_2-2-更新员工\",\"contents\":[\"案例：完善更新员工功能，修改为动态更新员工数据信息\",\"动态更新员工信息，如果更新时传递有值，则更新；如果更新时没有传递值，则不更新\",\"解决方案：动态SQL\",\"修改Mapper接口：\",\"@Mapper public interface EmpMapper { //删除@Update注解编写的SQL语句 //update操作的SQL语句编写在Mapper映射文件中 public void update(Emp emp); } \",\"修改Mapper映射文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"https://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"com.itheima.mapper.EmpMapper\\\"> <!--更新操作--> <update id=\\\"update\\\"> update emp set <if test=\\\"username != null\\\"> username=#{username}, </if> <if test=\\\"name != null\\\"> name=#{name}, </if> <if test=\\\"gender != null\\\"> gender=#{gender}, </if> <if test=\\\"image != null\\\"> image=#{image}, </if> <if test=\\\"job != null\\\"> job=#{job}, </if> <if test=\\\"entrydate != null\\\"> entrydate=#{entrydate}, </if> <if test=\\\"deptId != null\\\"> dept_id=#{deptId}, </if> <if test=\\\"updateTime != null\\\"> update_time=#{updateTime} </if> where id=#{id} </update> </mapper> \",\"测试方法：\",\"@Test public void testUpdate2(){ //要修改的员工信息 Emp emp = new Emp(); emp.setId(20); emp.setUsername(\\\"Tom111\\\"); emp.setName(\\\"汤姆111\\\"); emp.setUpdateTime(LocalDateTime.now()); //调用方法，修改员工数据 empMapper.update(emp); } \",\"执行的SQL语句：\",\"再次修改测试方法，观察SQL语句执行情况：\",\"@Test public void testUpdate2(){ //要修改的员工信息 Emp emp = new Emp(); emp.setId(20); emp.setUsername(\\\"Tom222\\\"); //调用方法，修改员工数据 empMapper.update(emp); } \",\"执行的SQL语句：\",\"以上问题的解决方案：使用<set>标签代替SQL语句中的set关键字\",\"<set>：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"https://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"com.itheima.mapper.EmpMapper\\\"> <!--更新操作--> <update id=\\\"update\\\"> update emp <!-- 使用set标签，代替update语句中的set关键字 --> <set> <if test=\\\"username != null\\\"> username=#{username}, </if> <if test=\\\"name != null\\\"> name=#{name}, </if> <if test=\\\"gender != null\\\"> gender=#{gender}, </if> <if test=\\\"image != null\\\"> image=#{image}, </if> <if test=\\\"job != null\\\"> job=#{job}, </if> <if test=\\\"entrydate != null\\\"> entrydate=#{entrydate}, </if> <if test=\\\"deptId != null\\\"> dept_id=#{deptId}, </if> <if test=\\\"updateTime != null\\\"> update_time=#{updateTime} </if> </set> where id=#{id} </update> </mapper> \",\"再次执行测试方法，执行的SQL语句：\",\"小结:\",\"<if>\",\"用于判断条件是否成立，如果条件为true，则拼接SQL\",\"形式：\",\"<if test=\\\"name != null\\\"> … </if> \",\"<where>\",\"where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR\",\"<set>\",\"动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中）\"]},{\"header\":\"3 动态SQL-foreach\",\"slug\":\"_3-动态sql-foreach\",\"contents\":[\"案例：员工删除功能（既支持删除单条记录，又支持批量删除）\",\"SQL语句：\",\"delete from emp where id in (1,2,3); \",\"Mapper接口：\",\"@Mapper public interface EmpMapper { //批量删除 public void deleteByIds(List<Integer> ids); } \",\"XML映射文件：\",\"使用<foreach>遍历deleteByIds方法中传递的参数ids集合\",\"<foreach collection=\\\"集合名称\\\" item=\\\"集合遍历出来的元素/项\\\" separator=\\\"每一次遍历使用的分隔符\\\" open=\\\"遍历开始前拼接的片段\\\" close=\\\"遍历结束后拼接的片段\\\"> </foreach> \",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"https://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"com.itheima.mapper.EmpMapper\\\"> <!--删除操作--> <delete id=\\\"deleteByIds\\\"> delete from emp where id in <foreach collection=\\\"ids\\\" item=\\\"id\\\" separator=\\\",\\\" open=\\\"(\\\" close=\\\")\\\"> #{id} </foreach> </delete> </mapper> \",\" 执行的SQL语句：\"]},{\"header\":\"4 动态SQL-sql & include\",\"slug\":\"_4-动态sql-sql-include\",\"contents\":[\"问题分析：\",\"在xml映射文件中配置的SQL，有时可能会存在很多重复的片段，此时就会存在很多冗余的代码\",\"对重复的代码片段进行抽取，将其通过<sql>标签封装到一个SQL片段，然后再通过<include>标签进行引用。\",\"<sql>：定义可重用的SQL片段\",\"<include>：通过属性refid，指定包含的SQL片段\",\"SQL片段： 抽取重复的代码\",\"<sql id=\\\"commonSelect\\\"> select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp </sql> \",\"然后通过<include> 标签在原来抽取的地方进行引用。操作如下：\",\"<select id=\\\"list\\\" resultType=\\\"com.itheima.pojo.Emp\\\"> <include refid=\\\"commonSelect\\\"/> <where> <if test=\\\"name != null\\\"> name like concat('%',#{name},'%') </if> <if test=\\\"gender != null\\\"> and gender = #{gender} </if> <if test=\\\"begin != null and end != null\\\"> and entrydate between #{begin} and #{end} </if> </where> order by update_time desc </select> \"]}]},\"/BackEnd/MybatisPlus/\":{\"title\":\"MyBatisPlus\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，简化CRUD操作。\"]},{\"header\":\"框架结构\",\"slug\":\"框架结构\",\"contents\":[]},{\"header\":\"优点 | Advantages\",\"slug\":\"优点-advantages\",\"contents\":[\"无侵入：Mybatis-Plus 在 Mybatis 的基础上进行扩展，只做增强不做改变，引入 Mybatis-Plus 不会对您现有的 Mybatis 构架产生任何影响，而且 MP 支持所有 Mybatis 原生的特性\",\"依赖少：仅仅依赖 Mybatis 以及 Mybatis-Spring\",\"损耗小：启动即会自动注入基本CURD，性能基本无损耗，直接面向对象操作\",\"通用CRUD操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求\",\"多种主键策略：支持多达4种主键策略（内含分布式唯一ID生成器），可自由配置，完美解决主键问题\",\"支持ActiveRecord：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可实现基本 CRUD 操作\",\"支持代码生成：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用（P.S. 比 Mybatis 官方的 Generator 更加强大！）\",\"支持自定义全局通用操作：支持全局通用方法注入( Write once, use anywhere )\",\"内置分页插件：基于Mybatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于写基本List查询\",\"内置性能分析插件：可输出Sql语句以及其执行时间，建议开发测试时启用该功能，能有效解决慢查询\",\"内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，预防误操作\"]},{\"header\":\"相关链接 | Links\",\"slug\":\"相关链接-links\",\"contents\":[\"文档\",\"代码生成\",\"功能示例\",\"展示\",\"企业版 Mybatis-Mate 高级特性\"]},{\"header\":\"原理 | Principle\",\"slug\":\"原理-principle\",\"contents\":[\"Mybatis-Plus 实践及架构原理\"]}]},\"/BackEnd/MybatisPlus/mybatisplus01.html\":{\"title\":\"MybatisPlus入门\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"能够基于 MyBatisPlus 完成标准Dao开发\",\"能够掌握 MyBatisPlus 的条件查询\",\"能够掌握 MyBatisPlus 的字段映射与表名映射\",\"能够掌握 id 生成策略控制\",\"能够理解代码生成器的相关配置\"]},{\"header\":\"1 MyBatisPlus简介\",\"slug\":\"_1-mybatisplus简介\",\"contents\":[]},{\"header\":\"1.1 入门案例\",\"slug\":\"_1-1-入门案例\",\"contents\":[\"MyBatisPlus环境搭建的步骤？\"]},{\"header\":\"SpringBoot整合MyBatisPlus入门程序\",\"slug\":\"springboot整合mybatisplus入门程序\",\"contents\":[]},{\"header\":\"①：创建新模块，选择Spring初始化，并配置模块相关基础信息\",\"slug\":\"_1-创建新模块-选择spring初始化-并配置模块相关基础信息\",\"contents\":[]},{\"header\":\"②：选择当前模块需要使用的技术集（仅保留JDBC）\",\"slug\":\"_2-选择当前模块需要使用的技术集-仅保留jdbc\",\"contents\":[]},{\"header\":\"③：手动添加MyBatisPlus起步依赖\",\"slug\":\"_3-手动添加mybatisplus起步依赖\",\"contents\":[\"<dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId> <version>3.4.1</version> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> \",\"注意事项1：由于mp并未被收录到idea的系统内置配置，无法直接选择加入\",\"注意事项2：如果使用Druid数据源，需要导入对应坐标\"]},{\"header\":\"④：制作实体类与表结构\",\"slug\":\"_4-制作实体类与表结构\",\"contents\":[\"（类名与表名对应，属性名与字段名对应）\",\"create database if not exists mybatisplus_db character set utf8; use mybatisplus_db; CREATE TABLE user ( id bigint(20) primary key auto_increment, name varchar(32) not null, password varchar(32) not null, age int(3) not null , tel varchar(32) not null ); insert into user values(null,'tom','123456',12,'12345678910'); insert into user values(null,'jack','123456',8,'12345678910'); insert into user values(null,'jerry','123456',15,'12345678910'); insert into user values(null,'tom','123456',9,'12345678910'); insert into user values(null,'snake','123456',28,'12345678910'); insert into user values(null,'张益达','123456',22,'12345678910'); insert into user values(null,'张大炮','123456',16,'12345678910'); \",\"public class User { private Long id; private String name; private String password; private Integer age; private String tel; //自行添加getter、setter、toString()等方法 } \"]},{\"header\":\"⑤：设置Jdbc参数（ application.yml ）\",\"slug\":\"_5-设置jdbc参数-application-yml\",\"contents\":[\"spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC username: root password: root \"]},{\"header\":\"⑥：定义数据接口，继承 BaseMapper\",\"slug\":\"_6-定义数据接口-继承basemapper\",\"contents\":[\"package com.itheima.dao; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.domain.User; import org.apache.ibatis.annotations.Mapper; @Mapper public interface UserDao extends BaseMapper<User> { } \"]},{\"header\":\"⑦：测试类中注入dao接口，测试功能\",\"slug\":\"_7-测试类中注入dao接口-测试功能\",\"contents\":[\"package com.itheima; import com.itheima.dao.UserDao; import com.itheima.domain.User; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.List; @SpringBootTest public class Mybatisplus01QuickstartApplicationTests { @Autowired private UserDao userDao; @Test void testGetAll() { List<User> userList = userDao.selectList(null); System.out.println(userList); } } \"]},{\"header\":\"2 标准数据层开发\",\"slug\":\"_2-标准数据层开发\",\"contents\":[]},{\"header\":\"2.1 MyBatisPlus的CRUD操作\",\"slug\":\"_2-1-mybatisplus的crud操作\",\"contents\":[\"package com.itheima; import com.itheima.dao.UserDao; import com.itheima.domain.User; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.List; @SpringBootTest class Mybatisplus01QuickstartApplicationTests { @Autowired private UserDao userDao; @Test void testSave() { User user = new User(); user.setName(\\\"黑马程序员\\\"); user.setPassword(\\\"itheima\\\"); user.setAge(12); user.setTel(\\\"4006184000\\\"); userDao.insert(user); } @Test void testDelete() { userDao.deleteById(1401856123725713409L); } @Test void testUpdate() { User user = new User(); user.setId(1L); user.setName(\\\"Tom888\\\"); user.setPassword(\\\"tom888\\\"); userDao.updateById(user); } @Test void testGetById() { User user = userDao.selectById(2L); System.out.println(user); } @Test void testGetAll() { List<User> userList = userDao.selectList(null); System.out.println(userList); } } \"]},{\"header\":\"2.2 MyBatisPlus分页功能\",\"slug\":\"_2-2-mybatisplus分页功能\",\"contents\":[\"思考一下Mybatis分页插件是如何用的？\"]},{\"header\":\"2.2.1 分页功能接口\",\"slug\":\"_2-2-1-分页功能接口\",\"contents\":[]},{\"header\":\"2.2.2 MyBatisPlus分页使用\",\"slug\":\"_2-2-2-mybatisplus分页使用\",\"contents\":[\"①：设置分页拦截器作为Spring管理的bean\",\"package com.itheima.config; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ //1 创建MybatisPlusInterceptor拦截器对象 MybatisPlusInterceptor mpInterceptor=new MybatisPlusInterceptor(); //2 添加分页拦截器 mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mpInterceptor; } } \",\"②：执行分页查询\",\"//分页查询 @Test void testSelectPage(){ //1 创建IPage分页对象,设置分页参数 IPage<User> page=new Page<>(1,3); //2 执行分页查询 userDao.selectPage(page,null); //3 获取分页结果 System.out.println(\\\"当前页码值：\\\"+page.getCurrent()); System.out.println(\\\"每页显示数：\\\"+page.getSize()); System.out.println(\\\"总页数：\\\"+page.getPages()); System.out.println(\\\"总条数：\\\"+page.getTotal()); System.out.println(\\\"当前页数据：\\\"+page.getRecords()); } \"]},{\"header\":\"2.2.3 开启MyBatisPlus日志\",\"slug\":\"_2-2-3-开启mybatisplus日志\",\"contents\":[\"spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC username: root password: root # 开启mp的日志（输出到控制台） mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl \"]},{\"header\":\"2.2.4 解决日志打印过多问题\",\"slug\":\"_2-2-4-解决日志打印过多问题\",\"contents\":[]},{\"header\":\"2.2.4.1 取消初始化spring日志打印\",\"slug\":\"_2-2-4-1-取消初始化spring日志打印\",\"contents\":[\"做法：在resources下新建一个logback.xml文件，名称固定，内容如下：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <configuration> </configuration> \",\"关于logback参考播客：https://www.jianshu.com/p/75f9d11ae011\"]},{\"header\":\"2.2.4.2 取消SpringBoot启动banner图标\",\"slug\":\"_2-2-4-2-取消springboot启动banner图标\",\"contents\":[\"spring: main: banner-mode: off # 关闭SpringBoot启动图标(banner) \"]},{\"header\":\"2.2.4.3 取消MybatisPlus启动banner图标\",\"slug\":\"_2-2-4-3-取消mybatisplus启动banner图标\",\"contents\":[\"# mybatis-plus日志控制台输出 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: banner: off # 关闭mybatisplus启动图标 \"]},{\"header\":\"3 DQL编程控制\",\"slug\":\"_3-dql编程控制\",\"contents\":[]},{\"header\":\"3.1 条件查询方式\",\"slug\":\"_3-1-条件查询方式\",\"contents\":[\"MyBatisPlus将书写复杂的SQL查询条件进行了封装，使用编程的形式完成查询条件的组合\"]},{\"header\":\"3.1.1 条件查询\",\"slug\":\"_3-1-1-条件查询\",\"contents\":[]},{\"header\":\"3.1.1.1 方式一：按条件查询\",\"slug\":\"_3-1-1-1-方式一-按条件查询\",\"contents\":[\"//方式一：按条件查询 QueryWrapper<User> qw=new QueryWrapper<>(); qw.lt(\\\"age\\\", 18); List<User> userList = userDao.selectList(qw); System.out.println(userList); \"]},{\"header\":\"3.1.1.2 方式二：lambda格式按条件查询\",\"slug\":\"_3-1-1-2-方式二-lambda格式按条件查询\",\"contents\":[\"//方式二：lambda格式按条件查询 QueryWrapper<User> qw = new QueryWrapper<User>(); qw.lambda().lt(User::getAge, 10); List<User> userList = userDao.selectList(qw); System.out.println(userList); \"]},{\"header\":\"3.1.1.3 方式三：lambda格式按条件查询（推荐）\",\"slug\":\"_3-1-1-3-方式三-lambda格式按条件查询-推荐\",\"contents\":[\"//方式三：lambda格式按条件查询 LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); lqw.lt(User::getAge, 10); List<User> userList = userDao.selectList(lqw); System.out.println(userList); \"]},{\"header\":\"3.1.2 组合条件\",\"slug\":\"_3-1-2-组合条件\",\"contents\":[]},{\"header\":\"3.1.2.1 并且关系（and）\",\"slug\":\"_3-1-2-1-并且关系-and\",\"contents\":[\"//并且关系 LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); //并且关系：10到30岁之间 lqw.lt(User::getAge, 30).gt(User::getAge, 10); List<User> userList = userDao.selectList(lqw); System.out.println(userList); \"]},{\"header\":\"3.1.2.2 或者关系（or）\",\"slug\":\"_3-1-2-2-或者关系-or\",\"contents\":[\"//或者关系 LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); //或者关系：小于10岁或者大于30岁 lqw.lt(User::getAge, 10).or().gt(User::getAge, 30); List<User> userList = userDao.selectList(lqw); System.out.println(userList); \"]},{\"header\":\"3.1.3 NULL值处理\",\"slug\":\"_3-1-3-null值处理\",\"contents\":[\"如下搜索场景，在多条件查询中，有条件的值为空应该怎么解决？\"]},{\"header\":\"3.1.3.1 if语句控制条件追加\",\"slug\":\"_3-1-3-1-if语句控制条件追加\",\"contents\":[\"Integer minAge=10; //将来有用户传递进来,此处简化成直接定义变量了 Integer maxAge=null; //将来有用户传递进来,此处简化成直接定义变量了 LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); if(minAge!=null){ lqw.gt(User::getAge, minAge); } if(maxAge!=null){ lqw.lt(User::getAge, maxAge); } List<User> userList = userDao.selectList(lqw); userList.forEach(System.out::println); \"]},{\"header\":\"3.1.3.2 条件参数控制\",\"slug\":\"_3-1-3-2-条件参数控制\",\"contents\":[\"Integer minAge=10; //将来有用户传递进来,此处简化成直接定义变量了 Integer maxAge=null; //将来有用户传递进来,此处简化成直接定义变量了 LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); //参数1：如果表达式为true，那么查询才使用该条件 lqw.gt(minAge!=null,User::getAge, minAge); lqw.lt(maxAge!=null,User::getAge, maxAge); List<User> userList = userDao.selectList(lqw); userList.forEach(System.out::println); \"]},{\"header\":\"3.1.3.3 条件参数控制（链式编程）\",\"slug\":\"_3-1-3-3-条件参数控制-链式编程\",\"contents\":[\"Integer minAge=10; //将来有用户传递进来,此处简化成直接定义变量了 Integer maxAge=null; //将来有用户传递进来,此处简化成直接定义变量了 LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); //参数1：如果表达式为true，那么查询才使用该条件 lqw.gt(minAge!=null,User::getAge, minAge) .lt(maxAge!=null,User::getAge, maxAge); List<User> userList = userDao.selectList(lqw); userList.forEach(System.out::println); \"]},{\"header\":\"3.2 查询投影-设置【查询字段、分组、分页】\",\"slug\":\"_3-2-查询投影-设置【查询字段、分组、分页】\",\"contents\":[]},{\"header\":\"3.2.1 查询结果包含模型类中部分属性\",\"slug\":\"_3-2-1-查询结果包含模型类中部分属性\",\"contents\":[\"/*LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); lqw.select(User::getId, User::getName, User::getAge);*/ //或者 QueryWrapper<User> lqw = new QueryWrapper<User>(); lqw.select(\\\"id\\\", \\\"name\\\", \\\"age\\\", \\\"tel\\\"); List<User> userList = userDao.selectList(lqw); System.out.println(userList); \"]},{\"header\":\"3.2.2 查询结果包含模型类中未定义的属性\",\"slug\":\"_3-2-2-查询结果包含模型类中未定义的属性\",\"contents\":[\"QueryWrapper<User> lqw = new QueryWrapper<User>(); lqw.select(\\\"count(*) as count, tel\\\"); lqw.groupBy(\\\"tel\\\"); List<Map<String, Object>> userList = userDao.selectMaps(lqw); System.out.println(userList); \"]},{\"header\":\"3.3 查询条件设定\",\"slug\":\"_3-3-查询条件设定\",\"contents\":[\"多条件查询有哪些组合？\",\"范围匹配（> 、 = 、between）\",\"模糊匹配（like）\",\"空判定（null）\",\"包含性匹配（in）\",\"分组（group）\",\"排序（order）\",\"……\"]},{\"header\":\"3.3.1 查询条件\",\"slug\":\"_3-3-1-查询条件\",\"contents\":[\"用户登录（eq匹配）\",\"LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); //等同于= lqw.eq(User::getName, \\\"Jerry\\\").eq(User::getPassword, \\\"jerry\\\"); User loginUser = userDao.selectOne(lqw); System.out.println(loginUser); \",\"购物设定价格区间、户籍设定年龄区间（le ge匹配 或 between匹配）\",\"LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); //范围查询 lt le gt ge eq between lqw.between(User::getAge, 10, 30); List<User> userList = userDao.selectList(lqw); System.out.println(userList); \",\"查信息，搜索新闻（非全文检索版：like匹配）\",\"LambdaQueryWrapper<User> lqw = new LambdaQueryWrapper<User>(); //模糊匹配 like lqw.likeLeft(User::getName, \\\"J\\\"); List<User> userList = userDao.selectList(lqw); System.out.println(userList); \",\"统计报表（分组查询聚合函数）\",\"QueryWrapper<User> qw = new QueryWrapper<User>(); qw.select(\\\"gender\\\",\\\"count(*) as nums\\\"); qw.groupBy(\\\"gender\\\"); List<Map<String, Object>> maps = userDao.selectMaps(qw); System.out.println(maps); \"]},{\"header\":\"3.3.2 MyBatisPlus练习\",\"slug\":\"_3-3-2-mybatisplus练习\",\"contents\":[\"题目：基于MyBatisPlus_Ex1模块，完成Top5功能的开发。\",\"说明：\",\"①：Top5指根据销售量排序（提示：对销售量进行降序排序）\",\"②：Top5是仅获取前5条数据（提示：使用分页功能控制数据显示数量）\"]},{\"header\":\"3.4 字段映射与表名映射\",\"slug\":\"_3-4-字段映射与表名映射\",\"contents\":[\"思考表的字段和实体类的属性不对应，查询会怎么样？\"]},{\"header\":\"3.4.1 问题一：表字段与编码属性设计不同步\",\"slug\":\"_3-4-1-问题一-表字段与编码属性设计不同步\",\"contents\":[\"在模型类属性上方，使用 @TableField 属性注解，通过 value 属性，设置当前属性对应的数据库表中的字段关系。\"]},{\"header\":\"3.4.2 问题二：编码中添加了数据库中未定义的属性\",\"slug\":\"_3-4-2-问题二-编码中添加了数据库中未定义的属性\",\"contents\":[\"在模型类属性上方，使用 @TableField 注解，通过 exist属性，设置属性在数据库表字段中是否存在，默认为true。此属性无法与value合并使用。\"]},{\"header\":\"3.4.3 问题三：采用默认查询开放了更多的字段查看权限\",\"slug\":\"_3-4-3-问题三-采用默认查询开放了更多的字段查看权限\",\"contents\":[\"在模型类属性上方，使用 @TableField 注解，通过 select 属性：设置该属性是否参与查询。此属性与select()映射配置不冲突。\"]},{\"header\":\"3.4.4 问题四：表名与编码开发设计不同步\",\"slug\":\"_3-4-4-问题四-表名与编码开发设计不同步\",\"contents\":[\"在 模型类 上方，使用 @TableName 注解，通过 value 属性，设置当前类对应的数据库表名称\",\"@Data @TableName(\\\"tbl_user\\\") public class User { /* id为Long类型，因为数据库中id为bigint类型， 并且mybatis有自己的一套id生成方案，生成出来的id必须是Long类型 */ private Long id; private String name; @TableField(value = \\\"pwd\\\",select = false) private String password; private Integer age; private String tel; @TableField(exist = false) //表示online字段不参与CRUD操作 private Boolean online; } \"]},{\"header\":\"4 DML编程控制\",\"slug\":\"_4-dml编程控制\",\"contents\":[]},{\"header\":\"4.1 id生成策略控制（Insert）\",\"slug\":\"_4-1-id生成策略控制-insert\",\"contents\":[\"主键生成的策略有哪几种方式？\",\"不同的表应用不同的id生成策略\",\"日志：自增（1,2,3,4，……）\",\"购物订单：特殊规则（FQ23948AK3843）\",\"外卖单：关联地区日期等信息（10 04 20200314 34 91）\",\"关系表：可省略id\",\"……\"]},{\"header\":\"4.1.1 id生成策略控制（@TableId注解）\",\"slug\":\"_4-1-1-id生成策略控制-tableid注解\",\"contents\":[\"名称：@TableId\",\"类型：属性注解\",\"位置：模型类中用于表示主键的属性定义上方\",\"作用：设置当前类中主键属性的生成策略\",\"相关属性\",\"type：设置主键属性的生成策略，值参照IdType枚举值\"]},{\"header\":\"4.1.2 全局策略配置\",\"slug\":\"_4-1-2-全局策略配置\",\"contents\":[\"mybatis-plus: global-config: db-config: id-type: assign_id table-prefix: tbl_ \"]},{\"header\":\"id生成策略全局配置\",\"slug\":\"id生成策略全局配置\",\"contents\":[]},{\"header\":\"表名前缀全局配置\",\"slug\":\"表名前缀全局配置\",\"contents\":[]},{\"header\":\"4.2 多记录操作（批量Delete/Select）\",\"slug\":\"_4-2-多记录操作-批量delete-select\",\"contents\":[\"MyBatisPlus是否支持批量操作？\"]},{\"header\":\"4.2.1 按照主键删除多条记录\",\"slug\":\"_4-2-1-按照主键删除多条记录\",\"contents\":[\"//删除指定多条数据 List<Long> list = new ArrayList<>(); list.add(1402551342481838081L); list.add(1402553134049501186L); list.add(1402553619611430913L); userDao.deleteBatchIds(list); \"]},{\"header\":\"4.2.2 根据主键查询多条记录\",\"slug\":\"_4-2-2-根据主键查询多条记录\",\"contents\":[\"//查询指定多条数据 List<Long> list = new ArrayList<>(); list.add(1L); list.add(3L); list.add(4L); userDao.selectBatchIds(list); \"]},{\"header\":\"4.3 逻辑删除（Delete/Update）\",\"slug\":\"_4-3-逻辑删除-delete-update\",\"contents\":[\"在实际环境中，如果想删除一条数据，是否会真的从数据库中删除该条数据？\",\"删除操作业务问题：业务数据从数据库中丢弃\",\"逻辑删除：为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中\"]},{\"header\":\"4.3.1 逻辑删除案例\",\"slug\":\"_4-3-1-逻辑删除案例\",\"contents\":[]},{\"header\":\"①：数据库表中添加逻辑删除标记字段\",\"slug\":\"_1-数据库表中添加逻辑删除标记字段\",\"contents\":[]},{\"header\":\"②：实体类中添加对应字段，并设定当前字段为逻辑删除标记字段\",\"slug\":\"_2-实体类中添加对应字段-并设定当前字段为逻辑删除标记字段\",\"contents\":[\"package com.itheima.domain; import com.baomidou.mybatisplus.annotation.*; import lombok.Data; @Data public class User { private Long id; //逻辑删除字段，标记当前记录是否被删除 @TableLogic private Integer deleted; } \"]},{\"header\":\"③：配置逻辑删除字面值\",\"slug\":\"_3-配置逻辑删除字面值\",\"contents\":[\"mybatis-plus: global-config: db-config: table-prefix: tbl_ # 逻辑删除字段名 logic-delete-field: deleted # 逻辑删除字面值：未删除为0 logic-not-delete-value: 0 # 逻辑删除字面值：删除为1 logic-delete-value: 1 \",\"逻辑删除本质：逻辑删除的本质其实是修改操作。如果加了逻辑删除字段，查询数据时也会自动带上逻辑删除字段。\"]},{\"header\":\"4.4 乐观锁（Update）\",\"slug\":\"_4-4-乐观锁-update\",\"contents\":[\"乐观锁主张的思想是什么？\",\"业务并发现象带来的问题：秒杀\"]},{\"header\":\"4.4.1 乐观锁案例\",\"slug\":\"_4-4-1-乐观锁案例\",\"contents\":[]},{\"header\":\"①：数据库表中添加锁标记字段\",\"slug\":\"_1-数据库表中添加锁标记字段\",\"contents\":[]},{\"header\":\"②： 实体类中添加对应字段，并设定当前字段为逻辑删除标记字段\",\"slug\":\"_2-实体类中添加对应字段-并设定当前字段为逻辑删除标记字段-1\",\"contents\":[\"package com.itheima.domain; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableLogic; import com.baomidou.mybatisplus.annotation.Version; import lombok.Data; @Data public class User { private Long id; @Version private Integer version; } \"]},{\"header\":\"③：配置乐观锁拦截器实现锁机制对应的动态SQL语句拼装\",\"slug\":\"_3-配置乐观锁拦截器实现锁机制对应的动态sql语句拼装\",\"contents\":[\"package com.itheima.config; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MpConfig { @Bean public MybatisPlusInterceptor mpInterceptor() { //1.定义Mp拦截器 MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor(); //2.添加乐观锁拦截器 mpInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return mpInterceptor; } } \"]},{\"header\":\"④：使用乐观锁机制在修改前必须先获取到对应数据的verion方可正常进行\",\"slug\":\"_4-使用乐观锁机制在修改前必须先获取到对应数据的verion方可正常进行\",\"contents\":[\"@Test public void testUpdate() { /*User user = new User(); user.setId(3L); user.setName(\\\"Jock666\\\"); user.setVersion(1); userDao.updateById(user);*/ //1.先通过要修改的数据id将当前数据查询出来 //User user = userDao.selectById(3L); //2.将要修改的属性逐一设置进去 //user.setName(\\\"Jock888\\\"); //userDao.updateById(user); //1.先通过要修改的数据id将当前数据查询出来 User user = userDao.selectById(3L); //version=3 User user2 = userDao.selectById(3L); //version=3 user2.setName(\\\"Jock aaa\\\"); userDao.updateById(user2); //version=>4 user.setName(\\\"Jock bbb\\\"); userDao.updateById(user); //verion=3?条件还成立吗？ } \"]}]},\"/BackEnd/MybatisPlus/mybatisplus02.html\":{\"title\":\"MybatisPlus代码生成器\",\"contents\":[{\"header\":\"1 快速开发-代码生成器\",\"slug\":\"_1-快速开发-代码生成器\",\"contents\":[\"如果只给一张表的字段信息，能够推演出Domain、Dao层的代码？\"]},{\"header\":\"1.1 MyBatisPlus提供模板\",\"slug\":\"_1-1-mybatisplus提供模板\",\"contents\":[\"Mapper接口模板\",\"实体对象类模板\"]},{\"header\":\"1.2 工程搭建和基本代码编写\",\"slug\":\"_1-2-工程搭建和基本代码编写\",\"contents\":[\"第一步：创建SpringBoot工程，添加代码生成器相关依赖，其他依赖自行添加\",\"<!--代码生成器--> <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-generator</artifactId> <version>3.4.1</version> </dependency> <!--velocity模板引擎--> <dependency> <groupId>org.apache.velocity</groupId> <artifactId>velocity-engine-core</artifactId> <version>2.3</version> </dependency> \",\"第二步：编写代码生成器类\",\"package com.itheima; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.config.DataSourceConfig; public class Generator { public static void main(String[] args) { //1. 创建代码生成器对象，执行生成代码操作 AutoGenerator autoGenerator = new AutoGenerator(); //2. 数据源相关配置：读取数据库中的信息，根据数据库表结构生成代码 DataSourceConfig dataSource = new DataSourceConfig(); dataSource.setDriverName(\\\"com.mysql.cj.jdbc.Driver\\\"); dataSource.setUrl(\\\"jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC\\\"); dataSource.setUsername(\\\"root\\\"); dataSource.setPassword(\\\"root\\\"); autoGenerator.setDataSource(dataSource); //3. 执行生成操作 autoGenerator.execute(); } } \"]},{\"header\":\"1.3 开发者自定义配置\",\"slug\":\"_1-3-开发者自定义配置\",\"contents\":[\"设置全局配置\",\"//设置全局配置 GlobalConfig globalConfig = new GlobalConfig(); globalConfig.setOutputDir(System.getProperty(\\\"user.dir\\\")+\\\"/mybatisplus_04_generator/src/main/java\\\"); //设置代码生成位置 globalConfig.setOpen(false); //设置生成完毕后是否打开生成代码所在的目录 globalConfig.setAuthor(\\\"黑马程序员\\\"); //设置作者 globalConfig.setFileOverride(true); //设置是否覆盖原始生成的文件 globalConfig.setMapperName(\\\"%sDao\\\"); //设置数据层接口名，%s为占位符，指代模块名称 globalConfig.setIdType(IdType.ASSIGN_ID); //设置Id生成策略 autoGenerator.setGlobalConfig(globalConfig); \",\"设置包名相关配置\",\"//设置包名相关配置 PackageConfig packageInfo = new PackageConfig(); packageInfo.setParent(\\\"com.aaa\\\"); //设置生成的包名，与代码所在位置不冲突，二者叠加组成完整路径 packageInfo.setEntity(\\\"domain\\\"); //设置实体类包名 packageInfo.setMapper(\\\"dao\\\"); //设置数据层包名 autoGenerator.setPackageInfo(packageInfo); \",\"策略设置\",\"//策略设置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setInclude(\\\"tbl_user\\\"); //设置当前参与生成的表名，参数为可变参数 strategyConfig.setTablePrefix(\\\"tbl_\\\"); //设置数据库表的前缀名称，模块名 = 数据库表名 - 前缀名 例如： User = tbl_user - tbl_ strategyConfig.setRestControllerStyle(true); //设置是否启用Rest风格 strategyConfig.setVersionFieldName(\\\"version\\\"); //设置乐观锁字段名 strategyConfig.setLogicDeleteFieldName(\\\"deleted\\\"); //设置逻辑删除字段名 strategyConfig.setEntityLombokModel(true); //设置是否启用lombok autoGenerator.setStrategy(strategyConfig); \"]}]},\"/BackEnd/Spring/\":{\"title\":\"Spring\",\"contents\":[{\"header\":\"简化开发\",\"slug\":\"简化开发\",\"contents\":[\"Spring框架中提供了两个大的核心技术，分别是：IOC、AOP\",\"Spring的简化操作都是基于这两块内容\"]},{\"header\":\"框架整合\",\"slug\":\"框架整合\",\"contents\":[\"Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如:\",\"MyBatis\",\"MyBatis-plus\",\"Struts\",\"Struts2\",\"Hibernate\",\"……\",\"综上所述，对于Spring的学习，主要学习四块内容:\",\"IOC\",\"整合Mybatis（IOC的具体应用）\",\"AOP\",\"声明式事务（AOP的具体应用）\"]},{\"header\":\"Spring家族\",\"slug\":\"spring家族\",\"contents\":[\"Spring开发生态圈提供了若干个项目，每个项目用于完成特定的功能，可自行选择，把这些项目组合起来\"]},{\"header\":\"常用框架\",\"slug\":\"常用框架\",\"contents\":[\"Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础\",\"SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上快速开发\",\"SpringCloud：用来做分布式微服务架构的相关开发\",\"除了上面的这三个技术外，还有很多其他的技术也比较流行，如SpringData、SpringSecurity等\"]},{\"header\":\"Spring发展史\",\"slug\":\"spring发展史\",\"contents\":[\"IBM（IT公司-国际商业机器公司）在1997年提出了EJB思想，早期的JAVAEE开发大都基于该思想\",\"Rod Johnson在2004年出版的Expert One-on-One J2EE Development without EJB，书中提出了比EJB思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是Spring1.0\",\"随着时间推移，版本不断更新维护\",\"Spring1.0 是纯配置文件开发\",\"Spring2.0 为了简化开发引入了注解开发，此时为配置文件加注解的开发方式\",\"Spring3.0 已经可以进行纯注解开发，使开发效率大幅提升\",\"Spring4.0 根据JDK的版本升级对个别API进行了调整\",\"Spring5.0 已经全面支持JDK8\"]},{\"header\":\"Spring系统架构\",\"slug\":\"spring系统架构\",\"contents\":[\"Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整\",\"核心层\",\"Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块\",\"AOP层\",\"AOP：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强\",\"Aspects：AOP是思想，Aspects是对AOP思想的具体实现\",\"数据层\",\"Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术\",\"Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis\",\"Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现\",\"Web层\",\"SpringMVC框架\",\"Test层\",\"Spring主要整合了Junit来完成单元测试和集成测试\"]}]},\"/BackEnd/Spring/spring01.html\":{\"title\":\"Spring IOC DI\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"掌握 Spring 相关概念\",\"完成 IOC/DI 的入门案例编写\",\"掌握 IOC 的相关配置与使用\",\"掌握 DI 的相关配置与使用\"]},{\"header\":\"1 Spring核心概念\",\"slug\":\"_1-spring核心概念\",\"contents\":[\"代码在编写过程中遇到的问题\",\"业务层需要调用数据层的方法，就需要在业务层new数据层的对象 \",\"如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变 \",\"发生变更后，都需要进行编译打包和重新部署\",\"针对这个问题，Spring提出了一个解决方案:\",\"使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象\"]},{\"header\":\"1.1 IOC、IOC容器、Bean、DI\",\"slug\":\"_1-1-ioc、ioc容器、bean、di\",\"contents\":[]},{\"header\":\"IOC（Inversion of Control）控制反转\",\"slug\":\"ioc-inversion-of-control-控制反转\",\"contents\":[\"什么是控制反转？\",\"使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转\",\"提示\",\"业务层要用数据层的类对象，以前是自己new的\",\"现在自己不new了，交给别人[外部]来创建对象\",\"别人[外部]就反转控制了数据层对象的创建权\",\"Spring和IOC之间的关系是什么?\",\"Spring技术对IOC思想进行了实现\",\"Spring提供了一个容器，称为IOC容器，用来充当IOC思想中的\\\"外部\\\"\",\"IOC容器的作用以及内部存放的是什么?\",\"IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象\",\"被创建或被管理的对象在IOC容器中统称为Bean\",\"IOC容器中放的就是一个个的Bean对象\",\"当IOC容器中创建好service和dao对象后，程序能正确执行么?\",\"不行\",\"因为service运行需要依赖dao对象\",\"IOC容器中虽然有service和dao对象\",\"service对象和dao对象没有任何关系\",\"需要把dao对象交给service，也就是说要绑定service和dao对象之间的关系\",\"像这种在容器中建立对象与对象之间的绑定关系就要用到Spring的另一个核心概念\"]},{\"header\":\"DI（Dependency Injection）依赖注入\",\"slug\":\"di-dependency-injection-依赖注入\",\"contents\":[\"什么是依赖注入?\",\"在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入\",\"IOC容器中哪些bean之间要建立依赖关系呢?\",\"需要根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系\",\"这两个概念的最终目标就是 充分解耦\",\"具体实现靠:\",\"使用IoC容器管理bean（IOC）\",\"在IoC容器内将有依赖关系的bean进行关系绑定（DI）\",\"最终结果：使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系\",\"小结\",\"什么是IOC/DI思想、什么是IOC容器和什么是Bean\",\"(1) 什么IOC/DI思想?\",\"IOC: 控制反转，控制反转的是对象的创建权\",\"DI: 依赖注入，绑定对象与对象之间的依赖关系\",\"(2) 什么是IOC容器?\",\"Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器\",\"(3) 什么是Bean?\",\"容器中所存放的一个个对象就叫Bean或Bean对象\"]},{\"header\":\"2 入门案例\",\"slug\":\"_2-入门案例\",\"contents\":[\"Spring到底是如何来实现IOC和DI的？\"]},{\"header\":\"2.1 IOC入门案例\",\"slug\":\"_2-1-ioc入门案例\",\"contents\":[\"先分析思路再代码实现\"]},{\"header\":\"2.1.1 入门案例思路分析\",\"slug\":\"_2-1-1-入门案例思路分析\",\"contents\":[\"Spring是使用容器来管理bean对象的，那么管什么?\",\"主要管理项目中所使用到的类对象，比如(Service和Dao)\",\"如何将被管理的对象告知IOC容器?\",\"使用配置文件\",\"被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?\",\"Spring框架提供相应的接口\",\"IOC容器得到后，如何从容器中获取bean?\",\"调用Spring框架提供对应接口中的方法\",\"使用Spring导入哪些坐标?\",\"在pom.xml添加对应的依赖\"]},{\"header\":\"2.1.2 入门案例代码实现\",\"slug\":\"_2-1-2-入门案例代码实现\",\"contents\":[\"需求分析: 将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用\",\"创建Maven的java项目\",\"pom.xml添加Spring的依赖jar包\",\"创建BookService，BookServiceImpl，BookDao和BookDaoImpl四个类\",\"resources下添加spring配置文件，并完成bean的配置\",\"使用Spring提供的接口完成IOC容器的创建\",\"从容器中获取对象进行方法调用\"]},{\"header\":\"步骤1:创建Maven项目\",\"slug\":\"步骤1-创建maven项目\",\"contents\":[]},{\"header\":\"步骤2:添加Spring的依赖jar包\",\"slug\":\"步骤2-添加spring的依赖jar包\",\"contents\":[\"pom.xml\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> </dependencies> \"]},{\"header\":\"步骤3:添加案例中需要的类\",\"slug\":\"步骤3-添加案例中需要的类\",\"contents\":[\"创建BookService，BookServiceImpl，BookDao和BookDaoImpl四个类\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\"); } } public interface BookService { public void save(); } public class BookServiceImpl implements BookService { private BookDao bookDao = new BookDaoImpl(); public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \"]},{\"header\":\"步骤4:添加spring配置文件\",\"slug\":\"步骤4-添加spring配置文件\",\"contents\":[\"resources下添加spring配置文件applicationContext.xml，并完成bean的配置\"]},{\"header\":\"步骤5:在配置文件中完成bean的配置\",\"slug\":\"步骤5-在配置文件中完成bean的配置\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!-- bean标签表示配置bean id属性表示给bean起名字 class属性表示给bean定义类型 --> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"/> </beans> \",\"注意事项：bean定义时id属性在同一个上下文中（配置文件）不能重复\"]},{\"header\":\"步骤6:获取IOC容器\",\"slug\":\"步骤6-获取ioc容器\",\"contents\":[\"使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法\",\"public class App { public static void main(String[] args) { //获取IOC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); } } \"]},{\"header\":\"步骤7:从容器中获取对象进行方法调用\",\"slug\":\"步骤7-从容器中获取对象进行方法调用\",\"contents\":[\"public class App { public static void main(String[] args) { //获取IOC容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); // BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); // bookDao.save(); BookService bookService = (BookService) ctx.getBean(\\\"bookService\\\"); bookService.save(); } } \"]},{\"header\":\"步骤8:运行程序\",\"slug\":\"步骤8-运行程序\",\"contents\":[\"但是在BookServiceImpl的类中依然存在BookDaoImpl对象的new操作，它们之间的耦合度还是比较高，需要用到下面的DI:依赖注入\"]},{\"header\":\"2.2 DI入门案例\",\"slug\":\"_2-2-di入门案例\",\"contents\":[]},{\"header\":\"2.2.1 入门案例思路分析\",\"slug\":\"_2-2-1-入门案例思路分析\",\"contents\":[\"要想实现依赖注入，必须要基于IOC管理Bean\",\"Service中使用new形式创建的Dao对象是否保留?\",\"需要删除掉，最终要使用IOC容器中的bean对象\",\"Service中需要的Dao对象如何进入到Service中?\",\"在Service中提供方法，让Spring的IOC容器可以通过该方法传入bean对象\",\"Service与Dao间的关系如何描述?\",\"使用配置文件\"]},{\"header\":\"2.2.2 入门案例代码实现\",\"slug\":\"_2-2-2-入门案例代码实现\",\"contents\":[\"需求: 基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入\",\"删除业务层中使用new的方式创建的dao对象\",\"在业务层提供BookDao的setter方法\",\"pom.xml添加Spring的依赖jar包\",\"在spring的配置文件applicationContext.xml添加依赖注入的配置\",\"resources下添加spring配置文件，并完成bean的配置\",\"使用Spring提供的接口完成IOC容器的创建\",\"从容器中获取对象进行方法调用\"]},{\"header\":\"步骤1: 去除代码中的new\",\"slug\":\"步骤1-去除代码中的new\",\"contents\":[\"在BookServiceImpl类中，删除业务层中使用new的方式创建的dao对象\",\"public class BookServiceImpl implements BookService { //删除业务层中使用new的方式创建的dao对象 private BookDao bookDao; public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \"]},{\"header\":\"步骤2:为属性提供setter方法\",\"slug\":\"步骤2-为属性提供setter方法\",\"contents\":[\"在BookServiceImpl类中，为BookDao提供setter方法\",\"public class BookServiceImpl implements BookService { //删除业务层中使用new的方式创建的dao对象 private BookDao bookDao; public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } //提供对应的set方法 public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } \"]},{\"header\":\"步骤3:修改配置完成注入\",\"slug\":\"步骤3-修改配置完成注入\",\"contents\":[\"在spring的配置文件applicationContext.xml添加依赖注入的配置\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!--bean标签表示配置bean id属性表示给bean起名字 class属性表示给bean定义类型 --> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <!--配置server与dao的关系--> <!--property标签表示配置当前bean的属性 name属性表示配置哪一个具体的属性 ref属性表示参照哪一个bean --> <property name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> </bean> </beans> \",\"配置中的两个bookDao的含义是不一样的\",\"name=\\\"bookDao\\\"中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入\",\"ref=\\\"bookDao\\\"中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入\"]},{\"header\":\"步骤4:运行程序\",\"slug\":\"步骤4-运行程序\",\"contents\":[]},{\"header\":\"3 IOC相关内容\",\"slug\":\"_3-ioc相关内容\",\"contents\":[]},{\"header\":\"3.1 bean基础配置\",\"slug\":\"_3-1-bean基础配置\",\"contents\":[\"对于bean的配置中，主要有bean基础配置，bean的别名配置，bean的作用范围配置\"]},{\"header\":\"3.1.1 bean基础配置（id 与 class）\",\"slug\":\"_3-1-1-bean基础配置-id-与-class\",\"contents\":[\"<bean id=\\\"\\\" class=\\\"\\\"/> \",\"bean标签的功能、使用方式以及id和class属性的作用\",\"思考\",\"class属性能不能写接口如BookDao的类全名呢?\",\"不行，因为接口是没办法创建对象的\",\"id必须唯一，但是如果由于命名习惯而产生了分歧后，该如何解决呢?\",\"Bean别名\"]},{\"header\":\"3.1.2 bean别名 name属性\",\"slug\":\"_3-1-2-bean别名-name属性\",\"contents\":[]},{\"header\":\"步骤1：配置别名\",\"slug\":\"步骤1-配置别名\",\"contents\":[\"打开spring的配置文件applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--> <bean id=\\\"bookService\\\" name=\\\"service service4 bookEbi\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <property name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> </bean> <!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--> <bean id=\\\"bookDao\\\" name=\\\"dao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> </beans> \",\"说明：Ebi 全称 Enterprise Business Interface ，翻译为企业业务接口\"]},{\"header\":\"步骤2:根据名称容器中获取bean对象\",\"slug\":\"步骤2-根据名称容器中获取bean对象\",\"contents\":[\"public class AppForName { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); //此处根据bean标签的id属性和name属性的任意一个值来获取bean对象 BookService bookService = (BookService) ctx.getBean(\\\"service4\\\"); bookService.save(); } } \"]},{\"header\":\"步骤3:运行程序\",\"slug\":\"步骤3-运行程序\",\"contents\":[\"注意事项:\",\"bean依赖注入的ref属性，必须在容器中存在\",\"从IOC容器中获取bean填写的名称对应的bean对象如果不存在，如:\"]},{\"header\":\"3.1.3 bean作用范围scope配置\",\"slug\":\"_3-1-3-bean作用范围scope配置\",\"contents\":[\"验证IOC容器中对象是否为单例:\"]},{\"header\":\"验证思路\",\"slug\":\"验证思路\",\"contents\":[\"同一个bean获取两次，将对象打印到控制台，看打印出的地址值是否一致\"]},{\"header\":\"具体实现\",\"slug\":\"具体实现\",\"contents\":[\"创建一个AppForScope的类，在其main方法中来验证\",\"public class AppForScope { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookDao bookDao1 = (BookDao) ctx.getBean(\\\"bookDao\\\"); BookDao bookDao2 = (BookDao) ctx.getBean(\\\"bookDao\\\"); System.out.println(bookDao1); System.out.println(bookDao2); } } \",\"结论: 默认情况下，Spring创建的bean对象都是单例的\",\"配置bean为非单例:\",\"将scope设置为singleton\",\"<bean id=\\\"bookDao\\\" name=\\\"dao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\" scope=\\\"singleton\\\"/> \",\"运行AppForScope，打印看结果\",\"将scope设置为prototype\",\"<bean id=\\\"bookDao\\\" name=\\\"dao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\" scope=\\\"prototype\\\"/> \",\"运行AppForScope，打印看结果\",\"`scope` 使用后续思考\",\"为什么bean默认为单例?\",\"bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象\",\"bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高\",\"bean在容器中是单例的，会不会产生线程安全问题?\",\"如果对象是有状态对象，即该对象有成员变量可以用来存储数据的， 因为所有请求线程共用一个bean对象，所以会存在线程安全问题\",\"如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的， 因方法中的局部变量在方法调用完成后就会被销毁，所以不会存在线程安全问题\",\"哪些bean对象适合交给容器进行管理?\",\"表现层对象\",\"业务层对象\",\"数据层对象\",\"工具对象\",\"哪些bean对象不适合交给容器进行管理?\",\"封装实例的域对象，因为会引发线程安全问题，所以不适合\",\"关于bean的基础配置中，掌握:\",\"<bean id=\\\"bean的唯一标识\\\" class=\\\"bean的类全名\\\" scope=\\\"bean的作用范围，有singleton(默认)和prototype\\\" name=\\\"为bean取的别名\\\"/> \"]},{\"header\":\"3.2 bean实例化\",\"slug\":\"_3-2-bean实例化\",\"contents\":[\"IOC容器是如何来创建对象的呢? bean的实例化过程\",\"实例化bean的三种方式： 构造方法，静态工厂和实例工厂\",\"bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的\"]},{\"header\":\"3.2.1 环境准备\",\"slug\":\"_3-2-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加依赖\",\"resources下添加spring的配置文件applicationContext.xml\"]},{\"header\":\"3.2.2 构造方法实例化\",\"slug\":\"_3-2-2-构造方法实例化\",\"contents\":[]},{\"header\":\"步骤1:准备需要被创建的类\",\"slug\":\"步骤1-准备需要被创建的类\",\"contents\":[\"准备一个BookDao和BookDaoImpl类\",\" public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\"); } } \"]},{\"header\":\"步骤2:将类配置到Spring容器\",\"slug\":\"步骤2-将类配置到spring容器\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> </beans> \"]},{\"header\":\"步骤3:编写运行程序\",\"slug\":\"步骤3-编写运行程序\",\"contents\":[\"public class AppForInstanceBook { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); bookDao.save(); } } \"]},{\"header\":\"步骤4:类中提供public构造函数测试\",\"slug\":\"步骤4-类中提供public构造函数测试\",\"contents\":[\"在BookDaoImpl类中添加一个无参构造函数\",\"public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\\\"book dao constructor is running ....\\\"); } public void save() { System.out.println(\\\"book dao save ...\\\"); } } \",\"运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数\"]},{\"header\":\"步骤5:将构造函数改成private测试\",\"slug\":\"步骤5-将构造函数改成private测试\",\"contents\":[\"public class BookDaoImpl implements BookDao { private BookDaoImpl() { System.out.println(\\\"book dao constructor is running ....\\\"); } public void save() { System.out.println(\\\"book dao save ...\\\"); } } \",\"运行程序，能执行成功，说明内部走的依然是构造函数，能访问到类中的私有构造方法，显而易见Spring底层用的是Reflection\"]},{\"header\":\"步骤6:构造函数中添加一个参数测试\",\"slug\":\"步骤6-构造函数中添加一个参数测试\",\"contents\":[\"public class BookDaoImpl implements BookDao { private BookDaoImpl(int i) { System.out.println(\\\"book dao constructor is running ....\\\"); } public void save() { System.out.println(\\\"book dao save ...\\\"); } } \",\"运行程序，程序报错，说明Spring底层使用的是类的无参构造方法\"]},{\"header\":\"3.2.3 静态工厂实例化\",\"slug\":\"_3-2-3-静态工厂实例化\",\"contents\":[\"工厂方式创建bean:\",\"(1) 准备一个OrderDao和OrderDaoImpl类\",\"public interface OrderDao { public void save(); } public class OrderDaoImpl implements OrderDao { public void save() { System.out.println(\\\"order dao save ...\\\"); } } \",\"(2) 创建一个工厂类OrderDaoFactory并提供一个静态方法\",\"//静态工厂创建对象 public class OrderDaoFactory { public static OrderDao getOrderDao(){ return new OrderDaoImpl(); } } \",\"(3) 编写AppForInstanceOrder运行类，在类中通过工厂获取对象\",\"public class AppForInstanceOrder { public static void main(String[] args) { //通过静态工厂创建对象 OrderDao orderDao = OrderDaoFactory.getOrderDao(); orderDao.save(); } } \",\"(4) 运行后，可以查看到结果\",\"如果代码中对象是通过上面的这种方式来创建的，如何将其交给Spring来管理呢?\",\"这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为:\",\"(1) 在spring的配置文件application.properties中添加以下内容:\",\"<bean id=\\\"orderDao\\\" class=\\\"com.itheima.factory.OrderDaoFactory\\\" factory-method=\\\"getOrderDao\\\"/> \",\"class：工厂类的类全名\",\"factory-mehod：具体工厂类中创建对象的方法名\",\"对应关系如下图:\",\"(2) 在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试\",\"public class AppForInstanceOrder { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); OrderDao orderDao = (OrderDao) ctx.getBean(\\\"orderDao\\\"); orderDao.save(); } } \",\"(3) 运行后，可以查看到结果\",\"静态工厂的方式反而更复杂，这种方式的意义是什么?\",\"提示\",\"在工厂的静态方法中，除了new对象还可以做其他的一些业务操作，有些操作必不可少\",\"如果直接使用new是没法实现的，比如下面操作:\",\"public class OrderDaoFactory { public static OrderDao getOrderDao(){ System.out.println(\\\"factory setup....\\\");//模拟必要的业务操作 return new OrderDaoImpl(); } } \",\"重新运行，查看结果:\",\"静态工厂的实例化一般是用来兼容早期的一些系统中对象的创建，了解为主\"]},{\"header\":\"3.2.4 实例工厂与FactoryBean\",\"slug\":\"_3-2-4-实例工厂与factorybean\",\"contents\":[\"环境准备:\",\"(1) 准备一个UserDao和UserDaoImpl类\",\"public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\\\"user dao save ...\\\"); } } \",\"(2) 创建一个工厂类UserDaoFactory并提供一个普通方法，注意此处和静态工厂的工厂类不一样的地方是方法不是静态方法\",\"public class UserDaoFactory { public UserDao getUserDao(){ return new UserDaoImpl(); } } \",\"(3) 编写AppForInstanceUser运行类，在类中通过工厂获取对象\",\"public class AppForInstanceUser { public static void main(String[] args) { //创建实例工厂对象 UserDaoFactory userDaoFactory = new UserDaoFactory(); //通过实例工厂对象创建对象 UserDao userDao = userDaoFactory.getUserDao(); userDao.save(); } \",\"(4) 运行后，可以查看到结果\",\"对于上面这种实例工厂的方式如何交给Spring管理呢?\",\"这就要用到Spring中的实例工厂实例化的知识了，具体实现步骤为:\",\"(1) 在spring的配置文件application.properties中添加以下内容:\",\"<bean id=\\\"userFactory\\\" class=\\\"com.itheima.factory.UserDaoFactory\\\"/> <bean id=\\\"userDao\\\" factory-method=\\\"getUserDao\\\" factory-bean=\\\"userFactory\\\"/> \",\"实例化工厂运行的顺序是:\",\"创建实例化工厂对象，对应的是第一行配置\",\"调用对象中的方法来创建bean，对应的是第二行配置\",\"factory-bean：工厂的实例对象\",\"factory-method：工厂对象中的具体创建对象的方法名，对应关系如下:\",\"(2) 在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试\",\"public class AppForInstanceUser { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); UserDao userDao = (UserDao) ctx.getBean(\\\"userDao\\\"); userDao.save(); } } \",\"(3) 运行后，可以查看到结果\",\"配置的过程还是比较复杂，Spring为了简化这种配置方式提供了一种叫FactoryBean的方式来简化开发\",\"FactoryBean的使用:\",\"(1) 创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法\",\"public class UserDaoFactoryBean implements FactoryBean<UserDao> { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } //返回所创建类的Class对象 public Class<?> getObjectType() { return UserDao.class; } } \",\"(2) 在Spring的配置文件applicationConext.xml中进行配置\",\"<bean id=\\\"userDao\\\" class=\\\"com.itheima.factory.UserDaoFactoryBean\\\"/> \",\"(3) AppForInstanceUser运行类不用做任何修改，直接运行\",\"这种方式在Spring去整合其他框架的时候会被用到\",\"查看源码，Spring的FactoryBean接口其实会有三个方法，分别是:\",\"T getObject() throws Exception; Class<?> getObjectType(); default boolean isSingleton() { return true; } \",\"方法一: getObject()，被重写后，在方法中进行对象的创建并返回\",\"方法二: getObjectType()，被重写后，主要返回的是被创建类的Class对象\",\"方法三: 没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true\",\"public class AppForInstanceUser { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); UserDao userDao1 = (UserDao) ctx.getBean(\\\"userDao\\\"); UserDao userDao2 = (UserDao) ctx.getBean(\\\"userDao\\\"); System.out.println(userDao1); System.out.println(userDao2); } } \",\"改成非单例只需要将isSingleton()方法进行重写，修改返回为为false，即可\",\"//FactoryBean创建对象 public class UserDaoFactoryBean implements FactoryBean<UserDao> { //代替原始实例工厂中创建对象的方法 public UserDao getObject() throws Exception { return new UserDaoImpl(); } public Class<?> getObjectType() { return UserDao.class; } public boolean isSingleton() { return false; } } \",\"bean实例化小结\",\"bean是如何创建的呢?\",\"构造方法\",\"Spring的IOC实例化对象的三种方式分别是:\",\"构造方法(常用)\",\"静态工厂(了解)\",\"实例工厂(了解) \",\"FactoryBean(实用)\"]},{\"header\":\"3.3 bean的生命周期\",\"slug\":\"_3-3-bean的生命周期\",\"contents\":[\"bean生命周期是什么?\",\"bean对象从创建到销毁的整体过程\",\"bean的生命周期控制是什么?\",\"在bean创建后到销毁前做一些事情\"]},{\"header\":\"3.3.1 环境准备\",\"slug\":\"_3-3-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加依赖\",\"resources下添加spring的配置文件applicationContext.xml\",\"(1)项目中添加添加BookDao、BookDaoImpl、BookService和BookServiceImpl类\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\"); } } public interface BookService { public void save(); } public class BookServiceImpl implements BookService{ private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \",\"(2)resources下提供spring的配置文件，applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> </beans> \",\"(3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象\",\"public class AppForLifeCycle { public static void main( String[] args ) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); bookDao.save(); } } \"]},{\"header\":\"3.3.2 生命周期设置\",\"slug\":\"_3-3-2-生命周期设置\",\"contents\":[\"添加生命周期的控制方法\",\"bean创建之后，想要添加内容，比如用来初始化需要用到资源\",\"bean消亡之前，想要添加内容，比如用来释放用到的资源\"]},{\"header\":\"步骤1:添加初始化和销毁方法\",\"slug\":\"步骤1-添加初始化和销毁方法\",\"contents\":[\"针对这两个阶段，BookDaoImpl类中分别添加两个方法，方法名任意\",\"public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\"); } //表示bean初始化对应的操作 public void init(){ System.out.println(\\\"init...\\\"); } //表示bean销毁前对应的操作 public void destory(){ System.out.println(\\\"destory...\\\"); } } \"]},{\"header\":\"步骤2:配置生命周期\",\"slug\":\"步骤2-配置生命周期\",\"contents\":[\"在applicationContext.xml配置文件添加配置，如下:\",\"<bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\" init-method=\\\"init\\\" destroy-method=\\\"destory\\\"/> \"]},{\"header\":\"步骤3 运行程序\",\"slug\":\"步骤3-运行程序-1\",\"contents\":[\"init方法执行了，但是destroy方法却未执行，这是为什么呢?\",\"Spring的IOC容器是运行在JVM中\",\"运行main方法后，JVM启动，Spring加载配置文件生成IOC容器，从容器获取bean对象，然后调方法执行\",\"main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了\",\"所以没有调用对应的destroy方法\",\"解决方案有两种\"]},{\"header\":\"3.3.3 close关闭容器\",\"slug\":\"_3-3-3-close关闭容器\",\"contents\":[\"ApplicationContext中没有close方法\",\"需要将ApplicationContext更换成ClassPathXmlApplicationContext\",\"ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); \",\"调用ctx的close()方法\",\"ctx.close(); \",\"运行程序，就能执行destroy方法的内容\"]},{\"header\":\"3.3.4 注册钩子关闭容器\",\"slug\":\"_3-3-4-注册钩子关闭容器\",\"contents\":[\"在容器未关闭之前，提前设置好回调函数，让虚拟机在退出之前回调此函数来关闭容器\",\"调用ctx的registerShutdownHook()方法\",\"ctx.registerShutdownHook(); \",\"注意: registerShutdownHook在ApplicationContext中也没有\",\"运行后，查询打印结果\",\"相同点：这两种都能用来关闭容器\",\"不同点：close()是在调用的时候关闭，registerShutdownHook()是在JVM退出后关闭\",\"Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置init-method和destroy-method\",\"添加两个接口InitializingBeanDisposableBean并实现接口中的两个方法afterPropertiesSet和destroy\",\"public class BookServiceImpl implements BookService， InitializingBean， DisposableBean { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } public void destroy() throws Exception { System.out.println(\\\"service destroy\\\"); } public void afterPropertiesSet() throws Exception { System.out.println(\\\"service init\\\"); } } \",\"细节\",\"对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为属性设置之后\",\"对于BookServiceImpl来说，bookDao是它的一个属性\",\"setBookDao方法是Spring的IOC容器为其注入属性的方法\",\"思考:\",\"afterPropertiesSet和setBookDao谁先执行?\",\"从方法名分析，猜想应该是setBookDao方法先执行\",\"验证思路，在setBookDao方法中添加一句话\",\"public void setBookDao(BookDao bookDao) { System.out.println(\\\"set .....\\\"); this.bookDao = bookDao; } \",\"初始化方法会在类中属性设置之后执行\"]},{\"header\":\"3.3.5 bean生命周期小结\",\"slug\":\"_3-3-5-bean生命周期小结\",\"contents\":[\"关于Spring中对bean生命周期控制提供了两种方式:\",\"在配置文件中的bean标签中添加init-method和destroy-method属性\",\"类实现InitializingBean与DisposableBean接口\",\"对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:\",\"初始化容器\",\"1.创建对象(内存分配)\",\"2.执行构造方法\",\"3.执行属性注入(set操作)\",\"4.执行bean初始化方法\",\"使用bean\",\"1.执行业务操作\",\"关闭/销毁容器\",\"1.执行bean销毁方法\",\"关闭容器的两种方式:\",\"ConfigurableApplicationContext是ApplicationContext的子类 \",\"close()方法\",\"registerShutdownHook()方法\"]},{\"header\":\"4 DI相关内容\",\"slug\":\"_4-di相关内容\",\"contents\":[\"向一个类中传递数据的方式有几种?\",\"普通方法(set方法)\",\"构造方法\",\"依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?\",\"引用类型\",\"简单类型(基本数据类型与String)\",\"Spring就是基于上面这些知识点，提供了两种注入方式，分别是:\",\"setter注入 \",\"简单类型\",\"引用类型\",\"构造器注入 \",\"简单类型\",\"引用类型\"]},{\"header\":\"4.1 setter注入\",\"slug\":\"_4-1-setter注入\",\"contents\":[\"在bean中定义引用类型属性，并提供可访问的set方法\",\"public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } } \",\"配置中使用property标签ref属性注入引用类型对象\",\"<bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <property name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> </bean> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.imipl.BookDaoImpl\\\"/> \"]},{\"header\":\"4.1.1 环境准备\",\"slug\":\"_4-1-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加依赖\",\"resources下添加spring的配置文件applicationContext.xml\",\"(1)项目中添加添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\"); } } public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\\\"user dao save ...\\\"); } } public interface BookService { public void save(); } public class BookServiceImpl implements BookService{ private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \",\"(2) resources下提供spring的配置文件，applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <property name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> </bean> </beans> \",\"(3) 编写AppForDISet运行类，加载Spring的IOC容器，并从中获取对应的bean对象\",\"public class AppForDISet { public static void main( String[] args ) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookService bookService = (BookService) ctx.getBean(\\\"bookService\\\"); bookService.save(); } } \"]},{\"header\":\"4.1.2 注入引用数据类型\",\"slug\":\"_4-1-2-注入引用数据类型\",\"contents\":[\"需求: 在bookServiceImpl对象中引入userDao\",\"在BookServiceImpl中声明userDao属性\",\"为userDao属性提供setter方法\",\"在applicationContext.xml配置文件中使用property标签注入\"]},{\"header\":\"步骤1:声明属性并提供setter方法\",\"slug\":\"步骤1-声明属性并提供setter方法\",\"contents\":[\"在BookServiceImpl中声明userDao属性，并提供setter方法\",\"public class BookServiceImpl implements BookService{ private BookDao bookDao; private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); userDao.save(); } } \"]},{\"header\":\"步骤2:配置文件中进行注入配置\",\"slug\":\"步骤2-配置文件中进行注入配置\",\"contents\":[\"在applicationContext.xml配置文件中使用property标签注入\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <bean id=\\\"userDao\\\" class=\\\"com.itheima.dao.impl.UserDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <property name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> <property name=\\\"userDao\\\" ref=\\\"userDao\\\"/> </bean> </beans> \"]},{\"header\":\"步骤3 运行程序\",\"slug\":\"步骤3-运行程序-2\",\"contents\":[\"运行AppForDISet类，查看结果，说明userDao已经成功注入\"]},{\"header\":\"4.1.3 注入简单数据类型\",\"slug\":\"_4-1-3-注入简单数据类型\",\"contents\":[\"需求：给BookDaoImpl注入一些简单数据类型的数据\",\"参考引用数据类型的注入，可以推出具体的步骤为:\",\"在BookDaoImpl类中声明对应的简单数据类型的属性\",\"为这些属性提供对应的setter方法\",\"在applicationContext.xml中配置\",\"思考:\",\"引用类型使用的是<property name=\\\"\\\" ref=\\\"\\\"/>，简单数据类型还是使用ref么?\",\"ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置?\"]},{\"header\":\"步骤1: 声明属性并提供setter方法\",\"slug\":\"步骤1-声明属性并提供setter方法-1\",\"contents\":[\"在BookDaoImpl类中声明对应的简单数据类型的属性，并提供对应的setter方法\",\"public class BookDaoImpl implements BookDao { private String databaseName; private int connectionNum; public void setConnectionNum(int connectionNum) { this.connectionNum = connectionNum; } public void setDatabaseName(String databaseName) { this.databaseName = databaseName; } public void save() { System.out.println(\\\"book dao save ...\\\"+databaseName+\\\"，\\\"+connectionNum); } } \"]},{\"header\":\"步骤2: 配置文件中进行注入配置\",\"slug\":\"步骤2-配置文件中进行注入配置-1\",\"contents\":[\"在applicationContext.xml配置文件中使用property标签注入\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"> <property name=\\\"databaseName\\\" value=\\\"mysql\\\"/> <property name=\\\"connectionNum\\\" value=\\\"10\\\"/> </bean> <bean id=\\\"userDao\\\" class=\\\"com.itheima.dao.impl.UserDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <property name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> <property name=\\\"userDao\\\" ref=\\\"userDao\\\"/> </bean> </beans> \",\"说明:\",\"value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成\",\"<property name=\\\"connectionNum\\\" value=\\\"abc\\\"/> \",\"这样的话，spring在将abc转换成int类型的时候就会报错\"]},{\"header\":\"步骤3: 运行程序\",\"slug\":\"步骤3-运行程序-3\",\"contents\":[\"运行AppForDISet类，查看结果，说明userDao已经成功注入\",\"注意: 两个property注入标签的顺序可以任意\",\"对于引用数据类型使用的是<property name=\\\"\\\" ref=\\\"\\\"/> 对于简单数据类型使用的是<property name=\\\"\\\" value=\\\"\\\"/>\"]},{\"header\":\"4.2 构造器注入\",\"slug\":\"_4-2-构造器注入\",\"contents\":[]},{\"header\":\"4.2.1 环境准备\",\"slug\":\"_4-2-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加依赖\",\"resources下添加spring的配置文件applicationContext.xml\",\"(1)项目中添加添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { private String databaseName; private int connectionNum; public void save() { System.out.println(\\\"book dao save ...\\\"); } } public interface UserDao { public void save(); } public class UserDaoImpl implements UserDao { public void save() { System.out.println(\\\"user dao save ...\\\"); } } public interface BookService { public void save(); } public class BookServiceImpl implements BookService{ private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \",\"(2) resources下提供spring的配置文件，applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <property name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> </bean> </beans> \",\"(3) 编写AppForDIConstructor运行类，加载Spring的IOC容器，并从中获取对应的bean对象\",\"public class AppForDIConstructor { public static void main( String[] args ) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookService bookService = (BookService) ctx.getBean(\\\"bookService\\\"); bookService.save(); } } \"]},{\"header\":\"4.2.2 构造器注入引用数据类型\",\"slug\":\"_4-2-2-构造器注入引用数据类型\",\"contents\":[\"需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入\",\"将bookDao的setter方法删除掉\",\"添加带有bookDao参数的构造方法\",\"在applicationContext.xml中配置\"]},{\"header\":\"步骤1:删除setter方法并提供构造方法\",\"slug\":\"步骤1-删除setter方法并提供构造方法\",\"contents\":[\"在BookServiceImpl类中将bookDao的setter方法删除掉，并添加带有bookDao参数的构造方法\",\"public class BookServiceImpl implements BookService{ private BookDao bookDao; public BookServiceImpl(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \"]},{\"header\":\"步骤2:配置文件中进行配置构造方式注入\",\"slug\":\"步骤2-配置文件中进行配置构造方式注入\",\"contents\":[\"在applicationContext.xml中配置\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <constructor-arg name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> </bean> </beans> \",\"说明\",\"标签<constructor-arg>中\",\"name属性对应的值为构造函数中方法形参的参数名，必须要保持一致\",\"ref属性指向的是spring的IOC容器中其他bean对象\"]},{\"header\":\"步骤3：运行程序\",\"slug\":\"步骤3-运行程序-4\",\"contents\":[\"运行AppForDIConstructor类，查看结果，说明bookDao已经成功注入\"]},{\"header\":\"4.2.3 构造器注入多个引用数据类型\",\"slug\":\"_4-2-3-构造器注入多个引用数据类型\",\"contents\":[\"需求: 在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao\",\"声明userDao属性\",\"生成一个带有bookDao和userDao参数的构造函数\",\"在applicationContext.xml中配置注入\"]},{\"header\":\"步骤1:提供多个属性与构造函数\",\"slug\":\"步骤1-提供多个属性与构造函数\",\"contents\":[\"在BookServiceImpl声明userDao并提供多个参数的构造函数\",\"public class BookServiceImpl implements BookService{ private BookDao bookDao; private UserDao userDao; public BookServiceImpl(BookDao bookDao，UserDao userDao) { this.bookDao = bookDao; this.userDao = userDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); userDao.save(); } } \",\"步骤2:配置文件中配置多个构造方式注入\",\"在applicationContext.xml中配置注入\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <bean id=\\\"userDao\\\" class=\\\"com.itheima.dao.impl.UserDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <constructor-arg name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> <constructor-arg name=\\\"userDao\\\" ref=\\\"userDao\\\"/> </bean> </beans> \",\"说明: 这两个<contructor-arg>的配置顺序可以任意\",\"步骤3:运行程序\",\"运行AppForDIConstructor类，查看结果，说明userDao已经成功注入\"]},{\"header\":\"4.2.4 构造器注入多个简单数据类型\",\"slug\":\"_4-2-4-构造器注入多个简单数据类型\",\"contents\":[\"需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数\",\"参考引用数据类型的注入，可以推出具体的步骤为:\",\"提供一个包含这两个参数的构造方法\",\"在applicationContext.xml中进行注入配置\"]},{\"header\":\"步骤1:添加多个简单属性并提供构造方法\",\"slug\":\"步骤1-添加多个简单属性并提供构造方法\",\"contents\":[\"修改BookDaoImpl类，添加构造方法\",\"public class BookDaoImpl implements BookDao { private String databaseName; private int connectionNum; public BookDaoImpl(String databaseName， int connectionNum) { this.databaseName = databaseName; this.connectionNum = connectionNum; } public void save() { System.out.println(\\\"book dao save ...\\\"+databaseName+\\\"，\\\"+connectionNum); } } \"]},{\"header\":\"步骤2:配置完成多个属性构造器注入\",\"slug\":\"步骤2-配置完成多个属性构造器注入\",\"contents\":[\"在applicationContext.xml中进行注入配置\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"> <constructor-arg name=\\\"databaseName\\\" value=\\\"mysql\\\"/> <constructor-arg name=\\\"connectionNum\\\" value=\\\"666\\\"/> </bean> <bean id=\\\"userDao\\\" class=\\\"com.itheima.dao.impl.UserDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <constructor-arg name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> <constructor-arg name=\\\"userDao\\\" ref=\\\"userDao\\\"/> </bean> </beans> \",\"说明: 这两个<contructor-arg>的配置顺序可以任意\",\"步骤3:运行程序\",\"运行AppForDIConstructor类，查看结果\",\"会存在一些问题:\",\"当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变\",\"这两块存在紧耦合，具体该如何解决?\",\"在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，都以了解为主\",\"方式一： 删除name属性，添加type属性，按照类型注入\",\"<bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"> <constructor-arg type=\\\"int\\\" value=\\\"10\\\"/> <constructor-arg type=\\\"java.lang.String\\\" value=\\\"mysql\\\"/> </bean> \",\"这种方式可以解决构造函数形参名发生变化带来的耦合问题\",\"但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了\",\"方式二： 删除type属性，添加index属性，按照索引下标注入，下标从0开始\",\"<bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"> <constructor-arg index=\\\"1\\\" value=\\\"100\\\"/> <constructor-arg index=\\\"0\\\" value=\\\"mysql\\\"/> </bean> \",\"这种方式可以解决参数类型重复问题\",\"但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题\",\"两种参数的注入方式，具体如何选择?\",\"强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现\",\"强制依赖指对象在创建的过程中必须要注入指定的参数\",\"可选依赖使用setter注入进行，灵活性强\",\"可选依赖指对象在创建过程中注入的参数可有可无\",\"Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨\",\"如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入\",\"实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入\",\"自己开发的模块推荐使用setter注入\",\"总结：\",\"setter注入\",\"简单数据类型\",\"<bean ...> <property name=\\\"\\\" value=\\\"\\\"/> </bean> \",\"引用数据类型\",\"<bean ...> <property name=\\\"\\\" ref=\\\"\\\"/> </bean> \",\"构造器注入\",\"简单数据类型\",\"<bean ...> <constructor-arg name=\\\"\\\" index=\\\"\\\" type=\\\"\\\" value=\\\"\\\"/> </bean> \",\"引用数据类型\",\"<bean ...> <constructor-arg name=\\\"\\\" index=\\\"\\\" type=\\\"\\\" ref=\\\"\\\"/> </bean> \"]},{\"header\":\"4.3 自动配置\",\"slug\":\"_4-3-自动配置\",\"contents\":[]},{\"header\":\"4.3.1 什么是依赖自动装配?\",\"slug\":\"_4-3-1-什么是依赖自动装配\",\"contents\":[\"IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配\"]},{\"header\":\"4.3.2 自动装配方式有哪些?\",\"slug\":\"_4-3-2-自动装配方式有哪些\",\"contents\":[\"按类型\",\"按名称\",\"按构造方法\",\"不启用自动装配\"]},{\"header\":\"4.3.3 准备下案例环境\",\"slug\":\"_4-3-3-准备下案例环境\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加依赖\",\"resources下添加spring的配置文件applicationContext.xml\",\"(1)项目中添加添加BookDao、BookDaoImpl、BookService和BookServiceImpl类\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { private String databaseName; private int connectionNum; public void save() { System.out.println(\\\"book dao save ...\\\"); } } public interface BookService { public void save(); } public class BookServiceImpl implements BookService{ private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \",\"(2)resources下提供spring的配置文件，applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\"> <property name=\\\"bookDao\\\" ref=\\\"bookDao\\\"/> </bean> </beans> \",\"(3)编写AppForAutoware运行类，加载Spring的IOC容器，并从中获取对应的bean对象\",\"public class AppForAutoware { public static void main( String[] args ) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookService bookService = (BookService) ctx.getBean(\\\"bookService\\\"); bookService.save(); } } \"]},{\"header\":\"4.3.4 完成自动装配的配置\",\"slug\":\"_4-3-4-完成自动装配的配置\",\"contents\":[\"自动装配只需要修改applicationContext.xml配置文件即可:\",\"(1) 将<property>标签删除\",\"(2) 在<bean>标签中添加autowire属性\",\"首先实现按照类型注入的配置\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <!--autowire属性：开启自动装配，通常使用按类型装配--> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\" autowire=\\\"byType\\\"/> </beans> \",\"注意事项\",\"需要注入属性的类中对应属性的setter方法不能省略\",\"被注入的对象必须要被Spring的IOC容器管理\",\"按照类型在Spring的IOC容器中如果找到多个对象，会报NoUniqueBeanDefinitionException\",\"一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> <!--autowire属性：开启自动装配，通常使用按类型装配--> <bean id=\\\"bookService\\\" class=\\\"com.itheima.service.impl.BookServiceImpl\\\" autowire=\\\"byName\\\"/> </beans> \",\"注意事项:\",\"按照名称注入中的名称指的是什么?\",\"bookDao是private修饰的，外部类无法直接方法\",\"外部类只能通过属性的set方法进行访问\",\"对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名 \",\"为什么是去掉set首字母小写?\",\"这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名\",\"所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的\",\"如果按照名称去找对应的bean对象，找不到则注入Null\",\"当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错\",\"注意\",\"自动装配用于引用类型依赖注入，不能对简单类型进行操作\",\"使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用\",\"使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用\",\"自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效\"]},{\"header\":\"4.4 集合注入\",\"slug\":\"_4-4-集合注入\",\"contents\":[\"数组\",\"List\",\"Set\",\"Map\",\"Properties\",\"针对不同的集合类型，该如何实现注入呢?\"]},{\"header\":\"4.4.1 环境准备\",\"slug\":\"_4-4-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加依赖\",\"resources下添加spring的配置文件applicationContext.xml\",\"(1) 项目中添加添加BookDao、BookDaoImpl类\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { private int[] array; private List<String> list; private Set<String> set; private Map<String，String> map; private Properties properties; public void save() { System.out.println(\\\"book dao save ...\\\"); System.out.println(\\\"遍历数组:\\\" + Arrays.toString(array)); System.out.println(\\\"遍历List\\\" + list); System.out.println(\\\"遍历Set\\\" + set); System.out.println(\\\"遍历Map\\\" + map); System.out.println(\\\"遍历Properties\\\" + properties); } //setter....方法省略，自己使用工具生成 } \",\"(2) resources下提供spring的配置文件，applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> </beans> \",\"(3) 编写AppForDICollection运行类，加载Spring的IOC容器，并从中获取对应的bean对象\",\"public class AppForDICollection { public static void main( String[] args ) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); bookDao.save(); } } \",\"下面的所有配置方式，都是在bookDao的bean标签中使用<property>进行注入\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"> </bean> </beans> \"]},{\"header\":\"4.4.2 注入数组类型数据\",\"slug\":\"_4-4-2-注入数组类型数据\",\"contents\":[\"<property name=\\\"array\\\"> <array> <value>100</value> <value>200</value> <value>300</value> </array> </property> \"]},{\"header\":\"4.4.3 注入List类型数据\",\"slug\":\"_4-4-3-注入list类型数据\",\"contents\":[\"<property name=\\\"list\\\"> <list> <value>itcast</value> <value>itheima</value> <value>boxuegu</value> <value>chuanzhihui</value> </list> </property> \"]},{\"header\":\"4.4.4 注入Set类型数据\",\"slug\":\"_4-4-4-注入set类型数据\",\"contents\":[\"<property name=\\\"set\\\"> <set> <value>itcast</value> <value>itheima</value> <value>boxuegu</value> <value>boxuegu</value> </set> </property> \"]},{\"header\":\"4.4.5 注入Map类型数据\",\"slug\":\"_4-4-5-注入map类型数据\",\"contents\":[\"<property name=\\\"map\\\"> <map> <entry key=\\\"country\\\" value=\\\"china\\\"/> <entry key=\\\"province\\\" value=\\\"henan\\\"/> <entry key=\\\"city\\\" value=\\\"kaifeng\\\"/> </map> </property> \"]},{\"header\":\"4.4.6 注入Properties类型数据\",\"slug\":\"_4-4-6-注入properties类型数据\",\"contents\":[\"<property name=\\\"properties\\\"> <props> <prop key=\\\"country\\\">china</prop> <prop key=\\\"province\\\">henan</prop> <prop key=\\\"city\\\">kaifeng</prop> </props> </property> \",\"配置完成后，运行下看结果:\",\"说明\",\"property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<array>、<list>、<set>、<map>、<props>标签\",\"List的底层也是通过数组实现的，所以<list>和<array>标签是可以混用\",\"集合中要添加引用类型，只需要把<value>标签改成<ref>标签，这种方式用的比较少\"]}]},\"/BackEnd/Spring/spring02.html\":{\"title\":\"Spring IOC DI 注解开发\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"掌握 IOC/DI 配置管理第三方bean\",\"掌握 IOC/DI 的注解开发\",\"掌握 IOC/DI 注解管理第三方bean\",\"完成Spring与Mybatis及Junit的整合开发\"]},{\"header\":\"1 IOC/DI 配置管理第三方bean\",\"slug\":\"_1-ioc-di-配置管理第三方bean\",\"contents\":[]},{\"header\":\"1.1 案例：数据源对象管理\",\"slug\":\"_1-1-案例-数据源对象管理\",\"contents\":[\"通过数据源Druid(德鲁伊)和C3P0来配置学习\"]},{\"header\":\"1.1.1 环境准备\",\"slug\":\"_1-1-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> \",\"resources下添加spring的配置文件applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> </beans> \",\"编写一个运行类App\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); } } \"]},{\"header\":\"1.1.2 思路分析\",\"slug\":\"_1-1-2-思路分析\",\"contents\":[\"需求：在Spring的IOC容器中对Druid数据连接池进行管理\",\"使用第三方的技术，需要在pom.xml添加依赖\",\"在applicationContext.xml配置文件中将【第三方的类】制作成一个bean，让IOC容器进行管理\",\"数据库连接需要基础的四要素驱动、连接、用户名和密码，【如何注入】到对应的bean中\",\"从IOC容器中获取对应的bean对象，将其打印到控制台查看结果\"]},{\"header\":\"1.1.3 实现Druid管理\",\"slug\":\"_1-1-3-实现druid管理\",\"contents\":[]},{\"header\":\"步骤1:导入 druid 的依赖\",\"slug\":\"步骤1-导入druid的依赖\",\"contents\":[\"pom.xml中添加依赖\",\"<dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> \"]},{\"header\":\"步骤2:配置第三方bean\",\"slug\":\"步骤2-配置第三方bean\",\"contents\":[\"在applicationContext.xml配置文件中添加DruidDataSource的配置\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <!--管理DruidDataSource对象--> <bean id=\\\"dataSource\\\" class=\\\"com.alibaba.druid.pool.DruidDataSource\\\"> <property name=\\\"driverClassName\\\" value=\\\"com.mysql.jdbc.Driver\\\"/> <property name=\\\"url\\\" value=\\\"jdbc:mysql://localhost:3306/spring_db\\\"/> <property name=\\\"username\\\" value=\\\"root\\\"/> <property name=\\\"password\\\" value=\\\"root\\\"/> </bean> </beans> \",\"说明\",\"driverClassName：数据库驱动\",\"url：数据库连接地址\",\"username：数据库连接用户名\",\"password：数据库连接密码\",\"数据库连接的四要素要和自己使用的数据库信息一致\"]},{\"header\":\"步骤3:从IOC容器中获取对应的bean对象\",\"slug\":\"步骤3-从ioc容器中获取对应的bean对象\",\"contents\":[\"public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); DataSource dataSource = (DataSource) ctx.getBean(\\\"dataSource\\\"); System.out.println(dataSource); } } \"]},{\"header\":\"步骤4:运行程序\",\"slug\":\"步骤4-运行程序\",\"contents\":[\"打印如下结果: 说明第三方bean对象已经被spring的IOC容器进行管理\",\"说明\",\"第三方的类指的是什么?\",\"DruidDataSource\",\"如何注入数据库连接四要素?\",\"setter注入\"]},{\"header\":\"1.1.4 实现C3P0管理\",\"slug\":\"_1-1-4-实现c3p0管理\",\"contents\":[\"需求：在Spring的IOC容器中对C3P0数据连接池进行管理\",\"重点关注管理的是哪个bean对象?\"]},{\"header\":\"步骤1:导入 C3P0 的依赖\",\"slug\":\"步骤1-导入c3p0的依赖\",\"contents\":[\"pom.xml中添加依赖\",\"<dependency> <groupId>c3p0</groupId> <artifactId>c3p0</artifactId> <version>0.9.1.2</version> </dependency> \",\"对于新的技术，不指定具体的坐标该如何查找?\",\"从mvn的仓库https://mvnrepository.com/中进行搜索\"]},{\"header\":\"步骤2: 配置第三方bean\",\"slug\":\"步骤2-配置第三方bean-1\",\"contents\":[\"在applicationContext.xml配置文件中添加配置\",\"<bean id=\\\"dataSource\\\" class=\\\"com.mchange.v2.c3p0.ComboPooledDataSource\\\"> <property name=\\\"driverClass\\\" value=\\\"com.mysql.jdbc.Driver\\\"/> <property name=\\\"jdbcUrl\\\" value=\\\"jdbc:mysql://localhost:3306/spring_db\\\"/> <property name=\\\"user\\\" value=\\\"root\\\"/> <property name=\\\"password\\\" value=\\\"root\\\"/> <property name=\\\"maxPoolSize\\\" value=\\\"1000\\\"/> </bean> \",\"注意\",\"ComboPooledDataSource的属性是通过setter方式进行注入\",\"四个setter属性就要求在ComboPooledDataSource类或其上层类中有提供属性对应的setter方法\",\"C3P0的四个属性和Druid的四个属性是不一样的\"]},{\"header\":\"步骤3:运行程序\",\"slug\":\"步骤3-运行程序\",\"contents\":[\"程序会报错，错误如下\",\"报的错为ClassNotFoundException，具体的类为com.mysql.jdbc.Driver\",\"原因是缺少mysql的驱动包\",\"<dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.47</version> </dependency> \",\"注意\",\"数据连接池在配置属性的时候，除了可以注入数据库连接四要素外还可以配置很多其他的属性，具体都有哪些属性用到的时候再去查，一般配置基础的四个，其他都有自己的默认值\",\"Druid和C3P0在没有导入mysql驱动包的前提下，一个没报错一个报错，说明Druid在初始化的时候没有去加载驱动，而C3P0刚好相反\",\"Druid启动虽然没有报错，但是当调用DruidDataSource的getConnection()方法获取连接的时候，也会报找不到驱动类的错误\"]},{\"header\":\"1.2 加载properties文件\",\"slug\":\"_1-2-加载properties文件\",\"contents\":[\"上节两个数据源druid和C3P0的配置，其中包含一些问题\",\"这两个数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护\",\"需要将这些值提取到一个外部的properties配置文件中\",\"提取到properties配置文件后，Spring框架如何将其加载后并设置进去\"]},{\"header\":\"1.2.1 第三方bean属性优化\",\"slug\":\"_1-2-1-第三方bean属性优化\",\"contents\":[]},{\"header\":\"1.2.1.1 实现思路\",\"slug\":\"_1-2-1-1-实现思路\",\"contents\":[\"需求：将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入\",\"在resources下创建一个jdbc.properties(文件的名称可以任意)\",\"将数据库连接四要素配置到配置文件中\",\"在Spring的配置文件中加载properties文件(重点)\",\"使用加载到的值实现属性注入(重点)\"]},{\"header\":\"1.2.1.2 实现步骤\",\"slug\":\"_1-2-1-2-实现步骤\",\"contents\":[]},{\"header\":\"步骤1:准备properties配置文件\",\"slug\":\"步骤1-准备properties配置文件\",\"contents\":[\"resources下创建一个jdbc.properties文件,并添加对应的属性键值对\",\"jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db jdbc.username=root jdbc.password=root \"]},{\"header\":\"步骤2:开启 context 命名空间\",\"slug\":\"步骤2-开启context命名空间\",\"contents\":[\"在applicationContext.xml中开context命名空间\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> </beans> \"]},{\"header\":\"步骤3:加载properties配置文件\",\"slug\":\"步骤3-加载properties配置文件\",\"contents\":[\"在配置文件中使用context命名空间下的标签来加载properties配置文件\",\"<context:property-placeholder location=\\\"jdbc.properties\\\"/> \"]},{\"header\":\"步骤4:完成属性注入\",\"slug\":\"步骤4-完成属性注入\",\"contents\":[\"使用${key}来读取properties配置文件中的内容并完成属性注入\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <context:property-placeholder location=\\\"jdbc.properties\\\"/> <bean id=\\\"dataSource\\\" class=\\\"com.alibaba.druid.pool.DruidDataSource\\\"> <property name=\\\"driverClassName\\\" value=\\\"${jdbc.driver}\\\"/> <property name=\\\"url\\\" value=\\\"${jdbc.url}\\\"/> <property name=\\\"username\\\" value=\\\"${jdbc.username}\\\"/> <property name=\\\"password\\\" value=\\\"${jdbc.password}\\\"/> </bean> </beans> \",\"至此，读取外部properties配置文件中的内容完成，但是上面的数据源配置是不是从properties中拿到数据并注入呢?\"]},{\"header\":\"1.2.2 读取单个属性\",\"slug\":\"_1-2-2-读取单个属性\",\"contents\":[]},{\"header\":\"1.2.2.1 实现思路\",\"slug\":\"_1-2-2-1-实现思路\",\"contents\":[\"对于上面的案例，效果不是很明显，换个案例来演示下:\",\"需求：从properties配置文件中读取key为name的值，并将其注入到BookDao中并在save方法中进行打印\",\"在项目中添加BookDao和BookDaoImpl类\",\"为BookDaoImpl添加一个name属性并提供setter方法\",\"将jdbc.properties中添加数据注入到bookDao中打印方便查询效果\",\"在applicationContext.xml添加配置完成配置文件加载、属性注入(${key})\"]},{\"header\":\"1.2.2.2 实现步骤\",\"slug\":\"_1-2-2-2-实现步骤\",\"contents\":[]},{\"header\":\"步骤1:在项目中添对应的类\",\"slug\":\"步骤1-在项目中添对应的类\",\"contents\":[\"BookDao和BookDaoImpl类，并再BookDaoImpl类中添加name属性与setter方法\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { private String name; public void setName(String name) { this.name = name; } public void save() { System.out.println(\\\"book dao save ...\\\" + name); } } \"]},{\"header\":\"步骤2:完成配置文件的读取与注入\",\"slug\":\"步骤2-完成配置文件的读取与注入\",\"contents\":[\"在applicationContext.xml添加配置，bean的配置管理、读取外部properties、依赖注入:\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <context:property-placeholder location=\\\"jdbc.properties\\\"/> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"> <property name=\\\"name\\\" value=\\\"${jdbc.driver}\\\"/> </bean> </beans> \"]},{\"header\":\"步骤3: 运行程序\",\"slug\":\"步骤3-运行程序-1\",\"contents\":[\"在App类中，从IOC容器中获取bookDao对象，调用方法，查看值是否已经被获取到并打印控制台\",\"public class App { public static void main(String[] args) throws Exception{ ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); bookDao.save(); } } \"]},{\"header\":\"1.2.2.3 注意事项\",\"slug\":\"_1-2-2-3-注意事项\",\"contents\":[\"问题一:键值对的key为username引发的问题\",\"1.在properties中配置键值对的时候，如果key设置为username\",\"username=root666 \",\"2.在applicationContext.xml注入该属性\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <context:property-placeholder location=\\\"jdbc.properties\\\"/> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"> <property name=\\\"name\\\" value=\\\"${username}\\\"/> </bean> </beans> \",\"3.运行后，在控制台打印的却不是root666，而是自己电脑的用户名\",\"4.出现问题的原因是<context:property-placeholder/>标签会加载系统的环境变量，而且环境变量的值会被优先加载，如何查看系统的环境变量?\",\"public static void main(String[] args) throws Exception{ Map<String, String> env = System.getenv(); System.out.println(env); } \",\"5.解决方案\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <context:property-placeholder location=\\\"jdbc.properties\\\" system-properties-mode=\\\"NEVER\\\"/> </beans> \",\"system-properties-mode：设置为NEVER，表示不加载系统属性\",\"问题二:当有多个properties配置文件需要被加载，该如何配置?\",\"1.配置文件\",\"jdbc.properties\",\"jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db jdbc.username=root jdbc.password=root \",\"jdbc2.properties\",\"username=root666 \",\"2.修改applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:context=\\\"http://www.springframework.org/schema/context\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\\\"> <!--方式一 --> <context:property-placeholder location=\\\"jdbc.properties,jdbc2.properties\\\" system-properties-mode=\\\"NEVER\\\"/> <!--方式二--> <context:property-placeholder location=\\\"*.properties\\\" system-properties-mode=\\\"NEVER\\\"/> <!--方式三 --> <context:property-placeholder location=\\\"classpath:*.properties\\\" system-properties-mode=\\\"NEVER\\\"/> <!--方式四--> <context:property-placeholder location=\\\"classpath*:*.properties\\\" system-properties-mode=\\\"NEVER\\\"/> </beans> \",\"说明\",\"方式一：可以实现，如果配置文件多的话，每个都需要配置\",\"方式二：*.properties代表所有以properties结尾的文件都会被加载，可以解决方式一的问题，但是不标准\",\"方式三：标准的写法，classpath:代表的是从根路径下开始查找，但是只能查询当前项目的根路径\",\"方式四：不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件\"]},{\"header\":\"1.2.3 加载properties文件小结\",\"slug\":\"_1-2-3-加载properties文件小结\",\"contents\":[\"如何开启context命名空间\",\"如何加载properties配置文件\",\"<context:property-placeholder location=\\\"\\\" system-properties-mode=\\\"NEVER\\\"/> \",\"如何在applicationContext.xml引入properties配置文件中的值\",\"${key} \"]},{\"header\":\"2 核心容器\",\"slug\":\"_2-核心容器\",\"contents\":[\"如何创建容器?\",\"创建好容器后，如何从容器中获取bean对象\",\"容器类的层次结构是什么?\",\"BeanFactory是什么?\"]},{\"header\":\"2.1 环境准备\",\"slug\":\"_2-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring的依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> \",\"resources下添加applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> </beans> \",\"添加BookDao和BookDaoImpl类\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\" ); } } \",\"创建运行类App\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); bookDao.save(); } } \"]},{\"header\":\"2.2 容器\",\"slug\":\"_2-2-容器\",\"contents\":[]},{\"header\":\"2.2.1 容器的创建方式\",\"slug\":\"_2-2-1-容器的创建方式\",\"contents\":[\"案例中创建ApplicationContext的方式为:\",\"ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); \",\"这种方式翻译为:类路径下的XML配置文件\",\"ApplicationContext ctx = new FileSystemXmlApplicationContext(\\\"applicationContext.xml\\\"); \",\"这种方式翻译为:文件系统下的XML配置文件\",\"从错误信息中能发现，这种方式是从项目路径下开始查找applicationContext.xml配置文件的\",\"ApplicationContext ctx = new FileSystemXmlApplicationContext(\\\"D:\\\\\\\\workspace\\\\\\\\spring\\\\\\\\spring_10_container\\\\\\\\src\\\\\\\\main\\\\\\\\resources\\\\\\\\applicationContext.xml\\\"); \",\"耦合度较高，不推荐使用\"]},{\"header\":\"2.2.2 Bean的三种获取方式\",\"slug\":\"_2-2-2-bean的三种获取方式\",\"contents\":[\"方式一:\",\"BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); \",\"方式二：\",\"BookDao bookDao = ctx.getBean(\\\"bookDao\\\",BookDao.class); \",\"方式三:\",\"BookDao bookDao = ctx.getBean(BookDao.class); \",\"这种方式类似依赖注入中的按类型注入，必须要确保IOC容器中该类型对应的bean对象只能有一个\"]},{\"header\":\"2.2.3 容器类层次结构\",\"slug\":\"_2-2-3-容器类层次结构\",\"contents\":[\"(1)在IDEA中双击shift,输入BeanFactory\",\"(2)点击进入BeanFactory类，ctrl+h，就能查看到如下结构的层次关系\",\"从图中可以看出，容器类也是从无到有根据需要一层层叠加上来的\"]},{\"header\":\"2.2.4 BeanFactory的使用\",\"slug\":\"_2-2-4-beanfactory的使用\",\"contents\":[\"使用BeanFactory来创建IOC容器的具体实现方式为:\",\"public class AppForBeanFactory { public static void main(String[] args) { Resource resources = new ClassPathResource(\\\"applicationContext.xml\\\"); BeanFactory bf = new XmlBeanFactory(resources); BookDao bookDao = bf.getBean(BookDao.class); bookDao.save(); } } \",\"为了更好的看出BeanFactory和ApplicationContext之间的区别，在BookDaoImpl添加如下构造函数:\",\"public class BookDaoImpl implements BookDao { public BookDaoImpl() { System.out.println(\\\"constructor\\\"); } public void save() { System.out.println(\\\"book dao save ...\\\" ); } } \",\"如果不去获取bean对象，打印会发现：\",\"BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建\",\"ApplicationContext是立即加载，容器加载的时候就会创建bean对象\",\"ApplicationContext要想成为延迟加载，只需要修改配置文件为\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\" lazy-init=\\\"true\\\"/> </beans> \",\"小结:\",\"容器创建的两种方式\",\"ClassPathXmlApplicationContext \",\"FileSystemXmlApplicationContext \",\"获取Bean的三种方式\",\"getBean(\\\"名称\\\"):需要类型转换\",\"getBean(\\\"名称\\\",类型.class):多了一个参数\",\"getBean(类型.class):容器中不能有多个该类的bean对象\",\"上述三种方式，各有各的优缺点，用哪个都可以\",\"容器类层次结构\",\"最上级的父接口为 BeanFactory\",\"BeanFactory | ApplicationContext\",\"使用BeanFactory创建的容器是延迟加载\",\"使用ApplicationContext创建的容器是立即加载\"]},{\"header\":\"2.2 核心容器总结\",\"slug\":\"_2-2-核心容器总结\",\"contents\":[]},{\"header\":\"2.2.1 容器相关\",\"slug\":\"_2-2-1-容器相关\",\"contents\":[\"BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载\",\"ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载\",\"ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能\",\"ApplicationContext接口常用初始化类 \",\"ClassPathXmlApplicationContext(常用)\",\"FileSystemXmlApplicationContext\"]},{\"header\":\"2.2.2 bean相关\",\"slug\":\"_2-2-2-bean相关\",\"contents\":[\"其实整个配置中最常用的就两个属性id和class\"]},{\"header\":\"2.2.3 依赖注入相关\",\"slug\":\"_2-2-3-依赖注入相关\",\"contents\":[]},{\"header\":\"3 IOC/DI注解开发\",\"slug\":\"_3-ioc-di注解开发\",\"contents\":[\"Spring对注解支持的版本历程\",\"2.0版开始支持注解\",\"2.5版注解功能趋于完善\",\"3.0版支持纯注解开发\",\"注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解\"]},{\"header\":\"3.1 环境准备\",\"slug\":\"_3-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring的依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> \",\"resources下添加applicationContext.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> </beans> \",\"添加BookDao、BookDaoImpl、BookService、BookServiceImpl类\",\"public interface BookDao { public void save(); } public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\" ); } } public interface BookService { public void save(); } public class BookServiceImpl implements BookService { public void save() { System.out.println(\\\"book service save ...\\\"); } } \",\"创建运行类App\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); bookDao.save(); } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"3.2 注解开发定义bean\",\"slug\":\"_3-2-注解开发定义bean\",\"contents\":[]},{\"header\":\"步骤1:删除原XML配置\",\"slug\":\"步骤1-删除原xml配置\",\"contents\":[\"将配置文件中的<bean>标签删除掉\",\"<bean id=\\\"bookDao\\\" class=\\\"com.itheima.dao.impl.BookDaoImpl\\\"/> \"]},{\"header\":\"步骤2:Dao上添加注解\",\"slug\":\"步骤2-dao上添加注解\",\"contents\":[\"在BookDaoImpl类上添加@Component注解\",\"@Component(\\\"bookDao\\\") public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\" ); } } \",\"注意：@Component注解不可以添加在接口上，因为接口是无法创建对象的\",\"XML与注解配置的对应关系:\"]},{\"header\":\"步骤3:配置Spring的注解包扫描\",\"slug\":\"步骤3-配置spring的注解包扫描\",\"contents\":[\"为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <beans xmlns=\\\"http://www.springframework.org/schema/beans\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\\\"> <context:component-scan base-package=\\\"com.itheima\\\"/> </beans> \",\"component-scan\",\"component：组件，Spring将管理的bean视作自己的一个组件\",\"scan：扫描\",\"base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解\",\"包路径越多 [如:com.itheima.dao.impl] ，扫描的范围越小速度越快\",\"包路径越少 [如:com.itheima] ，扫描的范围越大速度越慢\",\"一般扫描到项目的组织名称即Maven的groupId下 [如:com.itheima] 即可\"]},{\"header\":\"步骤4：运行程序\",\"slug\":\"步骤4-运行程序-1\",\"contents\":[\"运行App类查看打印结果\"]},{\"header\":\"步骤5:Service上添加注解\",\"slug\":\"步骤5-service上添加注解\",\"contents\":[\"在BookServiceImpl类上也添加@Component交给Spring框架管理\",\"@Component public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \"]},{\"header\":\"步骤6:运行程序\",\"slug\":\"步骤6-运行程序\",\"contents\":[\"在App类中，从IOC容器中获取BookServiceImpl对应的bean对象，打印\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); System.out.println(bookDao); //按类型获取bean BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } \",\"说明:\",\"BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象\",\"@Component注解如果不起名称，会有一个默认值就是当前类名首字母小写，所以也可以按照名称获取，如\",\"BookService bookService = (BookService)ctx.getBean(\\\"bookServiceImpl\\\"); System.out.println(bookService); \",\"对于@Component注解，还衍生出了其他三个注解@Controller、@Service、@Repository\",\"通过查看源码会发现:\",\"这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢?\",\"方便后期在编写类的时候能很好的区分出这个类是属于表现层、业务层还是数据层的类\"]},{\"header\":\"知识点1:@Component等\",\"slug\":\"知识点1-component等\",\"contents\":[\"名称\",\"@Component/@Controller/@Service/@Repository\",\"类型\",\"类注解\",\"位置\",\"类定义上方\",\"作用\",\"设置该类为spring管理的bean\",\"属性\",\"value（默认）：定义bean的id\"]},{\"header\":\"3.3 纯注解开发模式\",\"slug\":\"_3-3-纯注解开发模式\",\"contents\":[\"Spring3.0开启了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道\"]},{\"header\":\"3.3.1 思路分析\",\"slug\":\"_3-3-1-思路分析\",\"contents\":[\"将配置文件applicationContext.xml删除掉，使用类来替换\"]},{\"header\":\"3.3.2 实现步骤\",\"slug\":\"_3-3-2-实现步骤\",\"contents\":[]},{\"header\":\"步骤1:创建配置类\",\"slug\":\"步骤1-创建配置类\",\"contents\":[\"创建一个配置类SpringConfig\",\"public class SpringConfig { } \"]},{\"header\":\"步骤2:标识该类为配置类\",\"slug\":\"步骤2-标识该类为配置类\",\"contents\":[\"在配置类上添加@Configuration注解，将其标识为一个配置类，替换applicationContext.xml\",\"@Configuration public class SpringConfig { } \"]},{\"header\":\"步骤3:用注解替换包扫描配置\",\"slug\":\"步骤3-用注解替换包扫描配置\",\"contents\":[\"在配置类上添加包扫描注解@ComponentScan替换<context:component-scan base-package=\\\"\\\"/>\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") public class SpringConfig { } \"]},{\"header\":\"步骤4:创建运行类并执行\",\"slug\":\"步骤4-创建运行类并执行\",\"contents\":[\"创建一个新的运行类AppForAnnotation\",\"public class AppForAnnotation { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = (BookDao) ctx.getBean(\\\"bookDao\\\"); System.out.println(bookDao); BookService bookService = ctx.getBean(BookService.class); System.out.println(bookService); } } \",\"运行AppForAnnotation,可以开到两个对象依然被获取成功\",\"至此，纯注解开发的方式就已经完成了，主要内容包括:\",\"Java类替换Spring核心配置文件\",\"@Configuration注解用于设定当前类为配置类\",\"@ComponentScan注解用于设定扫描路径，此注解只能添加一次，多个数据用数组格式\",\"@ComponentScan({\\\"com.itheima.service\\\",\\\"com.itheima.dao\\\"}) \",\"读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象\",\"//加载配置文件初始化容器 ApplicationContext ctx = new ClassPathXmlApplicationContext(\\\"applicationContext.xml\\\"); //加载配置类初始化容器 ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); \"]},{\"header\":\"知识点1：@Configuration\",\"slug\":\"知识点1-configuration\",\"contents\":[\"名称\",\"@Configuration\",\"类型\",\"类注解\",\"位置\",\"类定义上方\",\"作用\",\"设置该类为spring配置类\",\"属性\",\"value（默认）：定义bean的id\"]},{\"header\":\"知识点2：@ComponentScan\",\"slug\":\"知识点2-componentscan\",\"contents\":[\"名称\",\"@ComponentScan\",\"类型\",\"类注解\",\"位置\",\"类定义上方\",\"作用\",\"设置spring配置类扫描路径，用于加载使用注解格式定义的bean\",\"属性\",\"value（默认）：扫描路径，此路径可以逐层向下扫描\",\"小结\",\"@Component、@Controller、@Service、@Repository\",\"applicationContext.xml中<context:component-san/>的作用是指定扫描包路径，注解为@ComponentScan\",\"@Configuration标识该类为配置类，使用类替换applicationContext.xml文件\",\"ClassPathXmlApplicationContext是加载XML配置文件\",\"AnnotationConfigApplicationContext是加载配置类\"]},{\"header\":\"3.4 注解开发bean作用范围与生命周期管理\",\"slug\":\"_3-4-注解开发bean作用范围与生命周期管理\",\"contents\":[]},{\"header\":\"3.4.1 环境准备\",\"slug\":\"_3-4-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring的依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> \",\"添加一个配置类SpringConfig\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") public class SpringConfig { } \",\"添加BookDao、BookDaoImpl类\",\"public interface BookDao { public void save(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\" ); } } \",\"创建运行类App\",\"public class App { public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao1 = ctx.getBean(BookDao.class); BookDao bookDao2 = ctx.getBean(BookDao.class); System.out.println(bookDao1); System.out.println(bookDao2); } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"3.4.2 Bean的作用范围\",\"slug\":\"_3-4-2-bean的作用范围\",\"contents\":[\"(1) 先运行App类,在控制台打印两个一摸一样的地址，说明默认情况下bean是单例\",\"(2) 要想将BookDaoImpl变成非单例，只需要在其类上添加@scope注解\",\"@Repository //@Scope设置bean的作用范围 @Scope(\\\"prototype\\\") public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\"); } } \",\"再次执行App类，打印结果:\"]},{\"header\":\"知识点1：@Scope\",\"slug\":\"知识点1-scope\",\"contents\":[\"名称\",\"@Scope\",\"类型\",\"类注解\",\"位置\",\"类定义上方\",\"作用\",\"设置该类创建对象的作用范围可用于设置创建出的bean是否为单例对象\",\"属性\",\"value（默认）：定义bean作用范围，默认值singleton（单例），可选值prototype（非单例）\"]},{\"header\":\"3.4.3 Bean的生命周期\",\"slug\":\"_3-4-3-bean的生命周期\",\"contents\":[\"(1) 在BookDaoImpl中添加两个方法，init和destroy，方法名可以任意\",\"@Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\"); } public void init() { System.out.println(\\\"init ...\\\"); } public void destroy() { System.out.println(\\\"destroy ...\\\"); } } \",\"(2) 如何对方法进行标识，哪个是初始化方法，哪个是销毁方法?\",\"只需要在对应的方法上添加@PostConstruct和@PreDestroy注解即可\",\"@Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\"); } @PostConstruct //在构造方法之后执行，替换 init-method public void init() { System.out.println(\\\"init ...\\\"); } @PreDestroy //在销毁方法之前执行,替换 destroy-method public void destroy() { System.out.println(\\\"destroy ...\\\"); } } \",\"(3) 要想看到两个方法执行，需要注意的是destroy只有在容器关闭的时候，才会执行，所以需要修改App的类\",\"public class App { public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao1 = ctx.getBean(BookDao.class); BookDao bookDao2 = ctx.getBean(BookDao.class); System.out.println(bookDao1); System.out.println(bookDao2); ctx.close(); //关闭容器 } } \",\"(4) 运行App,类查看打印结果，证明init和destroy方法都被执行了\",\"注意: @PostConstruct和@PreDestroy注解如果找不到，需要导入下面的jar包\",\"<dependency> <groupId>javax.annotation</groupId> <artifactId>javax.annotation-api</artifactId> <version>1.3.2</version> </dependency> \",\"找不到的原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中\"]},{\"header\":\"知识点1：@PostConstruct\",\"slug\":\"知识点1-postconstruct\",\"contents\":[\"名称\",\"@PostConstruct\",\"类型\",\"方法注解\",\"位置\",\"方法上\",\"作用\",\"设置该方法为初始化方法\",\"属性\",\"无\"]},{\"header\":\"知识点2：@PreDestroy\",\"slug\":\"知识点2-predestroy\",\"contents\":[\"名称\",\"@PreDestroy\",\"类型\",\"方法注解\",\"位置\",\"方法上\",\"作用\",\"设置该方法为销毁方法\",\"属性\",\"无\",\"小结:\"]},{\"header\":\"3.5 注解开发依赖注入\",\"slug\":\"_3-5-注解开发依赖注入\",\"contents\":[\"Spring为了使用注解简化开发，并没有提供构造函数注入、setter注入对应的注解，只提供了自动装配的注解实现\"]},{\"header\":\"3.5.1 环境准备\",\"slug\":\"_3-5-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring的依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> \",\"添加一个配置类SpringConfig\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") public class SpringConfig { } \",\"添加BookDao、BookDaoImpl、BookService、BookServiceImpl类\",\"public interface BookDao { public void save(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\" ); } } public interface BookService { public void save(); } @Service public class BookServiceImpl implements BookService { private BookDao bookDao; public void setBookDao(BookDao bookDao) { this.bookDao = bookDao; } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \",\"创建运行类App\",\"public class App { public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookService bookService = ctx.getBean(BookService.class); bookService.save(); } } \",\"最终创建好的项目结构如下:\",\"环境准备好后，运行后会发现有问题\",\"出现问题的原因是，在BookServiceImpl类中添加了BookDao的属性，并提供了setter方法，但是目前是没有提供配置注入BookDao的，所以bookDao对象为Null，调用其save方法就会报控指针异常\"]},{\"header\":\"3.5.2 注解实现按照类型注入\",\"slug\":\"_3-5-2-注解实现按照类型注入\",\"contents\":[\"对于这个问题使用注解该如何解决?\",\"(1) 在BookServiceImpl类的bookDao属性上添加@Autowired注解\",\"@Service public class BookServiceImpl implements BookService { @Autowired private BookDao bookDao; // public void setBookDao(BookDao bookDao) { // this.bookDao = bookDao; // } public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \",\"注意\",\"@Autowired可以写在属性上，也可也写在setter方法上，最简单的处理方式是写在属性上并将setter方法删除掉\",\"为什么setter方法可以删除呢? \",\"自动装配基于反射设计创建对象并暴力反射对应属性为私有属性初始化数据\",\"普通反射只能获取public修饰的内容\",\"暴力反射除了获取public修饰的内容还可以获取private修改的内容\",\"所以此处无需提供setter方法\",\"(2) @Autowired是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2\",\"@Repository public class BookDaoImpl2 implements BookDao { public void save() { System.out.println(\\\"book dao save ...2\\\"); } } \",\"这个时候再次运行App，就会报错\",\"此时，按照类型注入就无法区分到底注入哪个对象，解决方案:按照名称注入\",\"先给两个Dao类分别起个名称\",\"@Repository(\\\"bookDao\\\") public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\" ); } } @Repository(\\\"bookDao2\\\") public class BookDaoImpl2 implements BookDao { public void save() { System.out.println(\\\"book dao save ...2\\\" ); } } \",\"此时就可以注入成功，但是得思考个问题:\",\"@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错?\",\"@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配，因为变量名叫bookDao而容器中也有一个booDao，所以将其成功注入\",\"分析下面这种情况是否能完成注入呢?\",\"不行，因为按照类型会找到多个bean对象，此时会按照bookDao名称去找，因为IOC容器只有名称叫bookDao1和bookDao2,所以找不到，会报NoUniqueBeanDefinitionException\"]},{\"header\":\"3.5.3 注解实现按照名称注入\",\"slug\":\"_3-5-3-注解实现按照名称注入\",\"contents\":[\"当根据类型在容器中找到多个bean，注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到@Qualifier来指定注入哪个名称的bean对象\",\"@Service public class BookServiceImpl implements BookService { @Autowired @Qualifier(\\\"bookDao1\\\") private BookDao bookDao; public void save() { System.out.println(\\\"book service save ...\\\"); bookDao.save(); } } \",\"@Qualifier注解后的值就是需要注入的bean的名称\",\"注意:@Qualifier不能独立使用，必须和@Autowired一起使用:\"]},{\"header\":\"3.5.4 简单数据类型注入\",\"slug\":\"_3-5-4-简单数据类型注入\",\"contents\":[\"@Repository(\\\"bookDao\\\") public class BookDaoImpl implements BookDao { private String name; public void save() { System.out.println(\\\"book dao save ...\\\" + name); } } \",\"数据类型换了，对应的注解也要跟着换，这次使用@Value注解，将值写入注解的参数中就行了\",\"@Repository(\\\"bookDao\\\") public class BookDaoImpl implements BookDao { @Value(\\\"itheima\\\") private String name; public void save() { System.out.println(\\\"book dao save ...\\\" + name); } } \"]},{\"header\":\"3.5.5 注解读取properties配置文件\",\"slug\":\"_3-5-5-注解读取properties配置文件\",\"contents\":[\"@Value一般会被用在从properties配置文件中读取内容进行使用\"]},{\"header\":\"步骤1：resource下准备properties文件\",\"slug\":\"步骤1-resource下准备properties文件\",\"contents\":[\"jdbc.properties\",\"name=itheima888 \"]},{\"header\":\"步骤2: 使用注解加载properties配置文件\",\"slug\":\"步骤2-使用注解加载properties配置文件\",\"contents\":[\"在配置类上添加@PropertySource注解\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") @PropertySource(\\\"jdbc.properties\\\") public class SpringConfig { } \"]},{\"header\":\"步骤3：使用@Value读取配置文件中的内容\",\"slug\":\"步骤3-使用-value读取配置文件中的内容\",\"contents\":[\"@Repository(\\\"bookDao\\\") public class BookDaoImpl implements BookDao { @Value(\\\"${name}\\\") private String name; public void save() { System.out.println(\\\"book dao save ...\\\" + name); } } \"]},{\"header\":\"步骤4: 运行程序\",\"slug\":\"步骤4-运行程序-2\",\"contents\":[\"注意:\",\"如果读取的properties配置文件有多个，可以使用@PropertySource的属性来指定多个\",\"@PropertySource({\\\"jdbc.properties\\\",\\\"xxx.properties\\\"}) \",\"@PropertySource注解属性中不支持使用通配符*，运行会报错\",\"@PropertySource({\\\"*.properties\\\"}) \",\"@PropertySource注解属性中可以把classpath:加上，代表从当前项目的根路径找文件\",\"@PropertySource({\\\"classpath:jdbc.properties\\\"}) \"]},{\"header\":\"知识点1：@Autowired\",\"slug\":\"知识点1-autowired\",\"contents\":[\"名称\",\"@Autowired\",\"类型\",\"属性注解 或 方法注解（了解） 或 方法形参注解（了解）\",\"位置\",\"属性定义上方 或 标准set方法上方 或 类set方法上方 或 方法形参前面\",\"作用\",\"为引用类型属性设置值\",\"属性\",\"required：true/false，定义该属性是否允许为null\"]},{\"header\":\"知识点2：@Qualifier\",\"slug\":\"知识点2-qualifier\",\"contents\":[\"名称\",\"@Qualifier\",\"类型\",\"属性注解 或 方法注解（了解）\",\"位置\",\"属性定义上方 或 标准set方法上方 或 类set方法上方\",\"作用\",\"为引用类型属性指定注入的beanId\",\"属性\",\"value（默认）：设置注入的beanId\"]},{\"header\":\"知识点3：@Value\",\"slug\":\"知识点3-value\",\"contents\":[\"名称\",\"@Value\",\"类型\",\"属性注解 或 方法注解（了解）\",\"位置\",\"属性定义上方 或 标准set方法上方 或 类set方法上方\",\"作用\",\"为 基本数据类型 或 字符串类型 属性设置值\",\"属性\",\"value（默认）：要注入的属性值\"]},{\"header\":\"知识点4：@PropertySource\",\"slug\":\"知识点4-propertysource\",\"contents\":[\"名称\",\"@PropertySource\",\"类型\",\"类注解\",\"位置\",\"类定义上方\",\"作用\",\"加载properties文件中的属性值\",\"属性\",\"value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组\"]},{\"header\":\"4 IOC/DI注解开发管理第三方bean\",\"slug\":\"_4-ioc-di注解开发管理第三方bean\",\"contents\":[]},{\"header\":\"4.1 环境准备\",\"slug\":\"_4-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring的依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> \",\"添加一个配置类SpringConfig\",\"@Configuration public class SpringConfig { } \",\"添加BookDao、BookDaoImpl类\",\"public interface BookDao { public void save(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(\\\"book dao save ...\\\" ); } } \",\"创建运行类App\",\"public class App { public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"4.2 注解开发管理第三方bean\",\"slug\":\"_4-2-注解开发管理第三方bean\",\"contents\":[\"在上述环境中完成对Druid数据源的管理，具体的实现步骤为:\"]},{\"header\":\"步骤1:导入对应的jar包\",\"slug\":\"步骤1-导入对应的jar包\",\"contents\":[\"<dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> \"]},{\"header\":\"步骤2:在配置类中添加一个方法\",\"slug\":\"步骤2-在配置类中添加一个方法\",\"contents\":[\"注意该方法的返回值就是要创建的Bean对象类型\",\"@Configuration public class SpringConfig { public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); ds.setUrl(\\\"jdbc:mysql://localhost:3306/spring_db\\\"); ds.setUsername(\\\"root\\\"); ds.setPassword(\\\"root\\\"); return ds; } } \"]},{\"header\":\"步骤3:在方法上添加 @Bean 注解\",\"slug\":\"步骤3-在方法上添加-bean注解\",\"contents\":[\"@Bean注解的作用是将方法的返回值制作为Spring管理的一个bean对象\",\"@Configuration public class SpringConfig { @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); ds.setUrl(\\\"jdbc:mysql://localhost:3306/spring_db\\\"); ds.setUsername(\\\"root\\\"); ds.setPassword(\\\"root\\\"); return ds; } } \",\"注意:不能使用DataSource ds = new DruidDataSource()\",\"因为DataSource接口中没有对应的setter方法来设置属性\"]},{\"header\":\"步骤4:从IOC容器中获取对象并打印\",\"slug\":\"步骤4-从ioc容器中获取对象并打印\",\"contents\":[\"public class App { public static void main(String[] args) { AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource); } } \"]},{\"header\":\"4.3 引入外部配置类\",\"slug\":\"_4-3-引入外部配置类\",\"contents\":[\"对于数据源的bean，新建一个JdbcConfig配置类，并把数据源配置到该类下\",\"public class JdbcConfig { @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); ds.setUrl(\\\"jdbc:mysql://localhost:3306/spring_db\\\"); ds.setUsername(\\\"root\\\"); ds.setPassword(\\\"root\\\"); return ds; } } \",\"现在的问题是，这个配置类如何能被Spring配置类加载到，并创建DataSource对象在IOC容器中?\",\"针对这个问题，有两个解决方案:\"]},{\"header\":\"4.3.1 使用包扫描引入\",\"slug\":\"_4-3-1-使用包扫描引入\",\"contents\":[]},{\"header\":\"步骤1:在Spring的配置类上添加包扫描\",\"slug\":\"步骤1-在spring的配置类上添加包扫描\",\"contents\":[\"@Configuration @ComponentScan(\\\"com.itheima.config\\\") public class SpringConfig { } \"]},{\"header\":\"步骤2:在JdbcConfig上添加配置注解\",\"slug\":\"步骤2-在jdbcconfig上添加配置注解\",\"contents\":[\"JdbcConfig类要放入到com.itheima.config包下，需要被Spring的配置类扫描到即可\",\"@Configuration public class JdbcConfig { @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); ds.setUrl(\\\"jdbc:mysql://localhost:3306/spring_db\\\"); ds.setUsername(\\\"root\\\"); ds.setPassword(\\\"root\\\"); return ds; } } \"]},{\"header\":\"步骤3: 运行程序\",\"slug\":\"步骤3-运行程序-2\",\"contents\":[\"依然能获取到bean对象并打印控制台\",\"这种方式虽然能够扫描到，但是不能很快的知晓都引入了哪些配置类，所有这种方式不推荐使用\"]},{\"header\":\"4.3.2 使用 @Import 引入\",\"slug\":\"_4-3-2-使用-import引入\",\"contents\":[\"这种方案可以不用加@Configuration注解，但是必须在Spring配置类上使用@Import注解手动引入需要加载的配置类\"]},{\"header\":\"步骤1:去除JdbcConfig类上的注解\",\"slug\":\"步骤1-去除jdbcconfig类上的注解\",\"contents\":[\"public class JdbcConfig { @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); ds.setUrl(\\\"jdbc:mysql://localhost:3306/spring_db\\\"); ds.setUsername(\\\"root\\\"); ds.setPassword(\\\"root\\\"); return ds; } } \"]},{\"header\":\"步骤2:在Spring配置类中引入\",\"slug\":\"步骤2-在spring配置类中引入\",\"contents\":[\"@Configuration //@ComponentScan(\\\"com.itheima.config\\\") @Import({JdbcConfig.class}) public class SpringConfig { } \",\"注意:\",\"扫描注解可以移除\",\"@Import参数需要的是一个数组，可以引入多个配置类\",\"@Import注解在配置类中只能写一次，下面的方式是不允许的\",\"@Configuration //@ComponentScan(\\\"com.itheima.config\\\") @Import(JdbcConfig.class) @Import(Xxx.class) public class SpringConfig { } \"]},{\"header\":\"步骤3: 运行程序\",\"slug\":\"步骤3-运行程序-3\",\"contents\":[\"依然能获取到bean对象并打印控制台\"]},{\"header\":\"知识点1：@Bean\",\"slug\":\"知识点1-bean\",\"contents\":[\"名称\",\"@Bean\",\"类型\",\"方法注解\",\"位置\",\"方法定义上方\",\"作用\",\"设置该方法的返回值作为spring管理的bean\",\"属性\",\"value（默认）：定义bean的id\"]},{\"header\":\"知识点2：@Import\",\"slug\":\"知识点2-import\",\"contents\":[\"名称\",\"@Import\",\"类型\",\"类注解\",\"位置\",\"类定义上方\",\"作用\",\"导入配置类\",\"属性\",\"value（默认）：定义导入的配置类类名，当配置类有多个时使用数组格式一次性导入多个配置类\"]},{\"header\":\"4.4 注解开发实现为第三方bean注入资源\",\"slug\":\"_4-4-注解开发实现为第三方bean注入资源\",\"contents\":[\"在使用@Bean创建bean对象的时候，如果方法在创建的过程中需要其他资源该怎么办?\",\"这些资源会有两大类，分别是简单数据类型 和引用数据类型\"]},{\"header\":\"4.4.1 简单数据类型\",\"slug\":\"_4-4-1-简单数据类型\",\"contents\":[]},{\"header\":\"4.4.1.1 需求分析\",\"slug\":\"_4-4-1-1-需求分析\",\"contents\":[\"对于下面代码关于数据库的四要素不应该写死在代码中，应该是从properties配置文件中读取，如何来优化下面的代码?\",\"public class JdbcConfig { @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); ds.setUrl(\\\"jdbc:mysql://localhost:3306/spring_db\\\"); ds.setUsername(\\\"root\\\"); ds.setPassword(\\\"root\\\"); return ds; } } \"]},{\"header\":\"4.4.1.2 注入简单数据类型步骤\",\"slug\":\"_4-4-1-2-注入简单数据类型步骤\",\"contents\":[]},{\"header\":\"步骤1:类中提供四个属性\",\"slug\":\"步骤1-类中提供四个属性\",\"contents\":[\"public class JdbcConfig { private String driver; private String url; private String userName; private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); ds.setUrl(\\\"jdbc:mysql://localhost:3306/spring_db\\\"); ds.setUsername(\\\"root\\\"); ds.setPassword(\\\"root\\\"); return ds; } } \"]},{\"header\":\"步骤2:使用 @Value 注解引入值\",\"slug\":\"步骤2-使用-value注解引入值\",\"contents\":[\"public class JdbcConfig { @Value(\\\"com.mysql.jdbc.Driver\\\") private String driver; @Value(\\\"jdbc:mysql://localhost:3306/spring_db\\\") private String url; @Value(\\\"root\\\") private String userName; @Value(\\\"password\\\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } \"]},{\"header\":\"4.4.2 引用数据类型\",\"slug\":\"_4-4-2-引用数据类型\",\"contents\":[]},{\"header\":\"4.4.2.1 需求分析\",\"slug\":\"_4-4-2-1-需求分析\",\"contents\":[\"假设在构建DataSource对象的时候，需要用到BookDao对象，该如何把BookDao对象注入进方法内让其使用呢?\",\"public class JdbcConfig { @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(\\\"com.mysql.jdbc.Driver\\\"); ds.setUrl(\\\"jdbc:mysql://localhost:3306/spring_db\\\"); ds.setUsername(\\\"root\\\"); ds.setPassword(\\\"root\\\"); return ds; } } \"]},{\"header\":\"4.4.2.2 注入引用数据类型步骤\",\"slug\":\"_4-4-2-2-注入引用数据类型步骤\",\"contents\":[]},{\"header\":\"步骤1:在SpringConfig中扫描BookDao\",\"slug\":\"步骤1-在springconfig中扫描bookdao\",\"contents\":[\"扫描的目的是让Spring能管理到BookDao,也就是说要让IOC容器中有一个bookDao对象\",\"@Configuration @ComponentScan(\\\"com.itheima.dao\\\") @Import({JdbcConfig.class}) public class SpringConfig { } \"]},{\"header\":\"步骤2:在JdbcConfig类的方法上添加参数\",\"slug\":\"步骤2-在jdbcconfig类的方法上添加参数\",\"contents\":[\"@Bean public DataSource dataSource(BookDao bookDao){ System.out.println(bookDao); DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } \",\"引用类型注入只需要为bean定义方法设置形参即可，容器会根据类型自动装配对象\"]},{\"header\":\"步骤3: 运行程序\",\"slug\":\"步骤3-运行程序-4\",\"contents\":[]},{\"header\":\"5 注解开发总结\",\"slug\":\"_5-注解开发总结\",\"contents\":[]},{\"header\":\"6 Spring整合\",\"slug\":\"_6-spring整合\",\"contents\":[]},{\"header\":\"6.1 Spring整合Mybatis思路分析\",\"slug\":\"_6-1-spring整合mybatis思路分析\",\"contents\":[]},{\"header\":\"6.1.1 环境准备\",\"slug\":\"_6-1-1-环境准备\",\"contents\":[]},{\"header\":\"步骤1:准备数据库表\",\"slug\":\"步骤1-准备数据库表\",\"contents\":[\"create database spring_db character set utf8; use spring_db; create table tbl_account( id int primary key auto_increment, name varchar(35), money double ); \"]},{\"header\":\"步骤2:创建项目导入jar包\",\"slug\":\"步骤2-创建项目导入jar包\",\"contents\":[\"项目的pom.xml添加相关依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.6</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.47</version> </dependency> </dependencies> \"]},{\"header\":\"步骤3:根据表创建模型类\",\"slug\":\"步骤3-根据表创建模型类\",\"contents\":[\"public class Account implements Serializable { private Integer id; private String name; private Double money; //setter...getter...toString...方法略 } \"]},{\"header\":\"步骤4:创建Dao接口\",\"slug\":\"步骤4-创建dao接口\",\"contents\":[\"public interface AccountDao { @Insert(\\\"insert into tbl_account(name,money)values(#{name},#{money})\\\") void save(Account account); @Delete(\\\"delete from tbl_account where id = #{id} \\\") void delete(Integer id); @Update(\\\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \\\") void update(Account account); @Select(\\\"select * from tbl_account\\\") List<Account> findAll(); @Select(\\\"select * from tbl_account where id = #{id} \\\") Account findById(Integer id); } \"]},{\"header\":\"步骤5:创建Service接口和实现类\",\"slug\":\"步骤5-创建service接口和实现类\",\"contents\":[\"public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List<Account> findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List<Account> findAll() { return accountDao.findAll(); } } \"]},{\"header\":\"步骤6:添加jdbc.properties文件\",\"slug\":\"步骤6-添加jdbc-properties文件\",\"contents\":[\"resources目录下添加，用于配置数据库连接四要素\",\"jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root \",\"useSSL:关闭MySQL的SSL连接\"]},{\"header\":\"步骤7:添加Mybatis核心配置文件\",\"slug\":\"步骤7-添加mybatis核心配置文件\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <!DOCTYPE configuration PUBLIC \\\"-//mybatis.org//DTD Config 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-config.dtd\\\"> <configuration> <!--读取外部properties配置文件--> <properties resource=\\\"jdbc.properties\\\"></properties> <!--别名扫描的包路径--> <typeAliases> <package name=\\\"com.itheima.domain\\\"/> </typeAliases> <!--数据源--> <environments default=\\\"mysql\\\"> <environment id=\\\"mysql\\\"> <transactionManager type=\\\"JDBC\\\"></transactionManager> <dataSource type=\\\"POOLED\\\"> <property name=\\\"driver\\\" value=\\\"${jdbc.driver}\\\"></property> <property name=\\\"url\\\" value=\\\"${jdbc.url}\\\"></property> <property name=\\\"username\\\" value=\\\"${jdbc.username}\\\"></property> <property name=\\\"password\\\" value=\\\"${jdbc.password}\\\"></property> </dataSource> </environment> </environments> <!--映射文件扫描包路径--> <mappers> <package name=\\\"com.itheima.dao\\\"></package> </mappers> </configuration> \"]},{\"header\":\"步骤8:编写应用程序\",\"slug\":\"步骤8-编写应用程序\",\"contents\":[\"public class App { public static void main(String[] args) throws IOException { // 1. 创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); // 2. 加载SqlMapConfig.xml配置文件 InputStream inputStream = Resources.getResourceAsStream(\\\"SqlMapConfig.xml.bak\\\"); // 3. 创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); // 4. 获取SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 5. 执行SqlSession对象执行查询，获取结果User AccountDao accountDao = sqlSession.getMapper(AccountDao.class); Account ac = accountDao.findById(1); System.out.println(ac); // 6. 释放资源 sqlSession.close(); } } \"]},{\"header\":\"步骤9:运行程序\",\"slug\":\"步骤9-运行程序\",\"contents\":[]},{\"header\":\"6.1.2 整合思路分析\",\"slug\":\"_6-1-2-整合思路分析\",\"contents\":[\"Mybatis程序核心对象分析\",\"从图中可以获取到，真正需要交给Spring管理的是SqlSessionFactory\",\"整合Mybatis，就是将Mybatis用到的内容交给Spring管理，分析下配置文件\",\"说明\",\"第一行读取外部properties配置文件，Spring有提供具体的解决方案@PropertySource,需要交给Spring\",\"第二行起别名包扫描，为SqlSessionFactory服务的，需要交给Spring\",\"第三行主要用于做连接池，Spring之前我们已经整合了Druid连接池，这块也需要交给Spring\",\"前面三行一起都是为了创建SqlSession对象用的，那么用Spring管理SqlSession对象吗?SqlSession是由SqlSessionFactory创建出来的，所以只需要将SqlSessionFactory交给Spring管理即可\",\"第四行是Mapper接口和映射文件（如果使用注解就没有该映射文件），这个是在获取到SqlSession以后执行具体操作的时候用，所以它和SqlSessionFactory创建的时机都不在同一个时间，可能需要单独管理\"]},{\"header\":\"6.2 Spring整合Mybatis\",\"slug\":\"_6-2-spring整合mybatis\",\"contents\":[\"第一件事是：Spring要管理MyBatis中的SqlSessionFactory\",\"第二件事是：Spring要管理Mapper接口的扫描\"]},{\"header\":\"步骤1:项目中导入整合需要的jar包\",\"slug\":\"步骤1-项目中导入整合需要的jar包\",\"contents\":[\"<dependency> <!--Spring操作数据库需要该jar包--> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <!-- Spring与Mybatis整合的jar包 这个jar包mybatis在前面，是Mybatis提供的 --> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>1.3.0</version> </dependency> \"]},{\"header\":\"步骤2:创建Spring的主配置类\",\"slug\":\"步骤2-创建spring的主配置类\",\"contents\":[\"//配置类注解 @Configuration //包扫描，主要扫描的是项目中的AccountServiceImpl类 @ComponentScan(\\\"com.itheima\\\") public class SpringConfig { } \"]},{\"header\":\"步骤3:创建数据源的配置类\",\"slug\":\"步骤3-创建数据源的配置类\",\"contents\":[\"在配置类中完成数据源的创建\",\"public class JdbcConfig { @Value(\\\"${jdbc.driver}\\\") private String driver; @Value(\\\"${jdbc.url}\\\") private String url; @Value(\\\"${jdbc.username}\\\") private String userName; @Value(\\\"${jdbc.password}\\\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } \"]},{\"header\":\"步骤4:主配置类中读properties并引入数据源配置类\",\"slug\":\"步骤4-主配置类中读properties并引入数据源配置类\",\"contents\":[\"@Configuration @ComponentScan(\\\"com.itheima\\\") @PropertySource(\\\"classpath:jdbc.properties\\\") @Import(JdbcConfig.class) public class SpringConfig { } \"]},{\"header\":\"步骤5:创建Mybatis配置类并配置SqlSessionFactory\",\"slug\":\"步骤5-创建mybatis配置类并配置sqlsessionfactory\",\"contents\":[\"public class MybatisConfig { //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象 @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); //设置模型类的别名扫描 ssfb.setTypeAliasesPackage(\\\"com.itheima.domain\\\"); //设置数据源 ssfb.setDataSource(dataSource); return ssfb; } //定义bean，返回MapperScannerConfigurer对象 @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\\\"com.itheima.dao\\\"); return msc; } } \",\"说明:\",\"使用SqlSessionFactoryBean封装SqlSessionFactory需要的环境信息\",\"SqlSessionFactoryBean是FactoryBean的一个子类，在该类中将SqlSessionFactory的创建进行了封装，简化对象的创建，只需将其需要的内容设置进行即可\",\"方法中有一个参数为dataSource，当前Spring容器中已经创建了Druid数据源，类型刚好是DataSource类型的，此时在初始化SqlSessionFactoryBean这个对象的时候，发现需要使用DataSource对象，而容器中刚好有这么一个对象，就自动加载了DruidDataSource对象\",\"使用MapperScannerConfigurer加载Dao接口，创建代理对象保存到IOC容器中\",\"MapperScannerConfigurer对象也是MyBatis提供的专用于整合的jar包中的类，用来处理原始配置文件中的mappers相关配置的，加载数据层对应的Mapper，因此类名是一个扫描配置的名称\",\"MapperScannerConfigurer有一个核心属性，就是将原始配置中的扫描路径\",\"从类名上可以分辨出，它主要工作是扫描后生成配置，因此需要配置扫描的路径，所以需要为其设置扫描的路径包，也就是之前<mappers>配置中定义的主要内容\"]},{\"header\":\"步骤6:主配置类中引入Mybatis配置类\",\"slug\":\"步骤6-主配置类中引入mybatis配置类\",\"contents\":[\"@Configuration @ComponentScan(\\\"com.itheima\\\") @PropertySource(\\\"classpath:jdbc.properties\\\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } \"]},{\"header\":\"步骤7:编写运行类\",\"slug\":\"步骤7-编写运行类\",\"contents\":[\"在运行类中，从IOC容器中获取Service对象，调用方法获取结果\",\"public class App2 { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); AccountService accountService = ctx.getBean(AccountService.class); Account ac = accountService.findById(1); System.out.println(ac); } } \"]},{\"header\":\"步骤8:运行程序\",\"slug\":\"步骤8-运行程序\",\"contents\":[\"其中主要用到的两个类\",\"SqlSessionFactoryBean\",\"MapperScannerConfigurer\"]},{\"header\":\"6.3 Spring整合Junit\",\"slug\":\"_6-3-spring整合junit\",\"contents\":[]},{\"header\":\"6.3.1 环境准备\",\"slug\":\"_6-3-1-环境准备\",\"contents\":[]},{\"header\":\"6.3.2 整合Junit步骤\",\"slug\":\"_6-3-2-整合junit步骤\",\"contents\":[]},{\"header\":\"步骤1:引入依赖\",\"slug\":\"步骤1-引入依赖\",\"contents\":[\"pom.xml\",\"<dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> <version>5.2.10.RELEASE</version> </dependency> \"]},{\"header\":\"步骤2:编写测试类\",\"slug\":\"步骤2-编写测试类\",\"contents\":[\"在 test\\\\java 下创建一个AccountServiceTest\",\"//设置类运行器 @RunWith(SpringJUnit4ClassRunner.class) //设置Spring环境对应的配置类 @ContextConfiguration(classes = {SpringConfiguration.class}) //加载配置类 //@ContextConfiguration(locations={\\\"classpath:applicationContext.xml\\\"})//加载配置文件 public class AccountServiceTest { //支持自动装配注入bean @Autowired private AccountService accountService; @Test public void testFindById(){ System.out.println(accountService.findById(1)); } @Test public void testFindAll(){ System.out.println(accountService.findAll()); } } \",\"注意\",\"单元测试，如果测试的是注解配置类，则使用@ContextConfiguration(classes = {配置类.class})\",\"单元测试，如果测试的是注解配置文件，则使用@ContextConfiguration(locations={配置文件名,...})\",\"JUnit 运行后是基于Spring环境运行的，所以Spring提供了一个专用的类运行器，这个务必要设置，这个类运行器就在Spring的测试专用包中提供的，导入的坐标就是这个东西SpringJUnit4ClassRunner\"]},{\"header\":\"知识点1：@RunWith\",\"slug\":\"知识点1-runwith\",\"contents\":[\"名称\",\"@RunWith\",\"类型\",\"测试类注解\",\"位置\",\"测试类定义上方\",\"作用\",\"设置JUnit运行器\",\"属性\",\"value（默认）：运行所使用的运行期\"]},{\"header\":\"知识点2：@ContextConfiguration\",\"slug\":\"知识点2-contextconfiguration\",\"contents\":[\"名称\",\"@ContextConfiguration\",\"类型\",\"测试类注解\",\"位置\",\"测试类定义上方\",\"作用\",\"设置JUnit加载的Spring核心配置\",\"属性\",\"classes：核心配置类，可以使用数组的格式设定加载多个配置类locations： 配置文件，可以使用数组的格式设定加载多个配置文件名称\"]}]},\"/BackEnd/Spring/spring03.html\":{\"title\":\"Spring AOP\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"理解并掌握AOP相关概念\",\"能够说出AOP的工作流程\",\"能运用AOP相关知识完成对应的案例编写\",\"重点掌握Spring的声明式事务管理\"]},{\"header\":\"1 AOP简介\",\"slug\":\"_1-aop简介\",\"contents\":[]},{\"header\":\"1.1 什么是AOP?\",\"slug\":\"_1-1-什么是aop\",\"contents\":[\"AOP(Aspect Oriented Programming) 面向切面编程，一种编程范式，指导开发者如何组织程序结构\",\"OOP(Object Oriented Programming) 面向对象编程\",\"编程思想主要的内容就是指导程序员该如何编写程序，所以它们两个是不同的编程范式\"]},{\"header\":\"1.2 AOP作用\",\"slug\":\"_1-2-aop作用\",\"contents\":[\"在不惊动原始设计的基础上为其进行功能增强\"]},{\"header\":\"1.3 AOP核心概念\",\"slug\":\"_1-3-aop核心概念\",\"contents\":[\"整个环境的内容暂时可以不用关注，最主要的类为:BookDaoImpl\",\"@Repository public class BookDaoImpl implements BookDao { public void save() { //记录程序当前执行执行（开始时间） Long startTime = System.currentTimeMillis(); //业务执行万次 for (int i = 0;i<10000;i++) { System.out.println(\\\"book dao save ...\\\"); } //记录程序当前执行时间（结束时间） Long endTime = System.currentTimeMillis(); //计算时间差 Long totalTime = endTime-startTime; //输出信息 System.out.println(\\\"执行万次消耗时间：\\\" + totalTime + \\\"ms\\\"); } public void update(){ System.out.println(\\\"book dao update ...\\\"); } public void delete(){ System.out.println(\\\"book dao delete ...\\\"); } public void select(){ System.out.println(\\\"book dao select ...\\\"); } } \",\"当在App类中从容器中获取bookDao对象后，分别执行其save,delete,update和select方法\",\"疑问?\",\"对于计算万次执行消耗的时间只有save方法有，为什么delete和update方法也会有呢?\",\"delete和update方法有，那什么select方法又没有呢?\",\"这个案例中其实就使用了Spring的AOP，在不惊动(改动)原有设计(代码)的前提下，想给谁添加功能就给谁添加\"]},{\"header\":\"无入侵式 / 无侵入式\",\"slug\":\"无入侵式-无侵入式\",\"contents\":[\"BookServiceImpl中有save,update,delete和select方法，这些方法称为连接点\",\"update和delete只有打印，但是在运行的时候有该功能，update和delete方法都已经被增强，所以对于需要增强的方法叫切入点\",\"执行BookServiceImpl的update和delete方法的时候都被添加了一个计算万次执行消耗时间的功能，将这个功能抽取到一个方法中，换句话说就是存放共性功能的方法，叫通知\",\"通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，就需要提前将它们之间的关系描述清楚，那么对于通知和切入点之间的关系描述，叫切面\",\"通知是一个方法，方法不能独立存在需要被写在一个类中，这个类叫通知类\",\"总结\",\"连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等\",\"在SpringAOP中，理解为方法的执行\",\"切入点(Pointcut)：匹配连接点的式子\",\"在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法 \",\"一个具体的方法：com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法\",\"匹配多个方法：所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法\",\"连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点\",\"通知(Advice)：在切入点处执行的操作，也就是共性功能\",\"在SpringAOP中，功能最终以方法的形式呈现\",\"通知类：定义通知的类\",\"切面(Aspect)：描述通知与切入点的对应关系\"]},{\"header\":\"2 AOP入门案例\",\"slug\":\"_2-aop入门案例\",\"contents\":[]},{\"header\":\"2.1 需求分析\",\"slug\":\"_2-1-需求分析\",\"contents\":[\"案例设定：测定接口执行效率\",\"简化设定：在接口执行前输出当前系统时间\"]},{\"header\":\"2.2 思路分析\",\"slug\":\"_2-2-思路分析\",\"contents\":[\"导入坐标(pom.xml)\",\"制作连接点方法(原始操作，Dao接口与实现类)\",\"制作共性功能(通知类与通知)\",\"定义切入点\",\"绑定切入点与通知关系(切面)\"]},{\"header\":\"2.3 环境准备\",\"slug\":\"_2-3-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> \",\"添加BookDao和BookDaoImpl类\",\"public interface BookDao { public void save(); public void update(); } @Repository public class BookDaoImpl implements BookDao { public void save() { System.out.println(System.currentTimeMillis()); System.out.println(\\\"book dao save ...\\\"); } public void update(){ System.out.println(\\\"book dao update ...\\\"); } } \",\"创建Spring的配置类\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") public class SpringConfig { } \",\"编写App运行类\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.save(); } } \",\"最终创建好的项目结构如下:\",\"说明:\",\"目前打印save方法的时候，因为方法中有打印系统时间，所以运行的时候是可以看到系统时间 但是对于update方法来说，就没有该打印系统时间的功能 接下来，使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能\"]},{\"header\":\"2.4 AOP实现步骤\",\"slug\":\"_2-4-aop实现步骤\",\"contents\":[]},{\"header\":\"步骤1:添加依赖\",\"slug\":\"步骤1-添加依赖\",\"contents\":[\"pom.xml\",\"<dependency> <groupId>org.aspectj</groupId> <artifactId>aspectjweaver</artifactId> <version>1.9.4</version> </dependency> \",\"因为spring-context中已经导入了spring-aop，这用到的是Maven的依赖传递，所以不需要再导入spring-aop\",\"导入AspectJ的jar包，AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦些\"]},{\"header\":\"步骤2:定义接口与实现类\",\"slug\":\"步骤2-定义接口与实现类\",\"contents\":[\"环境准备的时候，BookDaoImpl已经准备好，不需要做任何修改\"]},{\"header\":\"步骤3:定义通知类和通知\",\"slug\":\"步骤3-定义通知类和通知\",\"contents\":[\"通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印\",\"public class MyAdvice { public void method(){ System.out.println(System.currentTimeMillis()); } } \"]},{\"header\":\"步骤4:定义切入点\",\"slug\":\"步骤4-定义切入点\",\"contents\":[\"BookDaoImpl中有两个方法，分别是save和update，要增强的是update方法，该如何定义?\",\"public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} public void method(){ System.out.println(System.currentTimeMillis()); } } \",\"切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑\"]},{\"header\":\"步骤5:制作切面\",\"slug\":\"步骤5-制作切面\",\"contents\":[\"切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?\",\"public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Before(\\\"pt()\\\") public void method(){ System.out.println(System.currentTimeMillis()); } } \",\"绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置\",\"@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行\"]},{\"header\":\"步骤6:将通知类配给容器并标识其为切面类\",\"slug\":\"步骤6-将通知类配给容器并标识其为切面类\",\"contents\":[\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Before(\\\"pt()\\\") public void method(){ System.out.println(System.currentTimeMillis()); } } \"]},{\"header\":\"步骤7:开启注解格式AOP功能\",\"slug\":\"步骤7-开启注解格式aop功能\",\"contents\":[\"@Configuration @ComponentScan(\\\"com.itheima\\\") @EnableAspectJAutoProxy public class SpringConfig { } \"]},{\"header\":\"步骤8:运行程序\",\"slug\":\"步骤8-运行程序\",\"contents\":[\"public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } \",\"看到在执行update方法之前打印了系统时间戳，说明对原始方法进行了增强，AOP编程成功\"]},{\"header\":\"知识点1：@EnableAspectJAutoProxy\",\"slug\":\"知识点1-enableaspectjautoproxy\",\"contents\":[\"名称\",\"@EnableAspectJAutoProxy\",\"类型\",\"配置类注解\",\"位置\",\"配置类定义上方\",\"作用\",\"开启注解格式AOP功能\"]},{\"header\":\"知识点2：@Aspect\",\"slug\":\"知识点2-aspect\",\"contents\":[\"名称\",\"@Aspect\",\"类型\",\"类注解\",\"位置\",\"切面类定义上方\",\"作用\",\"设置当前类为AOP切面类\"]},{\"header\":\"知识点3：@Pointcut\",\"slug\":\"知识点3-pointcut\",\"contents\":[\"名称\",\"@Pointcut\",\"类型\",\"方法注解\",\"位置\",\"切入点方法定义上方\",\"作用\",\"设置切入点方法\",\"属性\",\"value（默认）：切入点表达式\"]},{\"header\":\"知识点4：@Before\",\"slug\":\"知识点4-before\",\"contents\":[\"名称\",\"@Before\",\"类型\",\"方法注解\",\"位置\",\"通知方法定义上方\",\"作用\",\"设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行\"]},{\"header\":\"3 AOP工作流程\",\"slug\":\"_3-aop工作流程\",\"contents\":[]},{\"header\":\"3.1 AOP工作流程\",\"slug\":\"_3-1-aop工作流程\",\"contents\":[\"由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起:\"]},{\"header\":\"流程1:Spring容器启动\",\"slug\":\"流程1-spring容器启动\",\"contents\":[\"容器启动就需要去加载bean,哪些类需要被加载呢?\",\"需要被增强的类，如:BookServiceImpl\",\"通知类，如:MyAdvice\",\"注意此时bean对象还没有创建成功\"]},{\"header\":\"流程2:读取所有切面配置中的切入点\",\"slug\":\"流程2-读取所有切面配置中的切入点\",\"contents\":[\"上面有两个切入点的配置，但是第一个ptx()并没有被使用，所以不会被读取\"]},{\"header\":\"流程3:初始化bean\",\"slug\":\"流程3-初始化bean\",\"contents\":[\"判定bean对应的类中的方法是否匹配到任意切入点\",\"注意第1步在容器启动的时候，bean对象还没有被创建成功\",\"要被实例化bean对象的类中的方法和切入点进行匹配\",\"匹配失败，创建原始对象，如UserDao\",\"匹配失败说明不需要增强，直接调用原始对象的方法即可\",\"匹配成功，创建原始对象（目标对象）的代理对象，如:BookDao\",\"匹配成功说明需要对其进行增强\",\"对哪个类做增强，这个类对应的对象就叫做目标对象\",\"因为要对目标对象进行功能增强，而采用的技术是动态代理，所以会为目标对象创建一个代理对象\",\"最终运行的是代理对象的方法，在该方法中会对原始方法进行功能增强\"]},{\"header\":\"流程4:获取bean执行方法\",\"slug\":\"流程4-获取bean执行方法\",\"contents\":[\"获取的bean是原始对象时，调用方法并执行，完成操作\",\"获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作\"]},{\"header\":\"验证容器中是否为代理对象\",\"slug\":\"验证容器中是否为代理对象\",\"contents\":[\"如果目标对象中的方法会被增强，那么容器中将存入的是目标对象的代理对象\",\"如果目标对象中的方法不被增强，那么容器中将存入的是目标对象本身\"]},{\"header\":\"验证思路\",\"slug\":\"验证思路\",\"contents\":[\"要执行的方法，不被定义的切入点包含，即对该方法不进行增强，打印当前类的getClass()方法\",\"要执行的方法，被定义的切入点包含，即对该方法进行增强，打印出当前类的getClass()方法\",\"观察两次打印的结果\"]},{\"header\":\"步骤1:修改App类,获取类的类型\",\"slug\":\"步骤1-修改app类-获取类的类型\",\"contents\":[\"public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); System.out.println(bookDao); System.out.println(bookDao.getClass()); } } \"]},{\"header\":\"步骤2:修改MyAdvice类，不增强\",\"slug\":\"步骤2-修改myadvice类-不增强\",\"contents\":[\"因为定义的切入点中，被修改成update1,所以BookDao中的update方法在执行的时候，就不会被增强 所以容器中的对象应该是目标对象本身\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update1())\\\") private void pt(){} @Before(\\\"pt()\\\") public void method(){ System.out.println(System.currentTimeMillis()); } } \"]},{\"header\":\"步骤3:运行程序\",\"slug\":\"步骤3-运行程序\",\"contents\":[]},{\"header\":\"步骤4:修改MyAdvice类，增强\",\"slug\":\"步骤4-修改myadvice类-增强\",\"contents\":[\"因为定义的切入点中，被修改成update,所以BookDao中的update方法在执行的时候，就会被增强 所以容器中的对象应该是是目标对象的代理对象\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Before(\\\"pt()\\\") public void method(){ System.out.println(System.currentTimeMillis()); } } \"]},{\"header\":\"步骤5:运行程序\",\"slug\":\"步骤5-运行程序\",\"contents\":[]},{\"header\":\"3.2 AOP核心概念\",\"slug\":\"_3-2-aop核心概念\",\"contents\":[\"在上面介绍AOP的工作流程中，提到了两个核心概念，分别是:\",\"目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的\",\"代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现\",\"简单来说\",\"目标对象就是要增强的类（如:BookServiceImpl类）对应的对象，也叫原始对象，不能说它不能运行，只能说它在运行的过程中对于要增强的内容是缺失的\",\"SpringAOP是在不改变原有设计(代码)的前提下对其进行增强的，它的底层采用的是代理模式实现的，所以要对原始对象进行增强，就需要对原始对象创建代理对象，在代理对象中的方法把通知（如:MyAdvice中的method方法）内容加进去，就实现了增强，这就是代理(Proxy)\"]},{\"header\":\"4 AOP配置管理\",\"slug\":\"_4-aop配置管理\",\"contents\":[]},{\"header\":\"4.1 AOP切入点表达式\",\"slug\":\"_4-1-aop切入点表达式\",\"contents\":[\"对于AOP中切入点表达式，分别是语法格式、通配符和书写技巧\"]},{\"header\":\"4.1.1 语法格式\",\"slug\":\"_4-1-1-语法格式\",\"contents\":[\"切入点：要进行增强的方法\",\"切入点表达式：要进行增强的方法的描述方式\",\"描述方式一：执行com.itheima.dao包下的BookDao接口中的无参数update方法\",\"execution(void com.itheima.dao.BookDao.update()) \",\"描述方式二：执行com.itheima.dao.impl包下的BookDaoImpl类中的无参数update方法\",\"execution(void com.itheima.dao.impl.BookDaoImpl.update()) \",\"因为调用接口方法的时候最终运行的还是其实现类的方法，所以上面两种描述方式都是可以的\",\"对于切入点表达式\",\"标准格式：动作关键字（访问修饰符 返回值 包名.类/接口名.方法名(参数) 异常名）\",\"execution(public User com.itheima.service.UserService.findById(int)) \",\"提示\",\"execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点\",\"public：访问修饰符，还可以是public，private等，可以省略\",\"User：返回值，写返回值类型\",\"com.itheima.service：包名，多级包使用点连接\",\"UserService：类/接口名称\",\"findById：方法名\",\"int：参数，直接写参数的类型，多个类型用逗号隔开\",\"异常名：方法定义中抛出指定异常，可省略\"]},{\"header\":\"4.1.2 通配符\",\"slug\":\"_4-1-2-通配符\",\"contents\":[\"* ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现\",\"execution(public * com.itheima.*.UserService.find*(*)) \",\"匹配com.itheima包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法\",\".. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写\",\"execution(public User com..UserService.findById(..)) \",\"匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法\",\"+ ：专用于匹配子类类型\",\"execution(* *..*Service+.*(..)) \",\"使用率较低，描述子类的，表示所有以Service结尾的接口的子类\",\"execution(void com.itheima.dao.BookDao.update()) 匹配接口，能匹配到 execution(void com.itheima.dao.impl.BookDaoImpl.update()) 匹配实现类，能匹配到 execution(* com.itheima.dao.impl.BookDaoImpl.update()) 返回值任意，能匹配到 execution(* com.itheima.dao.impl.BookDaoImpl.update(*)) 返回值任意，但是update方法必须要有一个参数，无法匹配，要想匹配需要在update接口和实现类添加参数 execution(void com.*.*.*.*.update()) 返回值为void,com包下的任意包三层包下的任意类的update方法，匹配到的是实现类，能匹配 execution(void com.*.*.*.update()) 返回值为void,com包下的任意两层包下的任意类的update方法，匹配到的是接口，能匹配 execution(void *..update()) 返回值为void，方法名是update的任意包下的任意类，能匹配 execution(* *..*(..)) 匹配项目中任意类的任意方法，能匹配，但是不建议使用这种方式，影响范围广 execution(* *..u*(..)) 匹配项目中任意包任意类下只要以u开头的方法，update方法能满足，能匹配 execution(* *..*e(..)) 匹配项目中任意包任意类下只要以e结尾的方法，update和save方法能满足，能匹配 execution(void com..*()) 返回值为void，com包下的任意包任意类任意方法，能匹配，*代表的是方法 execution(* com.itheima.*.*Service.find*(..)) 将项目中所有业务层方法的以find开头的方法匹配 execution(* com.itheima.*.*Service.save*(..)) 将项目中所有业务层方法的以save开头的方法匹配 \",\"后面两种更符合平常切入点表达式的编写规则\"]},{\"header\":\"4.1.3 书写技巧\",\"slug\":\"_4-1-3-书写技巧\",\"contents\":[\"所有代码按照标准规范开发，否则以下技巧全部失效 描述切入点通常描述接口，而不描述实现类，如果描述到实现类，就出现紧耦合了 访问控制修饰符针对接口开发均采用public描述（可省略访问控制修饰符描述） 返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述包名书写尽量不使用..匹配，效率过低，常用*做单个包描述匹配，或精准匹配接口名/类名书写名称与模块相关的采用*匹配，例如UserService书写成*Service，绑定业务层接口名方法名书写以动词进行精准匹配，名词采用匹配，例如getById书写成getBy,selectAll书写成selectAll 通常不使用异常作为匹配规则\"]},{\"header\":\"4.2 AOP通知类型\",\"slug\":\"_4-2-aop通知类型\",\"contents\":[\"它所代表的含义是将通知添加到切入点方法执行的前面\"]},{\"header\":\"4.2.1 类型介绍\",\"slug\":\"_4-2-1-类型介绍\",\"contents\":[\"回顾AOP通知\",\"AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置\",\"通知具体要添加到切入点的哪里?\",\"AOP共提供了5种通知类型\",\"前置通知\",\"后置通知\",\"环绕通知\",\"返回后通知 \",\"抛出异常后通知 \",\"前置通知，追加功能到方法执行前，类似于在代码1或者代码2添加内容\",\"后置通知，追加功能到方法执行后，不管方法执行的过程中有没有抛出异常都会执行，类似于在代码5添加内容\",\"返回后通知，追加功能到方法执行后，只有方法正常执行结束后才进行，类似于在代码3添加内容，如果方法执行抛出异常，返回后通知将不会被添加\",\"抛出异常后通知，追加功能到方法抛出异常后，只有方法执行出异常才进行，类似于在代码4添加内容，只有方法抛出异常后才会被添加\",\"环绕通知，环绕通知功能比较强大，它可以追加功能到方法执行的前后，这也是比较常用的方式，它可以实现其他四种通知类型的功能\"]},{\"header\":\"4.2.2 环境准备\",\"slug\":\"_4-2-2-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.aspectj</groupId> <artifactId>aspectjweaver</artifactId> <version>1.9.4</version> </dependency> </dependencies> \",\"添加BookDao和BookDaoImpl类\",\"public interface BookDao { public void update(); public int select(); } @Repository public class BookDaoImpl implements BookDao { public void update(){ System.out.println(\\\"book dao update ...\\\"); } public int select() { System.out.println(\\\"book dao select is running ...\\\"); return 100; } } \",\"创建Spring的配置类\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") @EnableAspectJAutoProxy public class SpringConfig { } \",\"创建通知类\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} public void before() { System.out.println(\\\"before advice ...\\\"); } public void after() { System.out.println(\\\"after advice ...\\\"); } public void around(){ System.out.println(\\\"around before advice ...\\\"); System.out.println(\\\"around after advice ...\\\"); } public void afterReturning() { System.out.println(\\\"afterReturning advice ...\\\"); } public void afterThrowing() { System.out.println(\\\"afterThrowing advice ...\\\"); } } \",\"编写App运行类\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); bookDao.update(); } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"4.2.3 通知类型的使用\",\"slug\":\"_4-2-3-通知类型的使用\",\"contents\":[]},{\"header\":\"前置通知\",\"slug\":\"前置通知\",\"contents\":[\"修改MyAdvic，在before方法上添加@Before注解\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Before(\\\"pt()\\\") //此处也可以写成 @Before(\\\"MyAdvice.pt()\\\"),不建议 public void before() { System.out.println(\\\"before advice ...\\\"); } } \"]},{\"header\":\"后置通知\",\"slug\":\"后置通知\",\"contents\":[\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Before(\\\"pt()\\\") public void before() { System.out.println(\\\"before advice ...\\\"); } @After(\\\"pt()\\\") public void after() { System.out.println(\\\"after advice ...\\\"); } } \"]},{\"header\":\"环绕通知\",\"slug\":\"环绕通知\",\"contents\":[]},{\"header\":\"基本使用\",\"slug\":\"基本使用\",\"contents\":[\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Around(\\\"pt()\\\") public void around(){ System.out.println(\\\"around before advice ...\\\"); System.out.println(\\\"around after advice ...\\\"); } } \",\"运行结果中，通知的内容打印出来，但是原始方法的内容却没有被执行\",\"因为环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用，具体如何实现?\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Around(\\\"pt()\\\") public void around(ProceedingJoinPoint pjp) throws Throwable{ System.out.println(\\\"around before advice ...\\\"); //表示对原始操作的调用 pjp.proceed(); System.out.println(\\\"around after advice ...\\\"); } } \",\"说明: proceed()为什么要抛出异常?\",\"再次运行，程序可以看到原始方法已经被执行了\"]},{\"header\":\"注意事项\",\"slug\":\"注意事项\",\"contents\":[\"(1)原始方法有返回值的处理\",\"修改MyAdvice，对BookDao中的select方法添加环绕通知\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Pointcut(\\\"execution(int com.itheima.dao.BookDao.select())\\\") private void pt2(){} @Around(\\\"pt2()\\\") public void aroundSelect(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\\\"around before advice ...\\\"); //表示对原始操作的调用 pjp.proceed(); System.out.println(\\\"around after advice ...\\\"); } } \",\"修改App类，调用select方法\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); int num = bookDao.select(); System.out.println(num); } } \",\"运行后会报错，错误内容为:\",\"Exception in thread \\\"main\\\" org.springframework.aop.AopInvocationException: Null return value from advice does not match primitive return type for: public abstract int com.itheima.dao.BookDao.select() at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:226) at com.sun.proxy.$Proxy19.select(Unknown Source) at com.itheima.App.main(App.java:12) \",\"错误大概的意思是:空的返回不匹配原始方法的int返回\",\"void就是返回Null\",\"原始方法就是BookDao下的select方法\",\"所以使用环绕通知要根据原始方法的返回值来设置环绕通知的返回值\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Pointcut(\\\"execution(int com.itheima.dao.BookDao.select())\\\") private void pt2(){} @Around(\\\"pt2()\\\") public Object aroundSelect(ProceedingJoinPoint pjp) throws Throwable { System.out.println(\\\"around before advice ...\\\"); //表示对原始操作的调用 Object ret = pjp.proceed(); System.out.println(\\\"around after advice ...\\\"); return ret; } } \",\"为什么返回的是Object而不是int? 主要原因是Object类型更通用\",\"在环绕通知中是可以对原始方法返回值就行修改的\"]},{\"header\":\"返回后通知\",\"slug\":\"返回后通知\",\"contents\":[\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Pointcut(\\\"execution(int com.itheima.dao.BookDao.select())\\\") private void pt2(){} @AfterReturning(\\\"pt2()\\\") public void afterReturning() { System.out.println(\\\"afterReturning advice ...\\\"); } } \",\"返回后通知是需要在原始方法select正常执行后才会被执行，如果select()方法执行的过程中出现了异常，那么返回后通知是不会被执行，后置通知是不管原始方法有没有抛出异常都会被执行\"]},{\"header\":\"异常后通知\",\"slug\":\"异常后通知\",\"contents\":[\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(void com.itheima.dao.BookDao.update())\\\") private void pt(){} @Pointcut(\\\"execution(int com.itheima.dao.BookDao.select())\\\") private void pt2(){} @AfterReturning(\\\"pt2()\\\") public void afterThrowing() { System.out.println(\\\"afterThrowing advice ...\\\"); } } \",\"异常后通知是需要原始方法抛出异常，可以在select()方法中添加一行代码int i = 1/0即可，如果没有抛异常，异常后通知将不会被执行\",\"思考\",\"环绕通知是如何实现其他通知类型的功能的?\",\"因为环绕通知是可以控制原始方法执行的，把增强的代码写在调用原始方法的不同位置就可以实现不同的通知类型的功能，如:\"]},{\"header\":\"通知类型总结\",\"slug\":\"通知类型总结\",\"contents\":[]},{\"header\":\"知识点1：@After\",\"slug\":\"知识点1-after\",\"contents\":[\"名称\",\"@After\",\"类型\",\"方法注解\",\"位置\",\"通知方法定义上方\",\"作用\",\"设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行\"]},{\"header\":\"知识点2：@AfterReturning\",\"slug\":\"知识点2-afterreturning\",\"contents\":[\"名称\",\"@AfterReturning\",\"类型\",\"方法注解\",\"位置\",\"通知方法定义上方\",\"作用\",\"设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法正常执行完毕后执行\"]},{\"header\":\"知识点3：@AfterThrowing\",\"slug\":\"知识点3-afterthrowing\",\"contents\":[\"名称\",\"@AfterThrowing\",\"类型\",\"方法注解\",\"位置\",\"通知方法定义上方\",\"作用\",\"设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行\"]},{\"header\":\"知识点4：@Around\",\"slug\":\"知识点4-around\",\"contents\":[\"名称\",\"@Around\",\"类型\",\"方法注解\",\"位置\",\"通知方法定义上方\",\"作用\",\"设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行\",\"环绕通知注意事项:\",\"环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知\",\"通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行\",\"对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型\",\"原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object\",\"由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常\"]},{\"header\":\"4.3 业务层接口执行效率\",\"slug\":\"_4-3-业务层接口执行效率\",\"contents\":[]},{\"header\":\"4.3.1 需求分析\",\"slug\":\"_4-3-1-需求分析\",\"contents\":[\"这个需求也比较简单，前面我们在介绍AOP的时候已经演示过:\",\"需求:任意业务层接口执行均可显示其执行效率（执行时长）\",\"这个案例的目的是查看每个业务层执行的时间，这样就可以监控出哪个业务比较耗时，将其查找出来方便优化\",\"具体实现的思路:\",\"(1) 开始执行方法之前记录一个时间\",\"(2) 开始执行方法\",\"(3) 执行完方法之后记录一个时间\",\"(4) 用后一个时间减去前一个时间的差值，就是我们需要的结果\",\"所以要在方法执行的前后添加业务，经过分析我们将采用环绕通知\",\"**说明:**原始方法如果只执行一次，时间太快，两个时间差可能为0，所以我们要执行万次来计算时间差\"]},{\"header\":\"4.3.2 环境准备\",\"slug\":\"_4-3-2-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.aspectj</groupId> <artifactId>aspectjweaver</artifactId> <version>1.9.4</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.47</version> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.6</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>1.3.0</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> </dependencies> \",\"添加AccountService、AccountServiceImpl、AccountDao与Account类\",\"public interface AccountService { void save(Account account); void delete(Integer id); void update(Account account); List<Account> findAll(); Account findById(Integer id); } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void save(Account account) { accountDao.save(account); } public void update(Account account){ accountDao.update(account); } public void delete(Integer id) { accountDao.delete(id); } public Account findById(Integer id) { return accountDao.findById(id); } public List<Account> findAll() { return accountDao.findAll(); } } public interface AccountDao { @Insert(\\\"insert into tbl_account(name,money)values(#{name},#{money})\\\") void save(Account account); @Delete(\\\"delete from tbl_account where id = #{id} \\\") void delete(Integer id); @Update(\\\"update tbl_account set name = #{name} , money = #{money} where id = #{id} \\\") void update(Account account); @Select(\\\"select * from tbl_account\\\") List<Account> findAll(); @Select(\\\"select * from tbl_account where id = #{id} \\\") Account findById(Integer id); } public class Account implements Serializable { private Integer id; private String name; private Double money; //setter..getter..toString方法省略 } \",\"resources下提供一个jdbc.properties\",\"jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root \",\"创建相关配置类\",\"//Spring配置类:SpringConfig @Configuration @ComponentScan(\\\"com.itheima\\\") @PropertySource(\\\"classpath:jdbc.properties\\\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } //JdbcConfig配置类 public class JdbcConfig { @Value(\\\"${jdbc.driver}\\\") private String driver; @Value(\\\"${jdbc.url}\\\") private String url; @Value(\\\"${jdbc.username}\\\") private String userName; @Value(\\\"${jdbc.password}\\\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } //MybatisConfig配置类 public class MybatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\\\"com.itheima.domain\\\"); ssfb.setDataSource(dataSource); return ssfb; } @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\\\"com.itheima.dao\\\"); return msc; } } \",\"编写Spring整合Junit的测试类\",\"@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTestCase { @Autowired private AccountService accountService; @Test public void testFindById(){ Account ac = accountService.findById(2); } @Test public void testFindAll(){ List<Account> all = accountService.findAll(); } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"4.3.3 功能开发\",\"slug\":\"_4-3-3-功能开发\",\"contents\":[]},{\"header\":\"步骤1:开启SpringAOP的注解功能\",\"slug\":\"步骤1-开启springaop的注解功能\",\"contents\":[\"在Spring的主配置文件SpringConfig类中添加注解\",\"@EnableAspectJAutoProxy \"]},{\"header\":\"步骤2:创建AOP的通知类\",\"slug\":\"步骤2-创建aop的通知类\",\"contents\":[\"该类要被Spring管理，需要添加@Component\",\"要标识该类是一个AOP的切面类，需要添加@Aspect\",\"配置切入点表达式，需要添加一个方法，并添加@Pointcut\",\"@Component @Aspect public class ProjectAdvice { //配置业务层的所有方法 @Pointcut(\\\"execution(* com.itheima.service.*Service.*(..))\\\") private void servicePt(){} public void runSpeed(){ } } \"]},{\"header\":\"步骤3:添加环绕通知\",\"slug\":\"步骤3-添加环绕通知\",\"contents\":[\"在runSpeed()方法上添加@Around\",\"@Component @Aspect public class ProjectAdvice { //配置业务层的所有方法 @Pointcut(\\\"execution(* com.itheima.service.*Service.*(..))\\\") private void servicePt(){} //@Around(\\\"ProjectAdvice.servicePt()\\\") 可以简写为下面的方式 @Around(\\\"servicePt()\\\") public Object runSpeed(ProceedingJoinPoint pjp){ Object ret = pjp.proceed(); return ret; } } \",\"**注意:**目前并没有做任何增强\"]},{\"header\":\"步骤4:完成核心业务，记录万次执行的时间\",\"slug\":\"步骤4-完成核心业务-记录万次执行的时间\",\"contents\":[\"@Component @Aspect public class ProjectAdvice { //配置业务层的所有方法 @Pointcut(\\\"execution(* com.itheima.service.*Service.*(..))\\\") private void servicePt(){} //@Around(\\\"ProjectAdvice.servicePt()\\\") 可以简写为下面的方式 @Around(\\\"servicePt()\\\") public void runSpeed(ProceedingJoinPoint pjp){ long start = System.currentTimeMillis(); for (int i = 0; i < 10000; i++) { pjp.proceed(); } long end = System.currentTimeMillis(); System.out.println(\\\"业务层接口万次执行时间: \\\"+(end-start)+\\\"ms\\\"); } } \"]},{\"header\":\"步骤5:运行单元测试类\",\"slug\":\"步骤5-运行单元测试类\",\"contents\":[\"**注意:**因为程序每次执行的时候是不一样的，所以运行多次最终的结果是不一样的\"]},{\"header\":\"步骤6:程序优化\",\"slug\":\"步骤6-程序优化\",\"contents\":[\"目前程序所面临的问题是，多个方法一起执行测试的时候，控制台都打印的是:\",\"业务层接口万次执行时间:xxxms\",\"我们没有办法区分到底是哪个接口的哪个方法执行的具体时间，具体如何优化?\",\"@Component @Aspect public class ProjectAdvice { //配置业务层的所有方法 @Pointcut(\\\"execution(* com.itheima.service.*Service.*(..))\\\") private void servicePt(){} //@Around(\\\"ProjectAdvice.servicePt()\\\") 可以简写为下面的方式 @Around(\\\"servicePt()\\\") public void runSpeed(ProceedingJoinPoint pjp){ //获取执行签名信息 Signature signature = pjp.getSignature(); //通过签名获取执行操作名称(接口名) String className = signature.getDeclaringTypeName(); //通过签名获取执行操作名称(方法名) String methodName = signature.getName(); long start = System.currentTimeMillis(); for (int i = 0; i < 10000; i++) { pjp.proceed(); } long end = System.currentTimeMillis(); System.out.println(\\\"万次执行：\\\"+ className+\\\".\\\"+methodName+\\\"---->\\\" +(end-start) + \\\"ms\\\"); } } \"]},{\"header\":\"步骤7:运行单元测试类\",\"slug\":\"步骤7-运行单元测试类\",\"contents\":[\"补充说明:\",\"当前测试的接口执行效率仅仅是一个理论值，并不是一次完整的执行过程\",\"这块只是通过该案例把AOP的使用进行了学习，具体的实际值是有很多因素共同决定的\"]},{\"header\":\"4.4 AOP通知获取数据\",\"slug\":\"_4-4-aop通知获取数据\",\"contents\":[\"目前我们写AOP仅仅是在原始方法前后追加一些操作，接下来我们要说说AOP中数据相关的内容，我们将从获取参数、获取返回值和获取异常三个方面来研究切入点的相关信息\",\"前面我们介绍通知类型的时候总共讲了五种，那么对于这五种类型都会有参数，返回值和异常吗?\",\"我们先来一个个分析下:\",\"获取切入点方法的参数，所有的通知类型都可以获取参数 \",\"JoinPoint：适用于前置、后置、返回后、抛出异常后通知\",\"ProceedingJoinPoint：适用于环绕通知\",\"获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究 \",\"返回后通知\",\"环绕通知\",\"获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究 \",\"抛出异常后通知\",\"环绕通知\"]},{\"header\":\"4.4.1 环境准备\",\"slug\":\"_4-4-1-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.aspectj</groupId> <artifactId>aspectjweaver</artifactId> <version>1.9.4</version> </dependency> </dependencies> \",\"添加BookDao和BookDaoImpl类\",\"public interface BookDao { public String findName(int id); } @Repository public class BookDaoImpl implements BookDao { public String findName(int id) { System.out.println(\\\"id:\\\"+id); return \\\"itcast\\\"; } } \",\"创建Spring的配置类\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") @EnableAspectJAutoProxy public class SpringConfig { } \",\"编写通知类\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(* com.itheima.dao.BookDao.findName(..))\\\") private void pt(){} @Before(\\\"pt()\\\") public void before() { System.out.println(\\\"before advice ...\\\" ); } @After(\\\"pt()\\\") public void after() { System.out.println(\\\"after advice ...\\\"); } @Around(\\\"pt()\\\") public Object around() throws Throwable{ Object ret = pjp.proceed(); return ret; } @AfterReturning(\\\"pt()\\\") public void afterReturning() { System.out.println(\\\"afterReturning advice ...\\\"); } @AfterThrowing(\\\"pt()\\\") public void afterThrowing() { System.out.println(\\\"afterThrowing advice ...\\\"); } } \",\"编写App运行类\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); String name = bookDao.findName(100); System.out.println(name); } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"4.4.2 获取参数\",\"slug\":\"_4-4-2-获取参数\",\"contents\":[]},{\"header\":\"非环绕通知获取方式\",\"slug\":\"非环绕通知获取方式\",\"contents\":[\"在方法上添加JoinPoint,通过JoinPoint来获取参数\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(* com.itheima.dao.BookDao.findName(..))\\\") private void pt(){} @Before(\\\"pt()\\\") public void before(JoinPoint jp) Object[] args = jp.getArgs(); System.out.println(Arrays.toString(args)); System.out.println(\\\"before advice ...\\\" ); //...其他的略 } \",\"运行App类，可以获取如下内容，说明参数100已经被获取\",\"思考:方法的参数只有一个，为什么获取的是一个数组?\",\"因为参数的个数是不固定的，所以使用数组更通配些\",\"如果将参数改成两个会是什么效果呢?\",\"(1)修改BookDao接口和BookDaoImpl实现类\",\"public interface BookDao { public String findName(int id,String password); } @Repository public class BookDaoImpl implements BookDao { public String findName(int id,String password) { System.out.println(\\\"id:\\\"+id); return \\\"itcast\\\"; } } \",\"(2)修改App类，调用方法传入多个参数\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); BookDao bookDao = ctx.getBean(BookDao.class); String name = bookDao.findName(100,\\\"itheima\\\"); System.out.println(name); } } \",\"(3)运行App，查看结果,说明两个参数都已经被获取到\",\"1630233548743\",\"说明:\",\"使用JoinPoint的方式获取参数适用于前置、后置、返回后、抛出异常后通知。剩下的大家自行去验证\"]},{\"header\":\"环绕通知获取方式\",\"slug\":\"环绕通知获取方式\",\"contents\":[\"环绕通知使用的是ProceedingJoinPoint，因为ProceedingJoinPoint是JoinPoint类的子类，所以对于ProceedingJoinPoint类中应该也会有对应的getArgs()方法，我们去验证下:\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(* com.itheima.dao.BookDao.findName(..))\\\") private void pt(){} @Around(\\\"pt()\\\") public Object around(ProceedingJoinPoint pjp)throws Throwable { Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); Object ret = pjp.proceed(); return ret; } //其他的略 } \",\"运行App后查看运行结果，说明ProceedingJoinPoint也是可以通过getArgs()获取参数\",\"注意:\",\"pjp.proceed()方法是有两个构造方法，分别是:\",\"调用无参数的proceed，当原始方法有参数，会在调用的过程中自动传入参数\",\"所以调用这两个方法的任意一个都可以完成功能\",\"但是当需要修改原始方法的参数时，就只能采用带有参数的方法,如下:\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(* com.itheima.dao.BookDao.findName(..))\\\") private void pt(){} @Around(\\\"pt()\\\") public Object around(ProceedingJoinPoint pjp) throws Throwable{ Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = pjp.proceed(args); return ret; } //其他的略 } \",\"有了这个特性后，我们就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，保证代码的健壮性\"]},{\"header\":\"4.4.3 获取返回值\",\"slug\":\"_4-4-3-获取返回值\",\"contents\":[\"对于返回值，只有返回后AfterReturing和环绕Around这两个通知类型可以获取，具体如何获取?\"]},{\"header\":\"环绕通知获取返回值\",\"slug\":\"环绕通知获取返回值\",\"contents\":[\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(* com.itheima.dao.BookDao.findName(..))\\\") private void pt(){} @Around(\\\"pt()\\\") public Object around(ProceedingJoinPoint pjp) throws Throwable{ Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = pjp.proceed(args); return ret; } //其他的略 } \",\"上述代码中，ret就是方法的返回值，我们是可以直接获取，不但可以获取，如果需要还可以进行修改\"]},{\"header\":\"返回后通知获取返回值\",\"slug\":\"返回后通知获取返回值\",\"contents\":[\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(* com.itheima.dao.BookDao.findName(..))\\\") private void pt(){} @AfterReturning(value = \\\"pt()\\\",returning = \\\"ret\\\") public void afterReturning(Object ret) { System.out.println(\\\"afterReturning advice ...\\\"+ret); } //其他的略 } \",\"注意:\",\"(1)参数名的问题\",\"(2)afterReturning方法参数类型的问题\",\"参数类型可以写成String，但是为了能匹配更多的参数类型，建议写成Object类型\",\"(3)afterReturning方法参数的顺序问题\",\"运行App后查看运行结果，说明返回值已经被获取到\"]},{\"header\":\"4.4.4 获取异常\",\"slug\":\"_4-4-4-获取异常\",\"contents\":[\"对于获取抛出的异常，只有抛出异常后AfterThrowing和环绕Around这两个通知类型可以获取，具体如何获取?\"]},{\"header\":\"环绕通知获取异常\",\"slug\":\"环绕通知获取异常\",\"contents\":[\"这块比较简单，以前我们是抛出异常，现在只需要将异常捕获，就可以获取到原始方法的异常信息了\",\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(* com.itheima.dao.BookDao.findName(..))\\\") private void pt(){} @Around(\\\"pt()\\\") public Object around(ProceedingJoinPoint pjp){ Object[] args = pjp.getArgs(); System.out.println(Arrays.toString(args)); args[0] = 666; Object ret = null; try{ ret = pjp.proceed(args); }catch(Throwable throwable){ t.printStackTrace(); } return ret; } //其他的略 } \",\"在catch方法中就可以获取到异常，至于获取到异常以后该如何处理，这个就和你的业务需求有关了\"]},{\"header\":\"抛出异常后通知获取异常\",\"slug\":\"抛出异常后通知获取异常\",\"contents\":[\"@Component @Aspect public class MyAdvice { @Pointcut(\\\"execution(* com.itheima.dao.BookDao.findName(..))\\\") private void pt(){} @AfterThrowing(value = \\\"pt()\\\",throwing = \\\"t\\\") public void afterThrowing(Throwable t) { System.out.println(\\\"afterThrowing advice ...\\\"+t); } //其他的略 } \",\"如何让原始方法抛出异常，方式有很多，\",\"@Repository public class BookDaoImpl implements BookDao { public String findName(int id,String password) { System.out.println(\\\"id:\\\"+id); if(true){ throw new NullPointerException(); } return \\\"itcast\\\"; } } \",\"注意:\",\"运行App后，查看控制台，就能看的异常信息被打印到控制台\",\"至此，AOP通知如何获取数据就已经讲解完了，数据中包含参数、返回值、异常(了解)\"]},{\"header\":\"4.5 百度网盘密码数据兼容处理\",\"slug\":\"_4-5-百度网盘密码数据兼容处理\",\"contents\":[]},{\"header\":\"4.5.1 需求分析\",\"slug\":\"_4-5-1-需求分析\",\"contents\":[\"需求: 对百度网盘分享链接输入密码时尾部多输入的空格做兼容处理\",\"问题描述:\",\"点击链接，会提示，请输入提取码，如下图所示\",\"当我们从别人发给我们的内容中复制提取码的时候，有时候会多复制到一些空格，直接粘贴到百度的提取码输入框\",\"但是百度那边记录的提取码是没有空格的\",\"这个时候如果不做处理，直接对比的话，就会引发提取码不一致，导致无法访问百度盘上的内容\",\"所以多输入一个空格可能会导致项目的功能无法正常使用\",\"此时我们就想能不能考虑输入的参数先帮用户去掉空格再操作呢?\",\"答案是可以的，我们只需要在业务方法执行之前对所有的输入参数进行格式处理——trim()\",\"是对所有的参数都需要去除空格么?\",\"也没有必要，一般只需要针对字符串处理即可\",\"以后涉及到需要去除前后空格的业务可能会有很多，这个去空格的代码是每个业务都写么?\",\"可以考虑使用AOP来统一处理\",\"AOP有五种通知类型，该使用哪种呢?\",\"我们的需求是将原始方法的参数处理后在参与原始方法的调用，能做这件事的就只有环绕通知\",\"综上所述，我们需要考虑两件事: ①：在业务方法执行之前对所有的输入参数进行格式处理——trim() ②：使用处理后的参数调用原始方法——环绕通知中存在对原始方法的调用\"]},{\"header\":\"4.5.2 环境准备\",\"slug\":\"_4-5-2-环境准备\",\"contents\":[\"创建一个Maven项目\",\"pom.xml添加Spring依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.aspectj</groupId> <artifactId>aspectjweaver</artifactId> <version>1.9.4</version> </dependency> </dependencies> \",\"添加ResourcesService，ResourcesServiceImpl,ResourcesDao和ResourcesDaoImpl类\",\"public interface ResourcesDao { boolean readResources(String url, String password); } @Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { //模拟校验 return password.equals(\\\"root\\\"); } } public interface ResourcesService { public boolean openURL(String url ,String password); } @Service public class ResourcesServiceImpl implements ResourcesService { @Autowired private ResourcesDao resourcesDao; public boolean openURL(String url, String password) { return resourcesDao.readResources(url,password); } } \",\"创建Spring的配置类\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") public class SpringConfig { } \",\"编写App运行类\",\"public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); ResourcesService resourcesService = ctx.getBean(ResourcesService.class); boolean flag = resourcesService.openURL(\\\"http://pan.baidu.com/haha\\\", \\\"root\\\"); System.out.println(flag); } } \",\"最终创建好的项目结构如下:\",\"现在项目的效果是，当输入密码为root控制台打印为true,如果密码改为root控制台打印的是false\",\"我们想在的需求是使用AOP将参数进行统一处理，不管输入的密码root前后包含多少个空格，最终控制台打印的都是true\"]},{\"header\":\"4.5.3 具体实现\",\"slug\":\"_4-5-3-具体实现\",\"contents\":[]},{\"header\":\"步骤1: 开启SpringAOP的注解功能\",\"slug\":\"步骤1-开启springaop的注解功能-1\",\"contents\":[\"@Configuration @ComponentScan(\\\"com.itheima\\\") @EnableAspectJAutoProxy public class SpringConfig { } \"]},{\"header\":\"步骤2:编写通知类\",\"slug\":\"步骤2-编写通知类\",\"contents\":[\"@Component @Aspect public class DataAdvice { @Pointcut(\\\"execution(boolean com.itheima.service.*Service.*(*,*))\\\") private void servicePt(){} } \"]},{\"header\":\"步骤3: 添加环绕通知\",\"slug\":\"步骤3-添加环绕通知-1\",\"contents\":[\"@Component @Aspect public class DataAdvice { @Pointcut(\\\"execution(boolean com.itheima.service.*Service.*(*,*))\\\") private void servicePt(){} @Around(\\\"DataAdvice.servicePt()\\\") // @Around(\\\"servicePt()\\\")这两种写法都对 public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { Object ret = pjp.proceed(); return ret; } } \"]},{\"header\":\"步骤4:完成核心业务，处理参数中的空格\",\"slug\":\"步骤4-完成核心业务-处理参数中的空格\",\"contents\":[\"@Component @Aspect public class DataAdvice { @Pointcut(\\\"execution(boolean com.itheima.service.*Service.*(*,*))\\\") private void servicePt(){} @Around(\\\"DataAdvice.servicePt()\\\") // @Around(\\\"servicePt()\\\")这两种写法都对 public Object trimStr(ProceedingJoinPoint pjp) throws Throwable { //获取原始方法的参数 Object[] args = pjp.getArgs(); for (int i = 0; i < args.length; i++) { //判断参数是不是字符串 if(args[i].getClass().equals(String.class)){ args[i] = args[i].toString().trim(); } } //将修改后的参数传入到原始方法的执行中 Object ret = pjp.proceed(args); return ret; } } \"]},{\"header\":\"步骤5: 运行程序\",\"slug\":\"步骤5-运行程序-1\",\"contents\":[\"不管密码root前后是否加空格，最终控制台打印的都是true\"]},{\"header\":\"步骤6:优化测试\",\"slug\":\"步骤6-优化测试\",\"contents\":[\"为了能更好的看出AOP已经生效，我们可以修改ResourcesImpl类，在方法中将密码的长度进行打印\",\"@Repository public class ResourcesDaoImpl implements ResourcesDao { public boolean readResources(String url, String password) { System.out.println(password.length()); //模拟校验 return password.equals(\\\"root\\\"); } } \",\"再次运行成功，就可以根据最终打印的长度来看看，字符串的空格有没有被去除掉\",\"注意：\",\"1630242491831\"]},{\"header\":\"5 AOP总结\",\"slug\":\"_5-aop总结\",\"contents\":[\"AOP的知识就已经讲解完了，接下来对于AOP的知识进行一个总结:\"]},{\"header\":\"5.1 AOP的核心概念\",\"slug\":\"_5-1-aop的核心概念\",\"contents\":[\"概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式\",\"作用：在不惊动原始设计的基础上为方法进行功能增强\",\"核心概念 \",\"代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的\",\"连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行\",\"切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述\",\"通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法\",\"切面（Aspect）：描述通知与切入点的对应关系\",\"目标对象（Target）：被代理的原始对象成为目标对象\"]},{\"header\":\"5.2 切入点表达式\",\"slug\":\"_5-2-切入点表达式\",\"contents\":[\"切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类/接口名.方法名（参数）异常名)\",\"execution(* com.itheima.service.*Service.*(..)) \",\"切入点表达式描述通配符：\",\"作用：用于快速描述，范围描述\",\"*：匹配任意符号（常用）\",\".. ：匹配多个连续的任意符号（常用）\",\"+：匹配子类类型\",\"切入点表达式书写技巧\",\"1.按标准规范开发 2.查询操作的返回值建议使用*匹配 3.减少使用..的形式描述包 4.对接口进行描述，使用*表示模块名，例如UserService的匹配描述为*Service 5.方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy* 6.参数根据实际情况灵活调整\"]},{\"header\":\"5.3 五种通知类型\",\"slug\":\"_5-3-五种通知类型\",\"contents\":[\"前置通知\",\"后置通知\",\"环绕通知（重点） \",\"环绕通知依赖形参ProceedingJoinPoint才能实现对原始方法的调用\",\"环绕通知可以隔离原始方法的调用执行\",\"环绕通知返回值设置为Object类型\",\"环绕通知中可以对原始方法调用过程中出现的异常进行处理\",\"返回后通知\",\"抛出异常后通知\"]},{\"header\":\"5.4 通知中获取参数\",\"slug\":\"_5-4-通知中获取参数\",\"contents\":[\"获取切入点方法的参数，所有的通知类型都可以获取参数 \",\"JoinPoint：适用于前置、后置、返回后、抛出异常后通知\",\"ProceedingJoinPoint：适用于环绕通知\",\"获取切入点方法返回值，前置和抛出异常后通知是没有返回值，后置通知可有可无，所以不做研究 \",\"返回后通知\",\"环绕通知\",\"获取切入点方法运行异常信息，前置和返回后通知是不会有，后置通知可有可无，所以不做研究 \",\"抛出异常后通知\",\"环绕通知\"]},{\"header\":\"6 AOP事务管理\",\"slug\":\"_6-aop事务管理\",\"contents\":[]},{\"header\":\"6.1 Spring事务简介\",\"slug\":\"_6-1-spring事务简介\",\"contents\":[]},{\"header\":\"6.1.1 相关概念介绍\",\"slug\":\"_6-1-1-相关概念介绍\",\"contents\":[\"事务作用：在数据层保障一系列的数据库操作同成功同失败\",\"Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败\",\"数据层有事务我们可以理解，为什么业务层也需要处理事务呢?\",\"举个简单的例子，\",\"转账业务，在转业务中会有两次数据层的调用，一次是加钱一次是减钱\",\"把事务放在数据层，加钱和减钱就有两个事务\",\"没办法保证加钱和减钱同时成功或者同时失败\",\"这个时候就需要将事务放在业务层进行处理\",\"Spring为了管理事务，提供了一个平台事务管理器PlatformTransactionManager\",\"commit是用来提交事务，rollback是用来回滚事务\",\"PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现:\",\"从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个DataSourceTransactionManager事务管理器。\"]},{\"header\":\"6.1.2 转账案例-需求分析\",\"slug\":\"_6-1-2-转账案例-需求分析\",\"contents\":[\"接下来通过一个案例来学习下Spring是如何来管理事务的\",\"先来分析下需求:\",\"需求: 实现任意两个账户间转账操作\",\"需求微缩: A账户减钱，B账户加钱\",\"为了实现上述的业务需求，我们可以按照下面步骤来实现下: ①：数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney） ②：业务层提供转账操作（transfer），调用减钱与加钱的操作 ③：提供2个账号和操作金额执行转账操作 ④：基于Spring整合MyBatis环境搭建上述操作\"]},{\"header\":\"6.1.3 转账案例-环境搭建\",\"slug\":\"_6-1-3-转账案例-环境搭建\",\"contents\":[]},{\"header\":\"步骤1:准备数据库表\",\"slug\":\"步骤1-准备数据库表\",\"contents\":[\"之前我们在整合Mybatis的时候已经创建了这个表,可以直接使用\",\"create database spring_db character set utf8; use spring_db; create table tbl_account( id int primary key auto_increment, name varchar(35), money double ); insert into tbl_account values(1,'Tom',1000); insert into tbl_account values(2,'Jerry',1000); \"]},{\"header\":\"步骤2:创建项目导入jar包\",\"slug\":\"步骤2-创建项目导入jar包\",\"contents\":[\"项目的pom.xml添加相关依赖\",\"<dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-context</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.6</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.47</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>1.3.0</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> \"]},{\"header\":\"步骤3:根据表创建模型类\",\"slug\":\"步骤3-根据表创建模型类\",\"contents\":[\"public class Account implements Serializable { private Integer id; private String name; private Double money; //setter...getter...toString...方法略 } \"]},{\"header\":\"步骤4:创建Dao接口\",\"slug\":\"步骤4-创建dao接口\",\"contents\":[\"public interface AccountDao { @Update(\\\"update tbl_account set money = money + #{money} where name = #{name}\\\") void inMoney(@Param(\\\"name\\\") String name, @Param(\\\"money\\\") Double money); @Update(\\\"update tbl_account set money = money - #{money} where name = #{name}\\\") void outMoney(@Param(\\\"name\\\") String name, @Param(\\\"money\\\") Double money); } \"]},{\"header\":\"步骤5:创建Service接口和实现类\",\"slug\":\"步骤5-创建service接口和实现类\",\"contents\":[\"public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); accountDao.inMoney(in,money); } } \"]},{\"header\":\"步骤6:添加jdbc.properties文件\",\"slug\":\"步骤6-添加jdbc-properties文件\",\"contents\":[\"jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_db?useSSL=false jdbc.username=root jdbc.password=root \"]},{\"header\":\"步骤7:创建JdbcConfig配置类\",\"slug\":\"步骤7-创建jdbcconfig配置类\",\"contents\":[\"public class JdbcConfig { @Value(\\\"${jdbc.driver}\\\") private String driver; @Value(\\\"${jdbc.url}\\\") private String url; @Value(\\\"${jdbc.username}\\\") private String userName; @Value(\\\"${jdbc.password}\\\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } \"]},{\"header\":\"步骤8:创建MybatisConfig配置类\",\"slug\":\"步骤8-创建mybatisconfig配置类\",\"contents\":[\"public class MybatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\\\"com.itheima.domain\\\"); ssfb.setDataSource(dataSource); return ssfb; } @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\\\"com.itheima.dao\\\"); return msc; } } \"]},{\"header\":\"步骤9:创建SpringConfig配置类\",\"slug\":\"步骤9-创建springconfig配置类\",\"contents\":[\"@Configuration @ComponentScan(\\\"com.itheima\\\") @PropertySource(\\\"classpath:jdbc.properties\\\") @Import({JdbcConfig.class,MybatisConfig.class}) public class SpringConfig { } \"]},{\"header\":\"步骤10:编写测试类\",\"slug\":\"步骤10-编写测试类\",\"contents\":[\"@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class AccountServiceTest { @Autowired private AccountService accountService; @Test public void testTransfer() throws IOException { accountService.transfer(\\\"Tom\\\",\\\"Jerry\\\",100D); } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"6.1.4 事务管理\",\"slug\":\"_6-1-4-事务管理\",\"contents\":[\"上述环境，运行单元测试类，会执行转账操作，Tom的账户会减少100，Jerry的账户会加100\",\"这是正常情况下的运行结果，但是如果在转账的过程中出现了异常，如:\",\"@Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } \",\"这个时候就模拟了转账过程中出现异常的情况，正确的操作应该是转账出问题了，Tom应该还是900，Jerry应该还是1100，但是真正运行后会发现，并没有像我们想象的那样，Tom账户为800而Jerry还是1100,100块钱凭空消息了，银行乐疯了，如果把转账换个顺序，银行就该哭了\",\"不管哪种情况，都是不允许出现的，对刚才的结果我们做一个分析: ①：程序正常执行时，账户金额A减B加，没有问题 ②：程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败\",\"当程序出问题后，我们需要让事务进行回滚，而且这个事务应该是加在业务层上，而Spring的事务管理就是用来解决这类问题的\",\"Spring事务管理具体的实现步骤为:\"]},{\"header\":\"步骤1:在需要被事务管理的方法上添加注解\",\"slug\":\"步骤1-在需要被事务管理的方法上添加注解\",\"contents\":[\"public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) { accountDao.outMoney(out,money); int i = 1/0; accountDao.inMoney(in,money); } } \",\"注意:\",\"@Transactional可以写在接口上、接口方法上、类上和类方法上\",\"写在接口上，该接口的所有实现类的所有方法都会有事务\",\"写在接口方法上，该接口的所有实现类的该方法都会有事务\",\"写在类上，该类中的所有方法都会有事务\",\"写在类方法上，该方法上有事务\",\"Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合\"]},{\"header\":\"步骤2:在JdbcConfig类中配置事务管理器\",\"slug\":\"步骤2-在jdbcconfig类中配置事务管理器\",\"contents\":[\"public class JdbcConfig { @Value(\\\"${jdbc.driver}\\\") private String driver; @Value(\\\"${jdbc.url}\\\") private String url; @Value(\\\"${jdbc.username}\\\") private String userName; @Value(\\\"${jdbc.password}\\\") private String password; @Bean public DataSource dataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } //配置事务管理器，mybatis使用的是jdbc事务 @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } } \",\"**注意：**事务管理器要根据实现技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用DataSourceTransactionManager\"]},{\"header\":\"步骤3：开启事务注解\",\"slug\":\"步骤3-开启事务注解\",\"contents\":[\"在SpringConfig的配置类中开启\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") @PropertySource(\\\"classpath:jdbc.properties\\\") @Import({JdbcConfig.class,MybatisConfig.class //开启注解式事务驱动 @EnableTransactionManagement public class SpringConfig { } \"]},{\"header\":\"步骤4:运行测试类\",\"slug\":\"步骤4-运行测试类\",\"contents\":[\"会发现在转换的业务出现错误后，事务就可以控制回顾，保证数据的正确性\"]},{\"header\":\"知识点1：@EnableTransactionManagement\",\"slug\":\"知识点1-enabletransactionmanagement\",\"contents\":[\"名称\",\"@EnableTransactionManagement\",\"类型\",\"配置类注解\",\"位置\",\"配置类定义上方\",\"作用\",\"设置当前Spring环境中开启注解式事务支持\"]},{\"header\":\"知识点2：@Transactional\",\"slug\":\"知识点2-transactional\",\"contents\":[\"名称\",\"@Transactional\",\"类型\",\"接口注解 类注解 方法注解\",\"位置\",\"业务层接口上方 业务层实现类上方 业务方法上方\",\"作用\",\"为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）\"]},{\"header\":\"6.2 Spring事务角色\",\"slug\":\"_6-2-spring事务角色\",\"contents\":[\"这节中我们重点要理解两个概念，分别是事务管理员和事务协调员\",\"未开启Spring事务之前:\",\"AccountDao的outMoney因为是修改操作，会开启一个事务T1\",\"AccountDao的inMoney因为是修改操作，会开启一个事务T2\",\"AccountService的transfer没有事务，\",\"运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确\",\"运行过程中如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行\",\"就会导致数据出现错误\",\"开启Spring的事务管理后\",\"transfer上添加了@Transactional注解，在该方法上就会有一个事务T\",\"AccountDao的outMoney方法的事务T1加入到transfer的事务T中\",\"AccountDao的inMoney方法的事务T2加入到transfer的事务T中\",\"这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性\",\"通过上面例子的分析，我们就可以得到如下概念:\",\"事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法\",\"事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法\",\"注意:\",\"目前的事务管理是基于DataSourceTransactionManager和SqlSessionFactoryBean使用的是同一个数据源\"]},{\"header\":\"6.3 Spring事务属性\",\"slug\":\"_6-3-spring事务属性\",\"contents\":[\"上一节我们介绍了两个概念，事务的管理员和事务的协同员，对于这两个概念具体做什么的，我们待会通过案例来使用下，处理这两个概念，还有就是事务的其他相关配置都有哪些，就是我们接下来要学习的内容\",\"在这一节中，我们主要学习三部分内容事务配置、转账业务追加日志、事务传播行为\"]},{\"header\":\"6.3.1 事务配置\",\"slug\":\"_6-3-1-事务配置\",\"contents\":[\"上面这些属性都可以在@Transactional注解的参数上进行设置\",\"readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true\",\"timeout:设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间\",\"rollbackFor:当出现指定异常进行事务回滚\",\"noRollbackFor:当出现指定异常不进行事务回滚\",\"思考:出现异常事务会自动回滚，这个是我们之前就已经知道的\",\"noRollbackFor是设定对于指定的异常不回滚，这个好理解\",\"rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?\",\"这块需要更正一个知识点，并不是所有的异常都会回滚事务，比如下面的代码就不会回滚\",\"public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money) throws IOException; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; public void transfer(String out,String in ,Double money) throws IOException{ accountDao.outMoney(out,money); //int i = 1/0; //这个异常事务会回滚 if(true){ throw new IOException(); //这个异常事务就不会回滚 } accountDao.inMoney(in,money); } } \",\"出现这个问题的原因是，Spring的事务只会对Error异常和RuntimeException异常及其子类进行事务回顾，其他的异常类型是不会回滚的，对应IOException不符合上述条件所以不回滚\",\"此时就可以使用rollbackFor属性来设置出现IOException异常不回滚\",\"public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ //配置当前接口方法具有事务 @Transactional(rollbackFor = {IOException.class}) public void transfer(String out,String in ,Double money)throws IOException ; } \",\"rollbackForClassName等同于rollbackFor,只不过属性为异常的类全名字符串\",\"noRollbackForClassName等同于noRollbackFor，只不过属性为异常的类全名字符串\",\"isolation设置事务的隔离级别\",\"DEFAULT :默认隔离级别, 会采用数据库的隔离级别\",\"READ_UNCOMMITTED : 读未提交\",\"READ_COMMITTED : 读已提交\",\"REPEATABLE_READ : 重复读取\",\"SERIALIZABLE: 串行化\",\"介绍完上述属性后，还有最后一个事务的传播行为，为了讲解该属性的设置，我们需要完成下面的案例\"]},{\"header\":\"6.3.2 转账业务追加日志案例\",\"slug\":\"_6-3-2-转账业务追加日志案例\",\"contents\":[]},{\"header\":\"6.3.2.1 需求分析\",\"slug\":\"_6-3-2-1-需求分析\",\"contents\":[\"在前面的转案例的基础上添加新的需求，完成转账后记录日志\",\"需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕\",\"需求微缩：A账户减钱，B账户加钱，数据库记录日志\",\"基于上述的业务需求，我们来分析下该如何实现:\",\"①：基于转账操作案例添加日志模块，实现数据库中记录日志 ②：业务层转账操作（transfer），调用减钱、加钱与记录日志功能\",\"需要注意一点就是，我们这个案例的预期效果为:\",\"无论转账操作是否成功，均进行转账操作的日志留痕:\"]},{\"header\":\"6.3.2.2 环境准备\",\"slug\":\"_6-3-2-2-环境准备\",\"contents\":[\"该环境是基于转账环境来完成的，所以环境的准备可以参考6.1.3的环境搭建步骤，在其基础上，我们继续往下写\"]},{\"header\":\"步骤1:创建日志表\",\"slug\":\"步骤1-创建日志表\",\"contents\":[\"create table tbl_log( id int primary key auto_increment, info varchar(255), createDate datetime ) \"]},{\"header\":\"步骤2:添加LogDao接口\",\"slug\":\"步骤2-添加logdao接口\",\"contents\":[\"public interface LogDao { @Insert(\\\"insert into tbl_log (info,createDate) values(#{info},now())\\\") void log(String info); } \"]},{\"header\":\"步骤3:添加LogService接口与实现类\",\"slug\":\"步骤3-添加logservice接口与实现类\",\"contents\":[\"public interface LogService { @Transactional void log(String out, String in, Double money); } @Service public class LogServiceImpl implements LogService { @Autowired private LogDao logDao; public void log(String out,String in,Double money ) { logDao.log(\\\"转账操作由\\\"+out+\\\"到\\\"+in+\\\",金额：\\\"+money); } } \"]},{\"header\":\"步骤4:在转账的业务中添加记录日志\",\"slug\":\"步骤4-在转账的业务中添加记录日志\",\"contents\":[\"public interface AccountService { /** * 转账操作 * @param out 传出方 * @param in 转入方 * @param money 金额 */ //配置当前接口方法具有事务 @Transactional public void transfer(String out,String in ,Double money)throws IOException ; } @Service public class AccountServiceImpl implements AccountService { @Autowired private AccountDao accountDao; @Autowired private LogService logService; public void transfer(String out,String in ,Double money) { try{ accountDao.outMoney(out,money); accountDao.inMoney(in,money); }finally { logService.log(out,in,money); } } } \"]},{\"header\":\"步骤5: 运行程序\",\"slug\":\"步骤5-运行程序-2\",\"contents\":[\"当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功\",\"当转账业务之间出现异常(int i =1/0),转账失败，tbl_account成功回滚，但是tbl_log表未添加数据\",\"这个结果和我们想要的不一样，什么原因?该如何解决?\",\"失败原因:日志的记录与转账操作隶属同一个事务，同成功同失败\",\"最终效果:无论转账操作是否成功，日志必须保留\"]},{\"header\":\"6.3.3 事务传播行为\",\"slug\":\"_6-3-3-事务传播行为\",\"contents\":[\"1630253779575\",\"对于上述案例的分析:\",\"log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1,T2,T3\",\"transfer因为加了@Transactional注解，也开启了事务T\",\"前面我们讲过Spring事务会把T1,T2,T3都加入到事务T中\",\"所以当转账失败后，所有的事务都回滚，导致日志没有记录下来\",\"这和我们的需求不符，这个时候我们就想能不能让log方法单独是一个事务呢?\",\"要想解决这个问题，就需要用到事务传播行为，所谓的事务传播行为指的是:\",\"事务传播行为：事务协调员对事务管理员所携带事务的处理态度\",\"具体如何解决，就需要用到之前我们没有说的propagation属性\"]},{\"header\":\"1.修改logService改变事务的传播行为\",\"slug\":\"_1-修改logservice改变事务的传播行为\",\"contents\":[\"public interface LogService { //propagation设置事务属性：传播行为设置为当前操作需要新事务 @Transactional(propagation = Propagation.REQUIRES_NEW) void log(String out, String in, Double money); } \",\"运行后，就能实现我们想要的结果，不管转账是否成功，都会记录日志\"]},{\"header\":\"2.事务传播行为的可选值\",\"slug\":\"_2-事务传播行为的可选值\",\"contents\":[\"对于我们开发实际中使用的话，因为默认值需要事务是常态的。根据开发过程选择其他的就可以了，例如案例中需要新事务就需要手工配置。其实入账和出账操作上也有事务，采用的就是默认值。\"]}]},\"/BackEnd/SpringBoot/\":{\"title\":\"SpringBoot\",\"contents\":[{\"header\":\"1 起步依赖\",\"slug\":\"_1-起步依赖\",\"contents\":[\"在SpringBoot项目中，起步依赖有一个共同的特征：都是以spring-boot-starter-作为开头\",\"起步依赖特殊之处\",\"spring-boot-starter-web：包含了web应用开发所需要的常见依赖\",\"spring-boot-starter-test：包含了单元测试所需要的常见依赖\",\"spring-boot-starter-web 内部把关于Web开发所有的依赖都已经导入并且指定了版本，只需引入 spring-boot-starter-web 依赖就可以实现Web开发的需要的功能\",\"Spring官方提供了很多现成的starter(起步依赖)，开发相关应用时，只需要引入对应的starter即可。\",\"每一个起步依赖，都用于开发一个特定的功能。\",\"举例： 开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis ，即可导入redis开发所需要的依赖\"]},{\"header\":\"2 SpringBoot父工程\",\"slug\":\"_2-springboot父工程\",\"contents\":[\"SpringBoot通过maven引入的依赖，是没有指定具体的依赖版本号的。\",\"为什么没有指定<version>版本号，可以正常使用呢？\",\"因为每一个SpringBoot工程，都有一个父工程。依赖的版本号在父工程中统一管理。\"]}]},\"/BackEnd/SpringBoot/springboot01.html\":{\"title\":\"SpringBoot请求响应\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"SpringBoot进行web程序开发时，内置了一个核心的Servlet程序 DispatcherServlet，称之为核心控制器 DispatcherServlet 负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由DispatcherServlet给浏览器响应数据。\",\"请求到达Tomcat之后，Tomcat会负责解析这些请求数据，解析后的请求数据会传递给Servlet程序的 HttpServletRequest 对象，也意味着 HttpServletRequest 对象就可以获取到请求数据。 而Tomcat，还给Servlet程序传递了一个参数 HttpServletResponse，通过这个对象，可以给浏览器设置响应数据 。\",\"• BS架构：Browser/Server，浏览器/服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。\"]},{\"header\":\"1. 请求\",\"slug\":\"_1-请求\",\"contents\":[]},{\"header\":\"1.1 Postman\",\"slug\":\"_1-1-postman\",\"contents\":[\"一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。\",\"Postman原是Chrome浏览器的插件，可以模拟浏览器向后端服务器发起任何形式(如:get、post)的HTTP请求\",\"使用Postman还可以在发起请求时，携带一些请求参数、请求头等信息\",\"作用：常用于进行接口测试\",\"特征：简单、实用、美观、大方\"]},{\"header\":\"1.2 简单参数\",\"slug\":\"_1-2-简单参数\",\"contents\":[\"如何接收传递过来的普通参数数据呢？\",\"原始方式\",\"SpringBoot方式\"]},{\"header\":\"1.2.1 原始方式\",\"slug\":\"_1-2-1-原始方式\",\"contents\":[\"在原始的Web程序当中，需要通过Servlet中提供的API：HttpServletRequest（请求对象），获取请求的相关信息。\",\"Tomcat接收到http请求时：把请求的相关信息封装到HttpServletRequest对象中\",\"Controller获取Request对象，直接在方法的形参中声明 HttpServletRequest 对象\",\"//根据指定的参数名获取请求参数的数据值 String request.getParameter(\\\"参数名\\\") \",\"@RestController public class RequestController { //原始方式 @RequestMapping(\\\"/simpleParam\\\") public String simpleParam(HttpServletRequest request){ // http://localhost:8080/simpleParam?name=Tom&age=10 // 请求参数： name=Tom&age=10 （有2个请求参数） // 第1个请求参数： name=Tom 参数名:name，参数值:Tom // 第2个请求参数： age=10 参数名:age , 参数值:10 String name = request.getParameter(\\\"name\\\");//name就是请求参数名 String ageStr = request.getParameter(\\\"age\\\");//age就是请求参数名 int age = Integer.parseInt(ageStr);//需要手动进行类型转换 System.out.println(name+\\\" : \\\"+age); return \\\"OK\\\"; } } \",\"仅做了解\"]},{\"header\":\"1.2.2 SpringBoot方式\",\"slug\":\"_1-2-2-springboot方式\",\"contents\":[\"在Springboot的环境中，对原始的API进行了封装，接收参数的形式更加简单。 如果是简单参数，参数名与形参变量名相同，定义同名的形参即可接收参数。\",\"@RestController public class RequestController { // http://localhost:8080/simpleParam?name=Tom&age=10 // 第1个请求参数： name=Tom 参数名:name，参数值:Tom // 第2个请求参数： age=10 参数名:age , 参数值:10 @RequestMapping(\\\"/simpleParam\\\") public String simpleParam(String name , Integer age ){//形参名和请求参数名保持一致 System.out.println(name+\\\" : \\\"+age); return \\\"OK\\\"; } } \",\"postman测试( GET 请求)：\",\"postman测试( POST请求 )：\",\"结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证请求参数名和Controller方法中的形参名保持一致，就可以获取到请求参数中的数据值。\"]},{\"header\":\"1.2.3 参数名不一致\",\"slug\":\"_1-2-3-参数名不一致\",\"contents\":[\"@RestController public class RequestController { // http://localhost:8080/simpleParam?name=Tom&age=20 // 请求参数名：name //springboot方式 @RequestMapping(\\\"/simpleParam\\\") public String simpleParam(String username , Integer age ){//请求参数名和形参名不相同 System.out.println(username+\\\" : \\\"+age); return \\\"OK\\\"; } } \",\"运行后controller方法中的username值为null，age值为20\",\"结论\",\"请求参数名和controller方法中的形参名不一致时，无法接收到请求数据\",\"解决方案：在方法形参前面加上 @RequestParam 注解然后通过value属性执行请求参数名，从而完成映射\",\"@RestController public class RequestController { // http://localhost:8080/simpleParam?name=Tom&age=20 // 请求参数名：name @RequestMapping(\\\"/simpleParam\\\") public String simpleParam(@RequestParam(\\\"name\\\") String username , Integer age ){ System.out.println(username+\\\" : \\\"+age); return \\\"OK\\\"; } } \",\"注意事项：\",\"@RequestParam中的required属性默认为true，代表该请求参数必须传递，如果不传递将报错\",\"如果该参数是可选的，可以将required属性设置为false\",\"@RequestMapping(\\\"/simpleParam\\\") public String simpleParam(@RequestParam(name = \\\"name\\\", required = false) String username, Integer age){ System.out.println(username+ \\\":\\\" + age); return \\\"OK\\\"; } \"]},{\"header\":\"1.3 实体参数\",\"slug\":\"_1-3-实体参数\",\"contents\":[\"将请求参数封装到一个实体类对象中，完成数据封装需要请求参数名与实体类的属性名相同\"]},{\"header\":\"1.3.1 简单实体对象\",\"slug\":\"_1-3-1-简单实体对象\",\"contents\":[\"定义POJO实体类：\",\"public class User { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \\\"User{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", age=\\\" + age + '}'; } } \",\"Controller方法：\",\"@RestController public class RequestController { //实体参数：简单实体对象 @RequestMapping(\\\"/simplePojo\\\") public String simplePojo(User user){ System.out.println(user); return \\\"OK\\\"; } } \",\"Postman测试：\",\"参数名和实体类属性名一致时\",\"参数名和实体类属性名不一致时\"]},{\"header\":\"1.3.2 复杂实体对象\",\"slug\":\"_1-3-2-复杂实体对象\",\"contents\":[\"在实体类中有一个或多个属性，也是实体对象类型的\",\"User类中有一个Address类型的属性（Address是一个实体类）\",\"复杂实体对象的封装，需要遵守如下规则：\",\"请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。\",\"定义POJO实体类：\",\"Address实体类\",\"public class Address { private String province; private String city; public String getProvince() { return province; } public void setProvince(String province) { this.province = province; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } @Override public String toString() { return \\\"Address{\\\" + \\\"province='\\\" + province + '\\\\'' + \\\", city='\\\" + city + '\\\\'' + '}'; } } \",\"User实体类\",\"public class User { private String name; private Integer age; private Address address; //地址对象 public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Address getAddress() { return address; } public void setAddress(Address address) { this.address = address; } @Override public String toString() { return \\\"User{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", age=\\\" + age + \\\", address=\\\" + address + '}'; } } \",\"Controller方法：\",\"@RestController public class RequestController { //实体参数：复杂实体对象 @RequestMapping(\\\"/complexPojo\\\") public String complexPojo(User user){ System.out.println(user); return \\\"OK\\\"; } } \",\"Postman测试：\"]},{\"header\":\"1.4 数组集合参数\",\"slug\":\"_1-4-数组集合参数\",\"contents\":[\"使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值\",\"多个值是怎么提交的呢？多个值也是一个一个的提交\",\"后端程序接收上述多个值的方式有两种：\",\"数组\",\"集合\"]},{\"header\":\"1.4.1 数组\",\"slug\":\"_1-4-1-数组\",\"contents\":[\"数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数\",\"Controller方法：\",\"@RestController public class RequestController { //数组集合参数 @RequestMapping(\\\"/arrayParam\\\") public String arrayParam(String[] hobby){ System.out.println(Arrays.toString(hobby)); return \\\"OK\\\"; } } \",\"Postman测试：\",\"在前端请求时，有两种传递形式：\",\"方式一： xxxxxxxxxx?hobby=game&hobby=java\",\"方式二：xxxxxxxxxxxxx?hobby=game,java\"]},{\"header\":\"1.4.2 集合\",\"slug\":\"_1-4-2-集合\",\"contents\":[\"集合参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam 绑定参数关系\",\"默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系\",\"Controller方法：\",\"@RestController public class RequestController { //数组集合参数 @RequestMapping(\\\"/listParam\\\") public String listParam(@RequestParam List<String> hobby){ System.out.println(hobby); return \\\"OK\\\"; } } \",\"Postman测试：\",\"方式一： xxxxxxxxxx?hobby=game&hobby=java\",\"方式二：xxxxxxxxxxxxx?hobby=game,java\"]},{\"header\":\"1.5 日期参数\",\"slug\":\"_1-5-日期参数\",\"contents\":[\"日期的格式多种多样（如：2022-12-12 10:05:45 、2022/12/12 10:05:45），对于日期类型的参数在进行封装的时候，需要通过 @DateTimeFormat 注解，以及其pattern属性来设置日期的格式。\",\"@DateTimeFormat注解的pattern属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递\",\"后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数\",\"Controller方法：\",\"@RestController public class RequestController { //日期时间参数 @RequestMapping(\\\"/dateParam\\\") public String dateParam(@DateTimeFormat(pattern = \\\"yyyy-MM-dd HH:mm:ss\\\") LocalDateTime updateTime){ System.out.println(updateTime); return \\\"OK\\\"; } } \",\"Postman测试：\"]},{\"header\":\"1.6 JSON参数\",\"slug\":\"_1-6-json参数\",\"contents\":[\"Postman在发送请求时，如何传递json格式的请求参数\",\"在服务端的controller方法中，如何接收json格式的请求参数\",\"Postman发送JSON格式数据：\",\"服务端Controller方法接收JSON格式数据：\",\"传递json格式的参数，在Controller中会使用实体类进行封装。\",\"封装规则：JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用 @RequestBody 标识\",\"@RequestBody注解：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致）\",\"实体类：Address\",\"public class Address { private String province; private String city; //省略GET , SET 方法 } \",\"实体类：User\",\"public class User { private String name; private Integer age; private Address address; //省略GET , SET 方法 } \",\"Controller方法：\",\"@RestController public class RequestController { //JSON参数 @RequestMapping(\\\"/jsonParam\\\") public String jsonParam(@RequestBody User user){ System.out.println(user); return \\\"OK\\\"; } } \",\"Postman测试：\"]},{\"header\":\"1.7 路径参数\",\"slug\":\"_1-7-路径参数\",\"contents\":[\"传统的开发中请求参数是放在请求体(POST请求)传递 或 跟在URL后面通过?key=value的形式传递(GET请求)。\",\"现在的开发中经常还会直接在请求的URL中传递参数\",\"http://localhost:8080/user/1 http://localhost:880/user/1/0 \",\"路径参数：\",\"前端：通过请求URL直接传递参数\",\"后端：使用{…}来标识该路径参数，需要使用 @PathVariable 获取路径参数\",\"Controller方法：\",\"@RestController public class RequestController { //路径参数 @RequestMapping(\\\"/path/{id}\\\") public String pathParam(@PathVariable Integer id){ System.out.println(id); return \\\"OK\\\"; } } \",\"Postman测试：\",\"传递多个路径参数：\",\"Postman测试：\",\"Controller方法：\",\"@RestController public class RequestController { //路径参数 @RequestMapping(\\\"/path/{id}/{name}\\\") public String pathParam2(@PathVariable Integer id, @PathVariable String name){ System.out.println(id+ \\\" : \\\" +name); return \\\"OK\\\"; } } \"]},{\"header\":\"2. 响应\",\"slug\":\"_2-响应\",\"contents\":[\"HTTL协议的交互方式：请求响应模式（有请求就有响应）\"]},{\"header\":\"2.1 @ResponseBody\",\"slug\":\"_2-1-responsebody\",\"contents\":[\"controller方法中的return的结果，怎么就可以响应给浏览器呢？\",\"答案：使用@ResponseBody注解\",\"@ResponseBody注解\",\"类型：方法注解、类注解\",\"位置：书写在Controller方法上或类上\",\"作用：将方法返回值直接响应给浏览器\",\"如果返回值类型是实体对象/集合，将会转换为JSON格式后再响应给浏览器\",\"在所书写的Controller中，只在类上添加了@RestController注解、方法添加了@RequestMapping注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？\",\"@RestController public class HelloController { @RequestMapping(\\\"/hello\\\") public String hello(){ System.out.println(\\\"Hello World ~\\\"); return \\\"Hello World ~\\\"; } } \",\"原因：在类上添加的@RestController注解，是一个组合注解。\",\"@RestController = @Controller + @ResponseBody\",\"@RestController源码：\",\"@Target({ElementType.TYPE}) //元注解（修饰注解的注解） @Retention(RetentionPolicy.RUNTIME) //元注解 @Documented //元注解 @Controller @ResponseBody public @interface RestController { @AliasFor( annotation = Controller.class ) String value() default \\\"\\\"; } \",\"结论：在类上添加@RestController就相当于添加了@ResponseBody注解。\",\"@RestController public class ResponseController { //响应字符串 @RequestMapping(\\\"/hello\\\") public String hello(){ System.out.println(\\\"Hello World ~\\\"); return \\\"Hello World ~\\\"; } //响应实体对象 @RequestMapping(\\\"/getAddr\\\") public Address getAddr(){ Address addr = new Address();//创建实体类对象 addr.setProvince(\\\"广东\\\"); addr.setCity(\\\"深圳\\\"); return addr; } //响应集合数据 @RequestMapping(\\\"/listAddr\\\") public List<Address> listAddr(){ List<Address> list = new ArrayList<>();//集合对象 Address addr = new Address(); addr.setProvince(\\\"广东\\\"); addr.setCity(\\\"深圳\\\"); Address addr2 = new Address(); addr2.setProvince(\\\"陕西\\\"); addr2.setCity(\\\"西安\\\"); list.add(addr); list.add(addr2); return list; } } \",\"测试效果如下：\"]},{\"header\":\"2.2 统一响应结果\",\"slug\":\"_2-2-统一响应结果\",\"contents\":[\"真实的项目开发中，无论是哪种方法，都会定义一个统一的返回结果\",\"前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。\",\"统一的返回结果使用类来描述，在这个结果中包含：\",\"响应状态码：当前请求是成功，还是失败\",\"状态码信息：给页面的提示信息\",\"返回的数据：给前端响应的数据（字符串、对象、集合）\",\"定义在一个实体类Result来包含以上信息，代码如下：\",\"public class Result { private Integer code;//响应码，1 代表成功; 0 代表失败 private String msg; //响应码 描述字符串 private Object data; //返回的数据 public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } //增删改 成功响应(不需要给前端返回数据) public static Result success(){ return new Result(1,\\\"success\\\",null); } //查询 成功响应(把查询结果做为返回数据响应给前端) public static Result success(Object data){ return new Result(1,\\\"success\\\",data); } //失败响应 public static Result error(String msg){ return new Result(0,msg,null); } } \",\"改造Controller：\",\"@RestController public class ResponseController { //响应统一格式的结果 @RequestMapping(\\\"/hello\\\") public Result hello(){ System.out.println(\\\"Hello World ~\\\"); //return new Result(1,\\\"success\\\",\\\"Hello World ~\\\"); return Result.success(\\\"Hello World ~\\\"); } //响应统一格式的结果 @RequestMapping(\\\"/getAddr\\\") public Result getAddr(){ Address addr = new Address(); addr.setProvince(\\\"广东\\\"); addr.setCity(\\\"深圳\\\"); return Result.success(addr); } //响应统一格式的结果 @RequestMapping(\\\"/listAddr\\\") public Result listAddr(){ List<Address> list = new ArrayList<>(); Address addr = new Address(); addr.setProvince(\\\"广东\\\"); addr.setCity(\\\"深圳\\\"); Address addr2 = new Address(); addr2.setProvince(\\\"陕西\\\"); addr2.setCity(\\\"西安\\\"); list.add(addr); list.add(addr2); return Result.success(list); } } \",\"使用Postman测试：\"]},{\"header\":\"2.3 案例\",\"slug\":\"_2-3-案例\",\"contents\":[]},{\"header\":\"2.3.1 需求说明\",\"slug\":\"_2-3-1-需求说明\",\"contents\":[\"需求：加载并解析xml文件中的数据，完成数据处理，并在页面展示\"]},{\"header\":\"2.3.2 准备工作\",\"slug\":\"_2-3-2-准备工作\",\"contents\":[\"XML文件\",\"工具类\",\"前端页面资源\",\"在SpringBoot项目中，静态资源(html，css，js等前端资源)默认可以存放的目录：\",\"classpath:/static/\",\"classpath:/public/\",\"classpath:/resources/\",\"classpath:/META-INF/resources/\",\"classpath：\",\"代表的是类路径，在maven的项目中，其实指的就是 src/main/resources 或者 src/main/java，但是java目录是存放java代码的，所以相关的配置文件及静态资源文档，就放在 src/main/resources下。\"]},{\"header\":\"2.3.3 实现步骤\",\"slug\":\"_2-3-3-实现步骤\",\"contents\":[\"在pom.xml文件中引入dom4j的依赖，用于解析XML文件\",\"<dependency> <groupId>org.dom4j</groupId> <artifactId>dom4j</artifactId> <version>2.1.3</version> </dependency> \",\"解析XML的工具类XMLParserUtils、实体类Emp、XML文件emp.xml\",\"引入资料中提供的静态页面文件，放在resources下的static目录下\",\"创建EmpController类，编写Controller程序，处理请求，响应数据\"]},{\"header\":\"2.3.4 代码实现\",\"slug\":\"_2-3-4-代码实现\",\"contents\":[\"Contriller代码：\",\"@RestController public class EmpController { @RequestMapping(\\\"/listEmp\\\") public Result list(){ //1. 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(\\\"emp.xml\\\").getFile(); //System.out.println(file); List<Emp> empList = XmlParserUtils.parse(file, Emp.class); //2. 对数据进行转换处理 - gender, job empList.stream().forEach(emp -> { //处理 gender 1: 男, 2: 女 String gender = emp.getGender(); if(\\\"1\\\".equals(gender)){ emp.setGender(\\\"男\\\"); }else if(\\\"2\\\".equals(gender)){ emp.setGender(\\\"女\\\"); } //处理job - 1: 讲师, 2: 班主任 , 3: 就业指导 String job = emp.getJob(); if(\\\"1\\\".equals(job)){ emp.setJob(\\\"讲师\\\"); }else if(\\\"2\\\".equals(job)){ emp.setJob(\\\"班主任\\\"); }else if(\\\"3\\\".equals(job)){ emp.setJob(\\\"就业指导\\\"); } }); //3. 响应数据 return Result.success(empList); } } \",\"统一返回结果实体类：\",\"public class Result { private Integer code ;//1 成功 , 0 失败 private String msg; //提示信息 private Object data; //数据 date public Result() { } public Result(Integer code, String msg, Object data) { this.code = code; this.msg = msg; this.data = data; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } public static Result success(Object data){ return new Result(1, \\\"success\\\", data); } public static Result success(){ return new Result(1, \\\"success\\\", null); } public static Result error(String msg){ return new Result(0, msg, null); } } \"]},{\"header\":\"2.3.5 测试\",\"slug\":\"_2-3-5-测试\",\"contents\":[\"打开浏览器，在浏览器地址栏输入： http://localhost:8080/emp.html\"]},{\"header\":\"2.3.6 问题分析\",\"slug\":\"_2-3-6-问题分析\",\"contents\":[\"案例中：解析XML数据，获取数据的代码，处理数据的逻辑的代码，给页面响应的代码全部都堆积在一起了，全部都写在controller方法中了\",\"当我们要修改操作数据部分的代码，需要改动Controller\",\"当我们要完善逻辑处理部分的代码，需要改动Controller\",\"当我们需要修改数据响应的代码，还是需要改动Controller\"]},{\"header\":\"3. 分层解耦\",\"slug\":\"_3-分层解耦\",\"contents\":[]},{\"header\":\"3.1 三层架构\",\"slug\":\"_3-1-三层架构\",\"contents\":[]},{\"header\":\"3.1.1 介绍\",\"slug\":\"_3-1-1-介绍\",\"contents\":[\"单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。\",\"这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。\",\"数据访问：负责业务数据的维护操作，包括增、删、改、查等操作\",\"逻辑处理：负责业务逻辑处理的代码\",\"请求处理、响应数据：负责，接收页面的请求，给页面响应数据\",\"Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。\",\"Service：业务逻辑层。处理具体的业务逻辑。\",\"Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。\",\"基于三层架构的程序执行流程：\",\"前端发起的请求，由Controller层接收（Controller响应数据给前端）\",\"Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层）\",\"Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取）\",\"Dao层操作文件中的数据（Dao拿到的数据会返回给Service层）\"]},{\"header\":\"3.1.2 代码拆分\",\"slug\":\"_3-1-2-代码拆分\",\"contents\":[\"控制层包名：xxxx.controller\",\"业务逻辑层包名：xxxx.service\",\"数据访问层包名：xxxx.dao\",\"控制层： 接收前端发送的请求，对请求进行处理，并响应数据\",\"@RestController public class EmpController { //业务层对象 private EmpService empService = new EmpServiceA(); @RequestMapping(\\\"/listEmp\\\") public Result list(){ //1. 调用service层, 获取数据 List<Emp> empList = empService.listEmp(); //3. 响应数据 return Result.success(empList); } } \",\"业务逻辑层： 处理具体的业务逻辑\",\"业务接口\",\"//业务逻辑接口（制定业务标准） public interface EmpService { //获取员工列表 public List<Emp> listEmp(); } \",\"业务实现类\",\"//业务逻辑实现类（按照业务标准实现） public class EmpServiceA implements EmpService { //dao层对象 private EmpDao empDao = new EmpDaoA(); @Override public List<Emp> listEmp() { //1. 调用dao, 获取数据 List<Emp> empList = empDao.listEmp(); //2. 对数据进行转换处理 - gender, job empList.stream().forEach(emp -> { //处理 gender 1: 男, 2: 女 String gender = emp.getGender(); if(\\\"1\\\".equals(gender)){ emp.setGender(\\\"男\\\"); }else if(\\\"2\\\".equals(gender)){ emp.setGender(\\\"女\\\"); } //处理job - 1: 讲师, 2: 班主任 , 3: 就业指导 String job = emp.getJob(); if(\\\"1\\\".equals(job)){ emp.setJob(\\\"讲师\\\"); }else if(\\\"2\\\".equals(job)){ emp.setJob(\\\"班主任\\\"); }else if(\\\"3\\\".equals(job)){ emp.setJob(\\\"就业指导\\\"); } }); return empList; } } \",\"数据访问层： 负责数据的访问操作，包含数据的增、删、改、查\",\"数据访问接口\",\"//数据访问层接口（制定标准） public interface EmpDao { //获取员工列表数据 public List<Emp> listEmp(); } \",\"数据访问实现类\",\"//数据访问实现类 public class EmpDaoA implements EmpDao { @Override public List<Emp> listEmp() { //1. 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(\\\"emp.xml\\\").getFile(); System.out.println(file); List<Emp> empList = XmlParserUtils.parse(file, Emp.class); return empList; } } \",\"三层架构的好处\",\"复用性强\",\"便于维护\",\"利用扩展\"]},{\"header\":\"3.2 分层解耦\",\"slug\":\"_3-2-分层解耦\",\"contents\":[]},{\"header\":\"3.2.1 耦合问题\",\"slug\":\"_3-2-1-耦合问题\",\"contents\":[\"软件开发涉及到的两个概念：内聚和耦合\",\"内聚：软件中各个功能模块内部的功能联系。\",\"耦合：衡量软件中各个层/模块之间的依赖、关联的程度。\",\"软件设计原则：高内聚低耦合。\",\"高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 \\\"高内聚\\\"。\",\"低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。\",\"程序中高内聚的体现：\",\"EmpServiceA类中只编写了和员工相关的逻辑处理代码\",\"程序中耦合代码的体现：\",\"把业务类变为EmpServiceB时，需要修改controller层中的代码\",\"高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。\"]},{\"header\":\"3.2.2 解耦思路\",\"slug\":\"_3-2-2-解耦思路\",\"contents\":[\"怎么解耦呢？\",\"首先不能在EmpController中使用new对象。代码如下：\",\"不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢？\",\"解决思路\",\"提供一个容器，容器中存储一些对象(例：EmpService对象)\",\"controller程序从容器中获取EmpService类型的对象\",\"想要实现上述解耦操作，涉及Spring中的两个核心概念：\",\"控制反转： Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。\",\"对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器\",\"依赖注入： Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。\",\"程序运行时需要某个资源，此时容器就为其提供这个资源。\",\"例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象\",\"IOC容器中创建、管理的对象，称之为：bean对象\"]},{\"header\":\"3.3 IOC&DI\",\"slug\":\"_3-3-ioc-di\",\"contents\":[]},{\"header\":\"3.3.1 IOC&DI入门\",\"slug\":\"_3-3-1-ioc-di入门\",\"contents\":[\"完成Controller层、Service层、Dao层的代码解耦\",\"思路\",\"删除Controller层、Service层中new对象的代码\",\"Service层及Dao层的实现类，交给IOC容器管理\",\"为Controller及Service注入运行时依赖的对象 \",\"Controller程序中注入依赖的Service层对象\",\"Service程序中注入依赖的Dao层对象\",\"第1步：删除Controller层、Service层中new对象的代码\",\"第2步：Service层及Dao层的实现类，交给IOC容器管理\",\"使用Spring提供的注解：@Component ，就可以实现类交给IOC容器管理\",\"第3步：为Controller及Service注入运行时依赖的对象\",\"使用Spring提供的注解：@Autowired ，就可以实现程序运行时IOC容器自动注入需要的依赖对象\",\"完整的三层代码：\",\"Controller层：\",\"@RestController public class EmpController { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private EmpService empService ; @RequestMapping(\\\"/listEmp\\\") public Result list(){ //1. 调用service, 获取数据 List<Emp> empList = empService.listEmp(); //3. 响应数据 return Result.success(empList); } } \",\"Service层：\",\"@Component //将当前对象交给IOC容器管理,成为IOC容器的bean public class EmpServiceA implements EmpService { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private EmpDao empDao ; @Override public List<Emp> listEmp() { //1. 调用dao, 获取数据 List<Emp> empList = empDao.listEmp(); //2. 对数据进行转换处理 - gender, job empList.stream().forEach(emp -> { //处理 gender 1: 男, 2: 女 String gender = emp.getGender(); if(\\\"1\\\".equals(gender)){ emp.setGender(\\\"男\\\"); }else if(\\\"2\\\".equals(gender)){ emp.setGender(\\\"女\\\"); } //处理job - 1: 讲师, 2: 班主任 , 3: 就业指导 String job = emp.getJob(); if(\\\"1\\\".equals(job)){ emp.setJob(\\\"讲师\\\"); }else if(\\\"2\\\".equals(job)){ emp.setJob(\\\"班主任\\\"); }else if(\\\"3\\\".equals(job)){ emp.setJob(\\\"就业指导\\\"); } }); return empList; } } \",\"Dao层：\",\"@Component //将当前对象交给IOC容器管理,成为IOC容器的bean public class EmpDaoA implements EmpDao { @Override public List<Emp> listEmp() { //1. 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(\\\"emp.xml\\\").getFile(); System.out.println(file); List<Emp> empList = XmlParserUtils.parse(file, Emp.class); return empList; } } \",\"运行测试：\",\"启动SpringBoot引导类，打开浏览器，输入：http://localhost:8080/emp.html\"]},{\"header\":\"3.3.2 IOC详解\",\"slug\":\"_3-3-2-ioc详解\",\"contents\":[\"IOC控制反转\",\"就是将对象的控制权交给Spring的IOC容器，由IOC容器创建及管理对象\",\"IOC容器创建的对象称为bean对象\",\"要把某个对象交给IOC容器管理，需要在类上添加一个注解：@Component\",\"而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：\",\"@Controller （标注在控制层类上）\",\"@Service （标注在业务层类上）\",\"@Repository （标注在数据访问层类上）\",\"修改入门案例代码：\",\"Controller层：\",\"@RestController //@RestController = @Controller + @ResponseBody public class EmpController { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private EmpService empService ; @RequestMapping(\\\"/listEmp\\\") public Result list(){ //1. 调用service, 获取数据 List<Emp> empList = empService.listEmp(); //3. 响应数据 return Result.success(empList); } } \",\"Service层：\",\"@Service public class EmpServiceA implements EmpService { @Autowired //运行时,从IOC容器中获取该类型对象,赋值给该变量 private EmpDao empDao ; @Override public List<Emp> listEmp() { //1. 调用dao, 获取数据 List<Emp> empList = empDao.listEmp(); //2. 对数据进行转换处理 - gender, job empList.stream().forEach(emp -> { //处理 gender 1: 男, 2: 女 String gender = emp.getGender(); if(\\\"1\\\".equals(gender)){ emp.setGender(\\\"男\\\"); }else if(\\\"2\\\".equals(gender)){ emp.setGender(\\\"女\\\"); } //处理job - 1: 讲师, 2: 班主任 , 3: 就业指导 String job = emp.getJob(); if(\\\"1\\\".equals(job)){ emp.setJob(\\\"讲师\\\"); }else if(\\\"2\\\".equals(job)){ emp.setJob(\\\"班主任\\\"); }else if(\\\"3\\\".equals(job)){ emp.setJob(\\\"就业指导\\\"); } }); return empList; } } \",\"Dao层：\",\"@Repository public class EmpDaoA implements EmpDao { @Override public List<Emp> listEmp() { //1. 加载并解析emp.xml String file = this.getClass().getClassLoader().getResource(\\\"emp.xml\\\").getFile(); System.out.println(file); List<Emp> empList = XmlParserUtils.parse(file, Emp.class); return empList; } } \",\"要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：\",\"注解\",\"说明\",\"位置\",\"@Controller\",\"@Component的衍生注解\",\"标注在控制器类上\",\"@Service\",\"@Component的衍生注解\",\"标注在业务类上\",\"@Repository\",\"@Component的衍生注解\",\"标注在数据访问类上（由于与mybatis整合，用的少）\",\"@Component\",\"声明bean的基础注解\",\"不属于以上三类时，用此注解\",\"查看源码：\",\"在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。\",\"注意事项:\",\"声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。\",\"使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。\",\"组件扫描:\",\"问题：使用前面的四个注解声明的bean，一定会生效吗？\",\"答案：不一定。（原因：bean想要生效，还需要被组件扫描）\",\"下面通过修改项目工程的目录结构，来测试bean对象是否生效：\",\"运行程序后，报错：\",\"为什么没有找到bean对象呢？\",\"使用四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描\",\"@ComponentScan注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，默认扫描的范围是SpringBoot启动类所在包及其子包。\",\"解决方案：手动添加@ComponentScan注解，指定要扫描的包（仅做了解，不推荐）\",\"推荐做法：\",\"将定义的controller，service，dao这些包都放在引导类所在包com.itheima的子包下，定义的bean就会被自动的扫描到\"]},{\"header\":\"3.3.3 DI详解\",\"slug\":\"_3-3-3-di详解\",\"contents\":[\"依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。\",\"Autowired翻译过来叫：自动装配。\",\"@Autowired注解，默认是按照类型进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）\",\"入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。\",\"那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？\",\"程序运行会报错\",\"如何解决上述问题呢？Spring提供了以下几种解决方案：\",\"@Primary\",\"@Qualifier\",\"@Resource\",\"使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。\",\"使用@Qualifier注解：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。\",\"@Qualifier注解不能单独使用，必须配合@Autowired使用\",\"使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。\",\"面试题 ： @Autowird 与 @Resource的区别\",\"@Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解\",\"@Autowired 默认是按照类型注入，而@Resource是按照名称注入\"]}]},\"/BackEnd/SpringBoot/springboot02.html\":{\"title\":\"SpringBoot案例 ⅓\",\"contents\":[{\"header\":\"1. 准备工作\",\"slug\":\"_1-准备工作\",\"contents\":[]},{\"header\":\"1.1 需求\",\"slug\":\"_1-1-需求\",\"contents\":[\"部门管理:\",\"部门管理功能开发包括：\",\"查询部门列表\",\"删除部门\",\"新增部门\",\"修改部门\",\"员工管理:\",\"员工管理功能开发包括：\",\"查询员工列表(分页、条件)\",\"删除员工\",\"新增员工\",\"修改员工\"]},{\"header\":\"1.2 环境搭建\",\"slug\":\"_1-2-环境搭建\",\"contents\":[\"步骤\",\"准备数据库表(dept、emp)\",\"创建springboot工程，引入对应的起步依赖（web、mybatis、mysql驱动、lombok）\",\"配置文件application.properties中引入mybatis的配置信息，准备对应的实体类\",\"准备对应的Mapper、Service(接口、实现类)、Controller基础结构\",\"第1步：准备数据库表\",\"sql表\",\"-- 部门管理 create table dept( id int unsigned primary key auto_increment comment '主键ID', name varchar(10) not null unique comment '部门名称', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间' ) comment '部门表'; -- 部门表测试数据 insert into dept (id, name, create_time, update_time) values(1,'学工部',now(),now()), (2,'教研部',now(),now()), (3,'咨询部',now(),now()), (4,'就业部',now(),now()), (5,'人事部',now(),now()); -- 员工管理(带约束) create table emp ( id int unsigned primary key auto_increment comment 'ID', username varchar(20) not null unique comment '用户名', password varchar(32) default '123456' comment '密码', name varchar(10) not null comment '姓名', gender tinyint unsigned not null comment '性别, 说明: 1 男, 2 女', image varchar(300) comment '图像', job tinyint unsigned comment '职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师', entrydate date comment '入职时间', dept_id int unsigned comment '部门ID', create_time datetime not null comment '创建时间', update_time datetime not null comment '修改时间' ) comment '员工表'; -- 员工表测试数据 INSERT INTO emp (id, username, password, name, gender, image, job, entrydate,dept_id,create_time, update_time) VALUES (1,'jinyong','123456','金庸',1,'1.jpg',4,'2000-01-01',2,now(),now()), (2,'zhangwuji','123456','张无忌',1,'2.jpg',2,'2015-01-01',2,now(),now()), (3,'yangxiao','123456','杨逍',1,'3.jpg',2,'2008-05-01',2,now(),now()), (4,'weiyixiao','123456','韦一笑',1,'4.jpg',2,'2007-01-01',2,now(),now()), (5,'changyuchun','123456','常遇春',1,'5.jpg',2,'2012-12-05',2,now(),now()), (6,'xiaozhao','123456','小昭',2,'6.jpg',3,'2013-09-05',1,now(),now()), (7,'jixiaofu','123456','纪晓芙',2,'7.jpg',1,'2005-08-01',1,now(),now()), (8,'zhouzhiruo','123456','周芷若',2,'8.jpg',1,'2014-11-09',1,now(),now()), (9,'dingminjun','123456','丁敏君',2,'9.jpg',1,'2011-03-11',1,now(),now()), (10,'zhaomin','123456','赵敏',2,'10.jpg',1,'2013-09-05',1,now(),now()), (11,'luzhangke','123456','鹿杖客',1,'11.jpg',5,'2007-02-01',3,now(),now()), (12,'hebiweng','123456','鹤笔翁',1,'12.jpg',5,'2008-08-18',3,now(),now()), (13,'fangdongbai','123456','方东白',1,'13.jpg',5,'2012-11-01',3,now(),now()), (14,'zhangsanfeng','123456','张三丰',1,'14.jpg',2,'2002-08-01',2,now(),now()), (15,'yulianzhou','123456','俞莲舟',1,'15.jpg',2,'2011-05-01',2,now(),now()), (16,'songyuanqiao','123456','宋远桥',1,'16.jpg',2,'2007-01-01',2,now(),now()), (17,'chenyouliang','123456','陈友谅',1,'17.jpg',NULL,'2015-03-21',NULL,now(),now()); \",\"第2步：创建一个SpringBoot工程，选择引入对应的起步依赖（web、mybatis、mysql驱动、lombok） (版本选择2.7.5版本，可以创建完毕之后，在pom.xml文件中更改版本号)\",\"生成的pom.xml文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.7.5</version> <relativePath/> </parent> <groupId>com.itheima</groupId> <artifactId>tlias-web-management</artifactId> <version>0.0.1-SNAPSHOT</version> <name>tlias-web-management</name> <description>Demo project for Spring Boot</description> <properties> <java.version>11</java.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>2.3.0</version> </dependency> <dependency> <groupId>com.mysql</groupId> <artifactId>mysql-connector-j</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <optional>true</optional> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <configuration> <excludes> <exclude> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </exclude> </excludes> </configuration> </plugin> </plugins> </build> </project> \",\"创建项目工程目录结构：\",\"第3步：配置文件application.properties中引入mybatis的配置信息，准备对应的实体类\",\"application.properties （直接把之前项目中的复制过来）\",\"#数据库连接 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/tlias spring.datasource.username=root spring.datasource.password=1234 #开启mybatis的日志输出 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl #开启数据库表字段 到 实体类属性的驼峰映射 mybatis.configuration.map-underscore-to-camel-case=true \",\"实体类\",\"/*部门类*/ @Data @NoArgsConstructor @AllArgsConstructor public class Dept { private Integer id; private String name; private LocalDateTime createTime; private LocalDateTime updateTime; } \",\"/*员工类*/ @Data @NoArgsConstructor @AllArgsConstructor public class Emp { private Integer id; private String username; private String password; private String name; private Short gender; private String image; private Short job; private LocalDate entrydate; private Integer deptId; private LocalDateTime createTime; private LocalDateTime updateTime; } \",\"第4步：准备对应的Mapper、Service(接口、实现类)、Controller基础结构\",\"数据访问层：\",\"DeptMapper\",\"package com.itheima.mapper; import org.apache.ibatis.annotations.Mapper; @Mapper public interface DeptMapper { } \",\"EmpMapper\",\"package com.itheima.mapper; import org.apache.ibatis.annotations.Mapper; @Mapper public interface EmpMapper { } \",\"业务层：\",\"DeptService\",\"package com.itheima.service; //部门业务规则 public interface DeptService { } \",\"DeptServiceImpl\",\"package com.itheima.service.impl; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; //部门业务实现类 @Slf4j @Service public class DeptServiceImpl implements DeptService { } \",\"EmpService\",\"package com.itheima.service; //员工业务规则 public interface EmpService { } \",\"EmpServiceImpl\",\"package com.itheima.service.impl; import com.itheima.service.EmpService; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; //员工业务实现类 @Slf4j @Service public class EmpServiceImpl implements EmpService { } \",\"控制层：\",\"DeptController\",\"package com.itheima.controller; import org.springframework.web.bind.annotation.RestController; //部门管理控制器 @RestController public class DeptController { } \",\"EmpController\",\"package com.itheima.controller; import org.springframework.web.bind.annotation.RestController; //员工管理控制器 @RestController public class EmpController { } \",\"项目工程结构：\"]},{\"header\":\"2 开发规范\",\"slug\":\"_2-开发规范\",\"contents\":[\"案例是基于当前最为主流的前后端分离模式进行开发\"]},{\"header\":\"2.1 REST\",\"slug\":\"_2-1-rest\",\"contents\":[\"REST（Representational State Transfer），表述性状态转换，它是一种软件架构风格。\",\"传统URL风格如下:\",\"http://localhost:8080/user/getById?id=1 GET：查询id为1的用户 http://localhost:8080/user/saveUser POST：新增用户 http://localhost:8080/user/updateUser POST：修改用户 http://localhost:8080/user/deleteUser?id=1 GET：删除id为1的用户 \",\"原始的传统URL定义比较复杂，而且将资源的访问行为对外暴露出来了。\",\"基于REST风格URL如下：\",\"http://localhost:8080/users/1 GET：查询id为1的用户 http://localhost:8080/users POST：新增用户 http://localhost:8080/users PUT：修改用户 http://localhost:8080/users/1 DELETE：删除id为1的用户 \",\"总结：通过URL定位要操作的资源，通过HTTP(请求方式)来描述具体的操作。\",\"在REST风格的URL中，通过四种请求方式，来操作数据的增删改查。\",\"GET ： 查询\",\"POST ：新增\",\"PUT ：修改\",\"DELETE ：删除\"]},{\"header\":\"2.2 统一响应结果\",\"slug\":\"_2-2-统一响应结果\",\"contents\":[\"前后端工程在进行交互时，使用统一响应结果 Result。\",\"package com.itheima.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @NoArgsConstructor @AllArgsConstructor public class Result { private Integer code;//响应码，1 代表成功; 0 代表失败 private String msg; //响应信息 描述字符串 private Object data; //返回的数据 //增删改 成功响应 public static Result success(){ return new Result(1,\\\"success\\\",null); } //查询 成功响应 public static Result success(Object data){ return new Result(1,\\\"success\\\",data); } //失败响应 public static Result error(String msg){ return new Result(0,msg,null); } } \"]},{\"header\":\"2.3 开发流程\",\"slug\":\"_2-3-开发流程\",\"contents\":[\"查看页面原型明确需求\",\"根据页面原型和需求，进行表结构设计、编写接口文档\",\"阅读接口文档\",\"思路分析\",\"功能接口开发\",\"就是开发后台的业务功能，一个业务功能，我们称为一个接口\",\"功能接口测试\",\"功能开发完毕后，先通过Postman进行功能接口测试，测试通过后，再和前端进行联调测试\",\"前后端联调测试\",\"和前端开发人员开发好的前端工程一起测试\"]}]},\"/BackEnd/SpringBoot/springboot03.html\":{\"title\":\"SpringBoot案例 ⅔\",\"contents\":[{\"header\":\"1. 部门管理\",\"slug\":\"_1-部门管理\",\"contents\":[\"开发的部门管理功能包含：\",\"查询部门\",\"删除部门\",\"新增部门\",\"更新部门\"]},{\"header\":\"1.1 查询部门\",\"slug\":\"_1-1-查询部门\",\"contents\":[]},{\"header\":\"1.1.1 原型和需求\",\"slug\":\"_1-1-1-原型和需求\",\"contents\":[]},{\"header\":\"1.1.2 接口文档\",\"slug\":\"_1-1-2-接口文档\",\"contents\":[\"部门列表查询:\",\"基本信息\",\"请求路径：/depts 请求方式：GET 接口描述：该接口用于部门列表数据查询 \",\"请求参数\",\"无\",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"code\",\"number\",\"必须\",\"响应码，1 代表成功，0 代表失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object[ ]\",\"非必须\",\"返回的数据\",\"|- id\",\"number\",\"非必须\",\"id\",\"|- name\",\"string\",\"非必须\",\"部门名称\",\"|- createTime\",\"string\",\"非必须\",\"创建时间\",\"|- updateTime\",\"string\",\"非必须\",\"修改时间\",\"响应数据样例：\",\"{ \\\"code\\\": 1, \\\"msg\\\": \\\"success\\\", \\\"data\\\": [ { \\\"id\\\": 1, \\\"name\\\": \\\"学工部\\\", \\\"createTime\\\": \\\"2022-09-01T23:06:29\\\", \\\"updateTime\\\": \\\"2022-09-01T23:06:29\\\" }, { \\\"id\\\": 2, \\\"name\\\": \\\"教研部\\\", \\\"createTime\\\": \\\"2022-09-01T23:06:29\\\", \\\"updateTime\\\": \\\"2022-09-01T23:06:29\\\" } ] } \"]},{\"header\":\"1.1.3 思路分析\",\"slug\":\"_1-1-3-思路分析\",\"contents\":[]},{\"header\":\"1.1.4 功能开发\",\"slug\":\"_1-1-4-功能开发\",\"contents\":[\"请求路径：/depts\",\"请求方式：GET\",\"请求参数：无\",\"响应数据：json格式\",\"DeptController:\",\"@Slf4j @RestController public class DeptController { @Autowired private DeptService deptService; //@RequestMapping(value = \\\"/depts\\\" , method = RequestMethod.GET) @GetMapping(\\\"/depts\\\") public Result list(){ log.info(\\\"查询所有部门数据\\\"); List<Dept> deptList = deptService.list(); return Result.success(deptList); } } \",\"@Slf4j注解源码：\",\"DeptService（业务接口）\",\"public interface DeptService { /** * 查询所有的部门数据 * @return 存储Dept对象的集合 */ List<Dept> list(); } \",\"DeptServiceImpl（业务实现类）\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public List<Dept> list() { List<Dept> deptList = deptMapper.list(); return deptList; } } \",\"DeptMapper:\",\"@Mapper public interface DeptMapper { //查询所有部门数据 @Select(\\\"select id, name, create_time, update_time from dept\\\") List<Dept> list(); } \"]},{\"header\":\"1.1.5 功能测试\",\"slug\":\"_1-1-5-功能测试\",\"contents\":[\"启动项目，打开postman，发起GET请求，访问 ：http://localhost:8080/depts\"]},{\"header\":\"1.2 前后端联调\",\"slug\":\"_1-2-前后端联调\",\"contents\":[\"1、启动nginx\",\"2、打开浏览器，访问：[http://localhost:90]\",\"3、测试：部门管理 - 查询部门列表\"]},{\"header\":\"1.3 删除部门\",\"slug\":\"_1-3-删除部门\",\"contents\":[]},{\"header\":\"1.3.1 需求\",\"slug\":\"_1-3-1-需求\",\"contents\":[]},{\"header\":\"1.3.2 接口文档\",\"slug\":\"_1-3-2-接口文档\",\"contents\":[\"删除部门:\",\"基本信息\",\"请求路径：/depts/{id} 请求方式：DELETE 接口描述：该接口用于根据ID删除部门数据 \",\"请求参数 参数格式：路径参数\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"id\",\"number\",\"必须\",\"部门ID\",\"请求参数样例：\",\"/depts/1 \",\"响应数据 参数格式：application/json\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"code\",\"number\",\"必须\",\"响应码，1 代表成功，0 代表失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object\",\"非必须\",\"返回的数据\",\"响应数据样例：\",\"{ \\\"code\\\":1, \\\"msg\\\":\\\"success\\\", \\\"data\\\":null } \"]},{\"header\":\"1.3.3 思路分析\",\"slug\":\"_1-3-3-思路分析\",\"contents\":[\"接口文档规定：\",\"前端请求路径：/depts/\",\"前端请求方式：DELETE\",\"问题1：怎么在controller中接收请求路径中的路径参数？\",\"@PathVariable \",\"问题2：如何限定请求方式是delete？\",\"@DeleteMapping \"]},{\"header\":\"1.3.4 功能开发\",\"slug\":\"_1-3-4-功能开发\",\"contents\":[\"请求路径：/depts/\",\"请求方式：DELETE\",\"请求参数：路径参数\",\"响应数据：json格式\",\"DeptController:\",\"@Slf4j @RestController public class DeptController { @Autowired private DeptService deptService; @DeleteMapping(\\\"/depts/{id}\\\") public Result delete(@PathVariable Integer id) { //日志记录 log.info(\\\"根据id删除部门\\\"); //调用service层功能 deptService.delete(id); //响应 return Result.success(); } //省略... } \",\"DeptService:\",\"public interface DeptService { /** * 根据id删除部门 * @param id 部门id */ void delete(Integer id); //省略... } \",\"DeptServiceImpl:\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public void delete(Integer id) { //调用持久层删除功能 deptMapper.deleteById(id); } //省略... } \",\"DeptMapper:\",\"@Mapper public interface DeptMapper { /** * 根据id删除部门信息 * @param id 部门id */ @Delete(\\\"delete from dept where id = #{id}\\\") void deleteById(Integer id); //省略... } \"]},{\"header\":\"1.3.5 功能测试\",\"slug\":\"_1-3-5-功能测试\",\"contents\":[\"重新启动项目，使用postman，发起DELETE请求：\"]},{\"header\":\"1.3.6 前后端联调\",\"slug\":\"_1-3-6-前后端联调\",\"contents\":[]},{\"header\":\"1.4 新增部门\",\"slug\":\"_1-4-新增部门\",\"contents\":[]},{\"header\":\"1.4.1 需求\",\"slug\":\"_1-4-1-需求\",\"contents\":[]},{\"header\":\"1.4.2 接口文档\",\"slug\":\"_1-4-2-接口文档\",\"contents\":[\"添加部门:\",\"基本信息\",\"请求路径：/depts 请求方式：POST 接口描述：该接口用于添加部门数据 \",\"请求参数\",\"格式：application/json\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"name\",\"string\",\"必须\",\"部门名称\",\"请求参数样例：\",\"{ \\\"name\\\": \\\"教研部\\\" } \",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"code\",\"number\",\"必须\",\"响应码，1 代表成功，0 代表失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object\",\"非必须\",\"返回的数据\",\"响应数据样例：\",\"{ \\\"code\\\":1, \\\"msg\\\":\\\"success\\\", \\\"data\\\":null } \"]},{\"header\":\"1.4.3 思路分析\",\"slug\":\"_1-4-3-思路分析\",\"contents\":[\"接口文档规定：\",\"前端请求路径：/depts\",\"前端请求方式：POST\",\"前端请求参数：Json格式：{ \\\"name\\\": \\\"教研部\\\" }\",\"问题1：如何限定请求方式是POST？\",\"@PostMapping \",\"问题2：怎么在controller中接收json格式的请求参数？\",\"@RequestBody //把前端传递的json数据填充到实体类中 \"]},{\"header\":\"1.4.4 功能开发\",\"slug\":\"_1-4-4-功能开发\",\"contents\":[\"通过查看接口文档：新增部门\",\"请求路径：/depts\",\"请求方式：POST\",\"请求参数：json格式\",\"响应数据：json格式\",\"DeptController:\",\"@Slf4j @RestController public class DeptController { @Autowired private DeptService deptService; @PostMapping(\\\"/depts\\\") public Result add(@RequestBody Dept dept){ //记录日志 log.info(\\\"新增部门：{}\\\",dept); //调用service层添加功能 deptService.add(dept); //响应 return Result.success(); } //省略... } \",\"DeptService:\",\"public interface DeptService { /** * 新增部门 * @param dept 部门对象 */ void add(Dept dept); //省略... } \",\"DeptServiceImpl:\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public void add(Dept dept) { //补全部门数据 dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); //调用持久层增加功能 deptMapper.inser(dept); } //省略... } \",\"DeptMapper:\",\"@Mapper public interface DeptMapper { @Insert(\\\"insert into dept (name, create_time, update_time) values (#{name},#{createTime},#{updateTime})\\\") void inser(Dept dept); //省略... } \"]},{\"header\":\"1.4.5 功能测试\",\"slug\":\"_1-4-5-功能测试\",\"contents\":[\"重新启动项目，使用postman，发起POST请求：\"]},{\"header\":\"1.4.6 前后端联调\",\"slug\":\"_1-4-6-前后端联调\",\"contents\":[]},{\"header\":\"1.4.7 请求路径\",\"slug\":\"_1-4-7-请求路径\",\"contents\":[\"部门管理的查询、删除、新增功能全部完成了，接下来对controller层的代码进行优化。\",\"以上三个方法上的请求路径，存在一个共同点：都是以/depts作为开头。\",\"在Spring当中为了简化请求路径的定义，可以把公共的请求路径，直接抽取到类上，在类上加一个注解@RequestMapping，并指定请求路径\\\"/depts\\\"\",\"优化前后的对比：\",\" 注意事项：一个完整的请求路径，应该是类上@RequestMapping的value属性 + 方法上的@RequestMapping的value属性\"]},{\"header\":\"2. 员工管理\",\"slug\":\"_2-员工管理\",\"contents\":[\"基于以上原型，可以把员工管理功能分为：\",\"分页查询\",\"带条件的分页查询\",\"删除员工\",\"新增员工\",\"修改员工\"]},{\"header\":\"2.1 分页查询\",\"slug\":\"_2-1-分页查询\",\"contents\":[]},{\"header\":\"2.1.1 基础分页\",\"slug\":\"_2-1-1-基础分页\",\"contents\":[\"需求分析：\",\"要想从数据库中进行分页查询，要使用LIMIT关键字\",\"格式为：limit 开始索引 每页显示的条数\",\"查询第1页数据的SQL语句是：\",\"select * from emp limit 0,10; \",\"查询第2页数据的SQL语句是：\",\"select * from emp limit 10,10; \",\"开始索引的计算公式：开始索引 = (当前页码 - 1) * 每页显示条数\",\"结论：\",\"前端在请求服务端时，传递的参数 \",\"当前页码 page\",\"每页显示条数 pageSize\",\"后端需要响应什么数据给前端 \",\"所查询到的数据列表（存储到List 集合中）\",\"总记录数\",\"后台给前端返回的数据包含：List集合(数据列表)、total(总记录数)\",\"而这两部分通常封装到PageBean对象中，并将该对象转换为json格式的数据响应回给浏览器。\",\"@Data @NoArgsConstructor @AllArgsConstructor public class PageBean { private Long total; //总记录数 private List rows; //当前页数据列表 } \",\"接口文档：\",\"员工列表查询\",\"基本信息\",\"请求路径：/emps 请求方式：GET 接口描述：该接口用于员工列表数据的条件分页查询 \",\"请求参数\",\"参数格式：queryString\",\"参数说明：\",\"参数名称\",\"是否必须\",\"示例\",\"备注\",\"name\",\"否\",\"张\",\"姓名\",\"gender\",\"否\",\"1\",\"性别 , 1 男 , 2 女\",\"begin\",\"否\",\"2010-01-01\",\"范围匹配的开始时间(入职日期)\",\"end\",\"否\",\"2020-01-01\",\"范围匹配的结束时间(入职日期)\",\"page\",\"是\",\"1\",\"分页查询的页码，如果未指定，默认为1\",\"pageSize\",\"是\",\"10\",\"分页查询的每页记录数，如果未指定，默认为10\",\"请求数据样例：\",\"/emps?name=张&gender=1&begin=2007-09-01&end=2022-09-01&page=1&pageSize=10 \",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"默认值\",\"备注\",\"其他信息\",\"code\",\"number\",\"必须\",\"响应码, 1 成功 , 0 失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object\",\"必须\",\"返回的数据\",\"|- total\",\"number\",\"必须\",\"总记录数\",\"|- rows\",\"object []\",\"必须\",\"数据列表\",\"item 类型: object\",\"|- id\",\"number\",\"非必须\",\"id\",\"|- username\",\"string\",\"非必须\",\"用户名\",\"|- name\",\"string\",\"非必须\",\"姓名\",\"|- password\",\"string\",\"非必须\",\"密码\",\"|- entrydate\",\"string\",\"非必须\",\"入职日期\",\"|- gender\",\"number\",\"非必须\",\"性别 , 1 男 ; 2 女\",\"|- image\",\"string\",\"非必须\",\"图像\",\"|- job\",\"number\",\"非必须\",\"职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师\",\"|- deptId\",\"number\",\"非必须\",\"部门id\",\"|- createTime\",\"string\",\"非必须\",\"创建时间\",\"|- updateTime\",\"string\",\"非必须\",\"更新时间\",\"响应数据样例：\",\"{ \\\"code\\\": 1, \\\"msg\\\": \\\"success\\\", \\\"data\\\": { \\\"total\\\": 2, \\\"rows\\\": [ { \\\"id\\\": 1, \\\"username\\\": \\\"jinyong\\\", \\\"password\\\": \\\"123456\\\", \\\"name\\\": \\\"金庸\\\", \\\"gender\\\": 1, \\\"image\\\": \\\"https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg\\\", \\\"job\\\": 2, \\\"entrydate\\\": \\\"2015-01-01\\\", \\\"deptId\\\": 2, \\\"createTime\\\": \\\"2022-09-01T23:06:30\\\", \\\"updateTime\\\": \\\"2022-09-02T00:29:04\\\" }, { \\\"id\\\": 2, \\\"username\\\": \\\"zhangwuji\\\", \\\"password\\\": \\\"123456\\\", \\\"name\\\": \\\"张无忌\\\", \\\"gender\\\": 1, \\\"image\\\": \\\"https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg\\\", \\\"job\\\": 2, \\\"entrydate\\\": \\\"2015-01-01\\\", \\\"deptId\\\": 2, \\\"createTime\\\": \\\"2022-09-01T23:06:30\\\", \\\"updateTime\\\": \\\"2022-09-02T00:29:04\\\" } ] } } \",\"思路分析:\",\"分页查询需要的数据，封装在PageBean对象中：\",\"功能开发:\",\"请求路径：/emps\",\"请求方式：GET\",\"请求参数：跟随在请求路径后的参数字符串。 例：/emps?page=1&pageSize=10\",\"响应数据：json格式\",\"EmpController:\",\"import com.itheima.pojo.PageBean; import com.itheima.pojo.Result; import com.itheima.service.EmpService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @Slf4j @RestController @RequestMapping(\\\"/emps\\\") public class EmpController { @Autowired private EmpService empService; //条件分页查询 @GetMapping public Result page(@RequestParam(defaultValue = \\\"1\\\") Integer page, @RequestParam(defaultValue = \\\"10\\\") Integer pageSize) { //记录日志 log.info(\\\"分页查询，参数：{},{}\\\", page, pageSize); //调用业务层分页查询功能 PageBean pageBean = empService.page(page, pageSize); //响应 return Result.success(pageBean); } } \",\"@RequestParam(defaultValue=\\\"默认值\\\") //设置请求参数默认值\",\"EmpService:\",\"public interface EmpService { /** * 条件分页查询 * @param page 页码 * @param pageSize 每页展示记录数 * @return */ PageBean page(Integer page, Integer pageSize); } \",\"EmpServiceImpl:\",\"import com.itheima.mapper.EmpMapper; import com.itheima.pojo.Emp; import com.itheima.pojo.PageBean; import com.itheima.service.EmpService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.time.LocalDate; import java.util.List; @Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public PageBean page(Integer page, Integer pageSize) { //1、获取总记录数 Long count = empMapper.count(); //2、获取分页查询结果列表 Integer start = (page - 1) * pageSize; //计算起始索引 , 公式: (页码-1)*页大小 List<Emp> empList = empMapper.list(start, pageSize); //3、封装PageBean对象 PageBean pageBean = new PageBean(count , empList); return pageBean; } } \",\"EmpMapper:\",\"@Mapper public interface EmpMapper { //获取总记录数 @Select(\\\"select count(*) from emp\\\") public Long count(); //获取当前页的结果列表 @Select(\\\"select * from emp limit #{start}, #{pageSize}\\\") public List<Emp> list(Integer start, Integer pageSize); } \",\"功能测试:\",\"功能开发完成后，重新启动项目，使用postman，发起POST请求：\",\"前后端联调:\",\"打开浏览器，测试后端功能接口：\"]},{\"header\":\"2.1.2 分页插件\",\"slug\":\"_2-1-2-分页插件\",\"contents\":[\"介绍:\",\"基础的分页查询功能编写起来比较繁琐\",\"结论：原始方式的分页查询，存在着\\\"步骤固定\\\"、\\\"代码频繁\\\"的问题\",\"解决方案：可以使用一些现成的分页插件完成。对于Mybatis来讲现在最主流的就是PageHelper。\",\"PageHelper是Mybatis的一款功能强大、方便易用的分页插件，支持任何形式的单标、多表的分页查询。\",\"官网：[https://pagehelper.github.io/]\",\"在执行empMapper.list()方法时，就是执行：select * from emp 语句，怎么能够实现分页操作呢？\",\"分页插件帮我们完成了以下操作：\",\"先获取到要执行的SQL语句：select * from emp\",\"把SQL语句中的字段列表，变为：count(*)\",\"执行SQL语句：select count(*) from emp //获取到总记录数\",\"再对要执行的SQL语句：select * from emp 进行改造，在末尾添加 limit ? , ?\",\"执行改造后的SQL语句：select * from emp limit ? , ?\",\"代码实现:\",\"当使用了PageHelper分页插件进行分页，就无需再Mapper中进行手动分页了。\",\"注\",\"在Mapper中只需要进行正常的列表查询即可\",\"在Service层中，调用Mapper的方法之前设置分页参数\",\"在调用Mapper方法执行查询之后，解析分页结果，并将结果封装到PageBean对象中返回\",\"1、在pom.xml引入依赖\",\"<dependency> <groupId>com.github.pagehelper</groupId> <artifactId>pagehelper-spring-boot-starter</artifactId> <version>1.4.2</version> </dependency> \",\"2、EmpMapper\",\"@Mapper public interface EmpMapper { //获取当前页的结果列表 @Select(\\\"select * from emp\\\") public List<Emp> page(Integer start, Integer pageSize); } \",\"3、EmpServiceImpl\",\"@Override public PageBean page(Integer page, Integer pageSize) { // 设置分页参数 PageHelper.startPage(page, pageSize); // 执行分页查询 List<Emp> empList = empMapper.list(name,gender,begin,end); // 获取分页结果 Page<Emp> p = (Page<Emp>) empList; //封装PageBean PageBean pageBean = new PageBean(p.getTotal(), p.getResult()); return pageBean; } \",\"测试:\",\"功能开发完成后，我们重启项目工程，打开postman，发起GET请求，访问 ：[http://localhost:8080/emps?page=1&pageSize=5]\",\"后端程序SQL输出：\"]},{\"header\":\"2.2 分页查询(带条件)\",\"slug\":\"_2-2-分页查询-带条件\",\"contents\":[]},{\"header\":\"2.2.1 需求\",\"slug\":\"_2-2-1-需求\",\"contents\":[\"通过员工管理的页面原型可以看到，员工列表页面的查询，不仅仅需要考虑分页，还需要考虑查询条件。\",\"看到页面原型及需求中描述，搜索栏的搜索条件有三个，分别是：\",\"姓名：模糊匹配\",\"性别：精确匹配\",\"入职日期：范围匹配\",\"select * from emp where name like concat('%','张','%') -- 条件1：根据姓名模糊匹配 and gender = 1 -- 条件2：根据性别精确匹配 and entrydate = between '2000-01-01' and '2010-01-01' -- 条件3：根据入职日期范围匹配 order by update_time desc; \"]},{\"header\":\"2.2.2 思路分析\",\"slug\":\"_2-2-2-思路分析\",\"contents\":[]},{\"header\":\"2.2.3 功能开发\",\"slug\":\"_2-2-3-功能开发\",\"contents\":[\"通过查看接口文档：员工列表查询\",\"请求路径：/emps\",\"请求方式：GET\",\"请求参数：\",\"参数名称\",\"是否必须\",\"示例\",\"备注\",\"name\",\"否\",\"张\",\"姓名\",\"gender\",\"否\",\"1\",\"性别 , 1 男 , 2 女\",\"begin\",\"否\",\"2010-01-01\",\"范围匹配的开始时间(入职日期)\",\"end\",\"否\",\"2020-01-01\",\"范围匹配的结束时间(入职日期)\",\"page\",\"是\",\"1\",\"分页查询的页码，如果未指定，默认为1\",\"pageSize\",\"是\",\"10\",\"分页查询的每页记录数，如果未指定，默认为10\",\"在原有分页查询的代码基础上进行改造：\",\"EmpController:\",\"@Slf4j @RestController @RequestMapping(\\\"/emps\\\") public class EmpController { @Autowired private EmpService empService; //条件分页查询 @GetMapping public Result page(@RequestParam(defaultValue = \\\"1\\\") Integer page, @RequestParam(defaultValue = \\\"10\\\") Integer pageSize, String name, Short gender, @DateTimeFormat(pattern = \\\"yyyy-MM-dd\\\") LocalDate begin, @DateTimeFormat(pattern = \\\"yyyy-MM-dd\\\") LocalDate end) { //记录日志 log.info(\\\"分页查询，参数：{},{},{},{},{},{}\\\", page, pageSize,name, gender, begin, end); //调用业务层分页查询功能 PageBean pageBean = empService.page(page, pageSize, name, gender, begin, end); //响应 return Result.success(pageBean); } } \",\"EmpService:\",\"public interface EmpService { /** * 条件分页查询 * @param page 页码 * @param pageSize 每页展示记录数 * @param name 姓名 * @param gender 性别 * @param begin 开始时间 * @param end 结束时间 * @return */ PageBean page(Integer page, Integer pageSize, String name, Short gender, LocalDate begin, LocalDate end); } \",\"EmpServiceImpl:\",\"@Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public PageBean page(Integer page, Integer pageSize, String name, Short gender, LocalDate begin, LocalDate end) { //设置分页参数 PageHelper.startPage(page, pageSize); //执行条件分页查询 List<Emp> empList = empMapper.list(name, gender, begin, end); //获取查询结果 Page<Emp> p = (Page<Emp>) empList; //封装PageBean PageBean pageBean = new PageBean(p.getTotal(), p.getResult()); return pageBean; } } \",\"EmpMapper:\",\"@Mapper public interface EmpMapper { //获取当前页的结果列表 public List<Emp> list(String name, Short gender, LocalDate begin, LocalDate end); } \",\"EmpMapper.xml:\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"com.itheima.mapper.EmpMapper\\\"> <!-- 条件分页查询 --> <select id=\\\"list\\\" resultType=\\\"com.itheima.pojo.Emp\\\"> select * from emp <where> <if test=\\\"name != null and name != ''\\\"> name like concat('%',#{name},'%') </if> <if test=\\\"gender != null\\\"> and gender = #{gender} </if> <if test=\\\"begin != null and end != null\\\"> and entrydate between #{begin} and #{end} </if> </where> order by update_time desc </select> </mapper> \"]},{\"header\":\"2.2.4 功能测试\",\"slug\":\"_2-2-4-功能测试\",\"contents\":[\"功能开发完成后，重启项目工程，打开postman，发起GET请求：\",\"控制台SQL语句：\"]},{\"header\":\"2.2.5 前后端联调\",\"slug\":\"_2-2-5-前后端联调\",\"contents\":[\"打开浏览器，测试后端功能接口：\"]},{\"header\":\"2.3 删除员工\",\"slug\":\"_2-3-删除员工\",\"contents\":[]},{\"header\":\"2.3.1 需求\",\"slug\":\"_2-3-1-需求\",\"contents\":[\"当勾选列表前面的复选框，然后点击 \\\"批量删除\\\" 按钮，就可以将这一批次的员工信息删除掉了。也可以只勾选一个复选框，仅删除一个员工信息。\",\"问题：我们需要开发两个功能接口吗？一个删除单个员工，一个删除多个员工\",\"答案：不需要。 只需要开发一个功能接口即可（删除多个员工包含只删除一个员工）\"]},{\"header\":\"2.3.2 接口文档\",\"slug\":\"_2-3-2-接口文档\",\"contents\":[\"删除员工:\",\"基本信息\",\"请求路径：/emps/{ids} 请求方式：DELETE 接口描述：该接口用于批量删除员工的数据信息 \",\"请求参数\",\"参数格式：路径参数\",\"参数说明：\",\"参数名\",\"类型\",\"示例\",\"是否必须\",\"备注\",\"ids\",\"数组 array\",\"1,2,3\",\"必须\",\"员工的id数组\",\"请求参数样例：\",\"/emps/1,2,3 \",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"code\",\"number\",\"必须\",\"响应码，1 代表成功，0 代表失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object\",\"非必须\",\"返回的数据\",\"响应数据样例：\",\"{ \\\"code\\\":1, \\\"msg\\\":\\\"success\\\", \\\"data\\\":null } \"]},{\"header\":\"2.3.3 思路分析\",\"slug\":\"_2-3-3-思路分析\",\"contents\":[\"接口文档规定：\",\"前端请求路径：/emps/\",\"前端请求方式：DELETE\",\"问题1：怎么在controller中接收请求路径中的路径参数？\",\"@PathVariable \",\"问题2：如何限定请求方式是delete？\",\"@DeleteMapping \",\"问题3：在Mapper接口中，执行delete操作的SQL语句时，条件中的id值是不确定的是动态的，怎么实现呢？\",\"Mybatis中的动态SQL：foreach \"]},{\"header\":\"2.3.4 功能开发\",\"slug\":\"_2-3-4-功能开发\",\"contents\":[\"通过查看接口文档：删除员工\",\"请求路径：/emps/\",\"请求方式：DELETE\",\"请求参数：路径参数\",\"响应数据：json格式\",\"EmpController:\",\"@Slf4j @RestController @RequestMapping(\\\"/emps\\\") public class EmpController { @Autowired private EmpService empService; //批量删除 @DeleteMapping(\\\"/{ids}\\\") public Result delete(@PathVariable List<Integer> ids){ empService.delete(ids); return Result.success(); } //条件分页查询 @GetMapping public Result page(@RequestParam(defaultValue = \\\"1\\\") Integer page, @RequestParam(defaultValue = \\\"10\\\") Integer pageSize, String name, Short gender, @DateTimeFormat(pattern = \\\"yyyy-MM-dd\\\") LocalDate begin, @DateTimeFormat(pattern = \\\"yyyy-MM-dd\\\") LocalDate end) { //记录日志 log.info(\\\"分页查询，参数：{},{},{},{},{},{}\\\", page, pageSize,name, gender, begin, end); //调用业务层分页查询功能 PageBean pageBean = empService.page(page, pageSize, name, gender, begin, end); //响应 return Result.success(pageBean); } } \",\"EmpService:\",\"public interface EmpService { /** * 批量删除操作 * @param ids id集合 */ void delete(List<Integer> ids); //省略... } \",\"EmpServiceImpl:\",\"@Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public void delete(List<Integer> ids) { empMapper.delete(ids); } //省略... } \",\"EmpMapper:\",\"@Mapper public interface EmpMapper { //批量删除 void delete(List<Integer> ids); //省略... } \",\"EmpMapper.xml:\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"com.itheima.mapper.EmpMapper\\\"> <!--批量删除员工--> <select id=\\\"delete\\\"> delete from emp where id in <foreach collection=\\\"ids\\\" item=\\\"id\\\" open=\\\"(\\\" close=\\\")\\\" separator=\\\",\\\"> #{id} </foreach> </select> <!-- 省略... --> </mapper> \"]},{\"header\":\"2.3.5 功能测试\",\"slug\":\"_2-3-5-功能测试\",\"contents\":[\"功能开发完成后，重启项目工程，打开postman，发起DELETE请求：\",\"控制台SQL语句：\"]},{\"header\":\"2.3.6 前后端联调\",\"slug\":\"_2-3-6-前后端联调\",\"contents\":[\"打开浏览器，测试后端功能接口：\"]}]},\"/BackEnd/SpringBoot/springboot04.html\":{\"title\":\"SpringBoot案例 ⅟\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"关于员工管理的功能，还有两个需求:\",\"新增员工\",\"修改员工\",\"在\\\"新增员工\\\"中，需要添加头像，而头像需要用到\\\"文件上传\\\"技术。\"]},{\"header\":\"1. 新增员工\",\"slug\":\"_1-新增员工\",\"contents\":[]},{\"header\":\"1.1 需求\",\"slug\":\"_1-1-需求\",\"contents\":[]},{\"header\":\"1.2 接口文档\",\"slug\":\"_1-2-接口文档\",\"contents\":[\"基本信息\",\"请求路径：/emps 请求方式：POST 接口描述：该接口用于添加员工的信息 \",\"请求参数\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"备注\",\"username\",\"string\",\"必须\",\"用户名\",\"name\",\"string\",\"必须\",\"姓名\",\"gender\",\"number\",\"必须\",\"性别, 说明: 1 男, 2 女\",\"image\",\"string\",\"非必须\",\"图像\",\"deptId\",\"number\",\"非必须\",\"部门id\",\"entrydate\",\"string\",\"非必须\",\"入职日期\",\"job\",\"number\",\"非必须\",\"职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师\",\"请求数据样例：\",\"{ \\\"image\\\": \\\"https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-03-07-37-38222.jpg\\\", \\\"username\\\": \\\"linpingzhi\\\", \\\"name\\\": \\\"林平之\\\", \\\"gender\\\": 1, \\\"job\\\": 1, \\\"entrydate\\\": \\\"2022-09-18\\\", \\\"deptId\\\": 1 } \",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"code\",\"number\",\"必须\",\"响应码，1 代表成功，0 代表失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object\",\"非必须\",\"返回的数据\",\"响应数据样例：\",\"{ \\\"code\\\":1, \\\"msg\\\":\\\"success\\\", \\\"data\\\":null } \"]},{\"header\":\"1.3 思路分析\",\"slug\":\"_1-3-思路分析\",\"contents\":[\"新增员工的具体的流程：\",\"接口文档规定：\",\"请求路径：/emps\",\"请求方式：POST\",\"请求参数：Json格式数据\",\"响应数据：Json格式数据\",\"问题1：如何限定请求方式是POST？\",\"@PostMapping \",\"问题2：怎么在controller中接收json格式的请求参数？\",\"@RequestBody //把前端传递的json数据填充到实体类中 \"]},{\"header\":\"1.4 功能开发\",\"slug\":\"_1-4-功能开发\",\"contents\":[\"EmpController:\",\"@Slf4j @RestController @RequestMapping(\\\"/emps\\\") public class EmpController { @Autowired private EmpService empService; //新增 @PostMapping public Result save(@RequestBody Emp emp){ //记录日志 log.info(\\\"新增员工, emp:{}\\\",emp); //调用业务层新增功能 empService.save(emp); //响应 return Result.success(); } //省略... } \",\"EmpService:\",\"public interface EmpService { /** * 保存员工信息 * @param emp */ void save(Emp emp); //省略... } \",\"EmpServiceImpl:\",\"@Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public void save(Emp emp) { //补全数据 emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); //调用添加方法 empMapper.insert(emp); } //省略... } \",\"EmpMapper:\",\"@Mapper public interface EmpMapper { //新增员工 @Insert(\\\"insert into emp (username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \\\" + \\\"values (#{username}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime});\\\") void insert(Emp emp); //省略... } \"]},{\"header\":\"1.5 功能测试\",\"slug\":\"_1-5-功能测试\",\"contents\":[\"代码开发完成后，重启服务器，打开Postman发送 POST 请求，请求路径：http://localhost:8080/emps\"]},{\"header\":\"1.6 前后端联调\",\"slug\":\"_1-6-前后端联调\",\"contents\":[\"功能测试通过后，我们再进行通过打开浏览器，测试后端功能接口：\"]},{\"header\":\"2. 文件上传\",\"slug\":\"_2-文件上传\",\"contents\":[\"上述问题，需要我们通过文件上传技术来解决。\"]},{\"header\":\"2.1 简介\",\"slug\":\"_2-1-简介\",\"contents\":[\"文件上传: 指将本地图片、视频、音频等文件上传到服务器，供其他用户浏览或下载的过程。\",\"文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。\",\"文件上传功能需要涉及到两个部分：\",\"前端程序\",\"服务端程序\",\"前端代码：\",\"<form action=\\\"/upload\\\" method=\\\"post\\\" enctype=\\\"multipart/form-data\\\"> 姓名: <input type=\\\"text\\\" name=\\\"username\\\"><br> 年龄: <input type=\\\"text\\\" name=\\\"age\\\"><br> 头像: <input type=\\\"file\\\" name=\\\"image\\\"><br> <input type=\\\"submit\\\" value=\\\"提交\\\"> </form> \",\"上传文件的原始form表单，要求表单必须具备以下三点（上传文件页面三要素）：\",\"表单必须有file域，用于选择要上传的文件\",\"<input type=\\\"file\\\" name=\\\"image\\\"/> \",\"表单提交方式必须为POST\",\"通常上传的文件会比较大，所以需要使用 POST 提交方式\",\"表单的编码类型 enctype 必须要设置为：multipart/form-data\",\"普通默认的编码格式是不适合传输大型的二进制数据的，所以在文件上传时，表单的编码格式必须设置为 multipart/form-data\",\"文件上传3要素\",\"验证：删除form表单中enctype属性值，会是什么情况？\",\"在IDEA中直接使用浏览器打开upload.html页面\",\"选择要上传的本地文件\",\"点击\\\"提交\\\"按钮，进入到开发者模式观察\",\"设置form表单中enctype属性值为multipart/form-data，会是什么情况？\",\" <form action=\\\"/upload\\\" method=\\\"post\\\" enctype=\\\"multipart/form-data\\\"> 姓名: <input type=\\\"text\\\" name=\\\"username\\\"><br> 年龄: <input type=\\\"text\\\" name=\\\"age\\\"><br> 头像: <input type=\\\"file\\\" name=\\\"image\\\"><br> <input type=\\\"submit\\\" value=\\\"提交\\\"> </form> \",\"知道了前端程序中需要设置上传文件页面三要素，那后端程序又是如何实现的呢？\",\"首先在服务端定义一个controller，用来进行文件上传，然后在controller当中定义一个方法来处理/upload 请求\",\"在定义的方法中接收提交过来的数据 （方法中的形参名和请求参数的名字保持一致）\",\"用户名：String name\",\"年龄： Integer age\",\"文件： MultipartFile image\",\"Spring中提供了一个API：MultipartFile，使用这个API就可以来接收到上传的文件\",\"问题：如果表单项的名字和方法中形参名不一致，该怎么办？\",\"public Result upload(String username, Integer age, MultipartFile file) //file形参名和请求参数名image不一致 \",\"解决：使用@RequestParam注解进行参数绑定\",\"public Result upload(String username, Integer age, @RequestParam(\\\"image\\\") MultipartFile file) \",\"UploadController代码：\",\"@Slf4j @RestController public class UploadController { @PostMapping(\\\"/upload\\\") public Result upload(String username, Integer age, MultipartFile image) { log.info(\\\"文件上传：{},{},{}\\\",username,age,image); return Result.success(); } } \",\"后端程序编写完成之后，打个断点，以debug方式启动SpringBoot项目\",\"打开浏览器输入：http://localhost:8080/upload.html ， 录入数据并提交\",\"通过后端程序控制台可以看到，上传的文件是存放在一个临时目录\",\"打开临时目录可以看到以下内容：\",\"表单提交的三项数据(姓名、年龄、文件)，分别存储在不同的临时文件中： 当我们程序运行完毕之后，这个临时文件会自动删除。\",\"所以，我们如果想要实现文件上传，需要将这个临时文件，要转存到我们的磁盘目录中。\"]},{\"header\":\"2.2 本地存储\",\"slug\":\"_2-2-本地存储\",\"contents\":[\"文件上传时在服务端会产生一个临时文件，请求响应完成之后，这个临时文件被自动删除，并没有进行保存。需要将上传的文件保存在服务器的本地磁盘上。\",\"代码实现：\",\"在服务器本地磁盘上创建images目录，用来存储上传的文件（例：E盘创建images目录）\",\"使用MultipartFile类提供的API方法，把临时文件转存到本地磁盘目录下\",\"MultipartFile 常见方法：\",\"String getOriginalFilename(); //获取原始文件名\",\"void transferTo(File dest); //将接收的文件转存到磁盘文件中\",\"long getSize(); //获取文件的大小，单位：字节\",\"byte[] getBytes(); //获取文件内容的字节数组\",\"InputStream getInputStream(); //获取接收到的文件内容的输入流\",\"@Slf4j @RestController public class UploadController { @PostMapping(\\\"/upload\\\") public Result upload(String username, Integer age, MultipartFile image) throws IOException { log.info(\\\"文件上传：{},{},{}\\\",username,age,image); //获取原始文件名 String originalFilename = image.getOriginalFilename(); //将文件存储在服务器的磁盘目录 image.transferTo(new File(\\\"E:/images/\\\"+originalFilename)); return Result.success(); } } \",\"利用postman测试：\",\"注意：请求参数名和controller方法形参名保持一致\",\"通过postman测试，文件上传是没有问题的。但是当我们再次上传一个名为1.jpg文件时，发现会把之前已经上传成功的文件会被覆盖掉。\",\"解决方案：保证每次上传文件时文件名都唯一的（使用UUID获取随机文件名）\",\"@Slf4j @RestController public class UploadController { @PostMapping(\\\"/upload\\\") public Result upload(String username, Integer age, MultipartFile image) throws IOException { log.info(\\\"文件上传：{},{},{}\\\",username,age,image); //获取原始文件名 String originalFilename = image.getOriginalFilename(); //构建新的文件名 String extname = originalFilename.substring(originalFilename.lastIndexOf(\\\".\\\"));//文件扩展名 String newFileName = UUID.randomUUID().toString()+extname;//随机名+文件扩展名 //将文件存储在服务器的磁盘目录 image.transferTo(new File(\\\"E:/images/\\\"+newFileName)); return Result.success(); } } \",\"在解决了文件名唯一性的问题后，再次上传一个较大的文件(超出1M)时发现，后端程序报错：\",\"报错原因：在SpringBoot中，文件上传时默认单个文件最大的大小为1M\",\"如果需要上传大文件，可以在application.properties进行如下配置：\",\"#配置单个文件最大上传大小 spring.servlet.multipart.max-file-size=10MB #配置单个请求最大上传大小(一次请求可以上传多个文件) spring.servlet.multipart.max-request-size=100MB \",\"本地存储方式存在问题：\",\"警告\",\"直接存储在服务器的磁盘目录中，存在以下缺点：\",\"不安全：磁盘如果损坏，所有的文件就会丢失\",\"容量有限：如果存储大量的图片，磁盘空间有限(磁盘不可能无限制扩容)\",\"无法直接访问\",\"解决方案\",\"自己搭建存储服务器，如：fastDFS 、MinIO\",\"使用现成的云服务，如：阿里云，腾讯云，华为云\"]},{\"header\":\"2.3 阿里云OSS\",\"slug\":\"_2-3-阿里云oss\",\"contents\":[]},{\"header\":\"2.3.1 准备\",\"slug\":\"_2-3-1-准备\",\"contents\":[\"阿里云是阿里巴巴集团旗下全球领先的云计算公司，也是国内最大的云服务提供商 。\",\"云服务指的就是通过互联网对外提供的各种各样的服务，比如像：语音服务、短信服务、邮件服务、视频直播服务、文字识别服务、对象存储服务等等。\",\"当我们在项目开发时需要用到某个或某些服务，就不需要自己来开发了，可以直接使用阿里云提供好的这些现成服务就可以了。\",\"比如：在项目开发当中，我们要实现一个短信发送的功能，如果我们项目组自己实现，将会非常繁琐，因为你需要和各个运营商进行对接。而此时阿里云完成了和三大运营商对接，并对外提供了一个短信服务。我们项目组只需要调用阿里云提供的短信服务，就可以很方便的来发送短信了。这样就降低了我们项目的开发难度，同时也提高了项目的开发效率。（大白话：别人帮我们实现好了功能，我们只要调用即可）\",\"阿里云对象存储OSS（Object Storage Service），是一款海量、安全、低成本、高可靠的云存储服务。使用OSS，您可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种文件。\",\"使用了阿里云OSS对象存储服务之后，在项目当中如果涉及到文件上传这样的业务，在前端进行文件上传并请求到服务端时，在服务器本地磁盘当中就不需要再来存储文件了。我们直接将接收到的文件上传到oss，由 oss帮我们存储和管理，同时阿里云的oss存储服务还保障了我们所存储内容的安全可靠。\",\"SDK：Software Development Kit 的缩写，软件开发工具包，包括辅助软件开发的依赖（jar包）、代码示例等，都可以叫做SDK。\",\"简单说，sdk中包含了我们使用第三方云服务时所需要的依赖，以及一些示例代码。我们可以参照sdk所提供的示例代码就可以完成入门程序。\",\"Bucket：存储空间是用户用于存储对象（Object，就是文件）的容器，所有的对象都必须隶属于某个存储空间。\",\"准备工作：\",\"注册阿里云账户（注册完成后需要实名认证）\",\"注册完账号之后，登录阿里云\",\"通过控制台找到对象存储OSS服务\",\"如果是第一次访问，还需要开通对象存储服务OSS\",\"开通OSS服务之后，就可以进入到阿里云对象存储的控制台\",\"点击左侧的 \\\"Bucket列表\\\"，创建一个Bucket\"]},{\"header\":\"2.3.2 入门\",\"slug\":\"_2-3-2-入门\",\"contents\":[\"参照官方所提供的sdk示例来编写入门程序。\",\"首先需要打开阿里云OSS的官方文档，在官方文档中找到 SDK 的示例代码：\",\"如果是在实际开发当中，是需要从前往后仔细的去阅读这一份文档的\",\"参照官方提供的SDK，改造一下，即可实现文件上传功能：\",\"import com.aliyun.oss.ClientException; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import com.aliyun.oss.OSSException; import com.aliyun.oss.model.PutObjectRequest; import com.aliyun.oss.model.PutObjectResult; import java.io.FileInputStream; import java.io.InputStream; public class AliOssTest { public static void main(String[] args) throws Exception { // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。 String endpoint = \\\"oss-cn-shanghai.aliyuncs.com\\\"; // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。 String accessKeyId = \\\"LTAI5t9MZK8iq5T2Av5GLDxX\\\"; String accessKeySecret = \\\"C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc\\\"; // 填写Bucket名称，例如examplebucket。 String bucketName = \\\"web-framework01\\\"; // 填写Object完整路径，完整路径中不能包含Bucket名称，例如exampledir/exampleobject.txt。 String objectName = \\\"1.jpg\\\"; // 填写本地文件的完整路径，例如D:\\\\\\\\localpath\\\\\\\\examplefile.txt。 // 如果未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件流。 String filePath= \\\"C:\\\\\\\\Users\\\\\\\\Administrator\\\\\\\\Pictures\\\\\\\\1.jpg\\\"; // 创建OSSClient实例。 OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); try { InputStream inputStream = new FileInputStream(filePath); // 创建PutObjectRequest对象。 PutObjectRequest putObjectRequest = new PutObjectRequest(bucketName, objectName, inputStream); // 设置该属性可以返回response。如果不设置，则返回的response为空。 putObjectRequest.setProcess(\\\"true\\\"); // 创建PutObject请求。 PutObjectResult result = ossClient.putObject(putObjectRequest); // 如果上传成功，则返回200。 System.out.println(result.getResponse().getStatusCode()); } catch (OSSException oe) { System.out.println(\\\"Caught an OSSException, which means your request made it to OSS, \\\" + \\\"but was rejected with an error response for some reason.\\\"); System.out.println(\\\"Error Message:\\\" + oe.getErrorMessage()); System.out.println(\\\"Error Code:\\\" + oe.getErrorCode()); System.out.println(\\\"Request ID:\\\" + oe.getRequestId()); System.out.println(\\\"Host ID:\\\" + oe.getHostId()); } catch (ClientException ce) { System.out.println(\\\"Caught an ClientException, which means the client encountered \\\" + \\\"a serious internal problem while trying to communicate with OSS, \\\" + \\\"such as not being able to access the network.\\\"); System.out.println(\\\"Error Message:\\\" + ce.getMessage()); } finally { if (ossClient != null) { ossClient.shutdown(); } } } } \",\"在以上代码中，需要替换的内容为：\",\"accessKeyId：阿里云账号AccessKey\",\"accessKeySecret：阿里云账号AccessKey对应的秘钥\",\"bucketName：Bucket名称\",\"objectName：对象名称，在Bucket中存储的对象的名称\",\"filePath：文件路径\",\"AccessKey ：\",\"运行以上程序后，会把本地的文件上传到阿里云OSS服务器上：\"]},{\"header\":\"2.3.3 集成\",\"slug\":\"_2-3-3-集成\",\"contents\":[\"在新增员工的时候，上传员工的图像，而之所以需要上传员工的图像，是因为将来我们需要在系统页面当中访问并展示员工的图像。而要想完成这个操作，需要做两件事：\",\"需要上传员工的图像，并把图像保存起来（存储到阿里云OSS）\",\"访问员工图像（通过图像在阿里云OSS的存储地址访问图像） \",\"OSS中的每一个文件都会分配一个访问的url，通过这个url就可以访问到存储在阿里云上的图片。所以需要把url返回给前端，这样前端就可以通过url获取到图像。\",\"参照接口文档来开发文件上传功能：\",\"基本信息\",\"请求路径：/upload 请求方式：POST 接口描述：上传图片接口 \",\"请求参数\",\"参数格式：multipart/form-data\",\"参数说明：\",\"参数名称\",\"参数类型\",\"是否必须\",\"示例\",\"备注\",\"image\",\"file\",\"是\",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"code\",\"number\",\"必须\",\"响应码，1 代表成功，0 代表失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object\",\"非必须\",\"返回的数据，上传图片的访问路径\",\"响应数据样例：\",\"{ \\\"code\\\": 1, \\\"msg\\\": \\\"success\\\", \\\"data\\\": \\\"https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-0400.jpg\\\" } \",\"引入阿里云OSS上传文件工具类（由官方的示例代码改造而来）\",\"import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; import java.util.UUID; @Component public class AliOSSUtils { private String endpoint = \\\"https://oss-cn-shanghai.aliyuncs.com\\\"; private String accessKeyId = \\\"LTAI5t9MZK8iq5T2Av5GLDxX\\\"; private String accessKeySecret = \\\"C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc\\\"; private String bucketName = \\\"web-framework01\\\"; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\\\".\\\")); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ossClient.putObject(bucketName, fileName, inputStream); //文件访问路径 String url = endpoint.split(\\\"//\\\")[0] + \\\"//\\\" + bucketName + \\\".\\\" + endpoint.split(\\\"//\\\")[1] + \\\"/\\\" + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } \",\"修改UploadController代码：\",\"import com.itheima.pojo.Result; import com.itheima.utils.AliOSSUtils; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; @Slf4j @RestController public class UploadController { @Autowired private AliOSSUtils aliOSSUtils; @PostMapping(\\\"/upload\\\") public Result upload(MultipartFile image) throws IOException { //调用阿里云OSS工具类，将上传上来的文件存入阿里云 String url = aliOSSUtils.upload(image); //将图片上传完成后的url返回，用于浏览器回显展示 return Result.success(url); } } \",\"使用postman测试：\"]},{\"header\":\"3. 修改员工\",\"slug\":\"_3-修改员工\",\"contents\":[\"在进行修改员工信息的时候，首先要根据员工的ID查询员工的信息用于页面回显展示，然后用户修改员工数据之后，点击保存按钮，就可以将修改的数据提交到服务端，保存到数据库。\",\"具体操作为：\",\"根据ID查询员工信息\",\"保存修改的员工信息\"]},{\"header\":\"3.1 查询回显\",\"slug\":\"_3-1-查询回显\",\"contents\":[]},{\"header\":\"3.1.1 接口文档\",\"slug\":\"_3-1-1-接口文档\",\"contents\":[\"根据ID查询员工数据\",\"基本信息\",\"请求路径：/emps/{id} 请求方式：GET 接口描述：该接口用于根据主键ID查询员工的信息 \",\"请求参数\",\"参数格式：路径参数\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"id\",\"number\",\"必须\",\"员工ID\",\"请求参数样例：\",\"/emps/1 \",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"默认值\",\"备注\",\"code\",\"number\",\"必须\",\"响应码, 1 成功 , 0 失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object\",\"必须\",\"返回的数据\",\"|- id\",\"number\",\"非必须\",\"id\",\"|- username\",\"string\",\"非必须\",\"用户名\",\"|- name\",\"string\",\"非必须\",\"姓名\",\"|- password\",\"string\",\"非必须\",\"密码\",\"|- entrydate\",\"string\",\"非必须\",\"入职日期\",\"|- gender\",\"number\",\"非必须\",\"性别 , 1 男 ; 2 女\",\"|- image\",\"string\",\"非必须\",\"图像\",\"|- job\",\"number\",\"非必须\",\"职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师\",\"|- deptId\",\"number\",\"非必须\",\"部门id\",\"|- createTime\",\"string\",\"非必须\",\"创建时间\",\"|- updateTime\",\"string\",\"非必须\",\"更新时间\",\"响应数据样例：\",\"{ \\\"code\\\": 1, \\\"msg\\\": \\\"success\\\", \\\"data\\\": { \\\"id\\\": 2, \\\"username\\\": \\\"zhangwuji\\\", \\\"password\\\": \\\"123456\\\", \\\"name\\\": \\\"张无忌\\\", \\\"gender\\\": 1, \\\"image\\\": \\\"https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-02-00-27-53B.jpg\\\", \\\"job\\\": 2, \\\"entrydate\\\": \\\"2015-01-01\\\", \\\"deptId\\\": 2, \\\"createTime\\\": \\\"2022-09-01T23:06:30\\\", \\\"updateTime\\\": \\\"2022-09-02T00:29:04\\\" } } \"]},{\"header\":\"3.1.2 实现思路\",\"slug\":\"_3-1-2-实现思路\",\"contents\":[]},{\"header\":\"3.1.3 代码实现\",\"slug\":\"_3-1-3-代码实现\",\"contents\":[\"EmpMapper\",\"@Mapper public interface EmpMapper { //根据ID查询员工信息 @Select(\\\"select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time \\\" + \\\"from emp \\\" + \\\"where id = #{id}\\\") public Emp findById(Integer id); //省略... } \",\"EmpService\",\"public interface EmpService { /** * 根据ID查询员工 * @param id * @return */ public Emp getById(Integer id); //省略... } \",\"EmpServiceImpl\",\"@Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public Emp getById(Integer id) { return empMapper.findById(id); } //省略... } \",\"EmpController\",\"@Slf4j @RestController @RequestMapping(\\\"/emps\\\") public class EmpController { @Autowired private EmpService empService; //根据id查询 @GetMapping(\\\"/{id}\\\") public Result getById(@PathVariable Integer id){ Emp emp = empService.getById(id); return Result.success(emp); } //省略... } \"]},{\"header\":\"3.1.4 postman测试\",\"slug\":\"_3-1-4-postman测试\",\"contents\":[]},{\"header\":\"3.2 修改员工\",\"slug\":\"_3-2-修改员工\",\"contents\":[\"当用户修改完数据之后，点击保存按钮，就需要将数据提交到服务端，然后服务端需要将修改后的数据更新到数据库中。\"]},{\"header\":\"3.2.1 接口文档\",\"slug\":\"_3-2-1-接口文档\",\"contents\":[\"基本信息\",\"请求路径：/emps 请求方式：PUT 接口描述：该接口用于修改员工的数据信息 \",\"请求参数\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"备注\",\"id\",\"number\",\"必须\",\"id\",\"username\",\"string\",\"必须\",\"用户名\",\"name\",\"string\",\"必须\",\"姓名\",\"gender\",\"number\",\"必须\",\"性别, 说明: 1 男, 2 女\",\"image\",\"string\",\"非必须\",\"图像\",\"deptId\",\"number\",\"非必须\",\"部门id\",\"entrydate\",\"string\",\"非必须\",\"入职日期\",\"job\",\"number\",\"非必须\",\"职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师\",\"请求数据样例：\",\"{ \\\"id\\\": 1, \\\"image\\\": \\\"https://web-framework.oss-cn-hangzhou.aliyuncs.com/2022-09-03-07-37-38222.jpg\\\", \\\"username\\\": \\\"linpingzhi\\\", \\\"name\\\": \\\"林平之\\\", \\\"gender\\\": 1, \\\"job\\\": 1, \\\"entrydate\\\": \\\"2022-09-18\\\", \\\"deptId\\\": 1 } \",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"参数名\",\"类型\",\"是否必须\",\"备注\",\"code\",\"number\",\"必须\",\"响应码，1 代表成功，0 代表失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"object\",\"非必须\",\"返回的数据\",\"响应数据样例：\",\"{ \\\"code\\\":1, \\\"msg\\\":\\\"success\\\", \\\"data\\\":null } \"]},{\"header\":\"3.2.2 实现思路\",\"slug\":\"_3-2-2-实现思路\",\"contents\":[]},{\"header\":\"3.2.3 代码实现\",\"slug\":\"_3-2-3-代码实现\",\"contents\":[\"EmpMapper\",\"@Mapper public interface EmpMapper { //修改员工信息 public void update(Emp emp); //省略... } \",\"EmpMapper.xml\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <!DOCTYPE mapper PUBLIC \\\"-//mybatis.org//DTD Mapper 3.0//EN\\\" \\\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\\\"> <mapper namespace=\\\"com.itheima.mapper.EmpMapper\\\"> <!--更新员工信息--> <update id=\\\"update\\\"> update emp <set> <if test=\\\"username != null and username != ''\\\"> username = #{username}, </if> <if test=\\\"password != null and password != ''\\\"> password = #{password}, </if> <if test=\\\"name != null and name != ''\\\"> name = #{name}, </if> <if test=\\\"gender != null\\\"> gender = #{gender}, </if> <if test=\\\"image != null and image != ''\\\"> image = #{image}, </if> <if test=\\\"job != null\\\"> job = #{job}, </if> <if test=\\\"entrydate != null\\\"> entrydate = #{entrydate}, </if> <if test=\\\"deptId != null\\\"> dept_id = #{deptId}, </if> <if test=\\\"updateTime != null\\\"> update_time = #{updateTime} </if> </set> where id = #{id} </update> <!-- 省略... --> </mapper> \",\"EmpService\",\"public interface EmpService { /** * 更新员工 * @param emp */ public void update(Emp emp); //省略... } \",\"EmpServiceImpl\",\"@Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public void update(Emp emp) { emp.setUpdateTime(LocalDateTime.now()); //更新修改时间为当前时间 empMapper.update(emp); } //省略... } \",\"EmpController\",\"@Slf4j @RestController @RequestMapping(\\\"/emps\\\") public class EmpController { @Autowired private EmpService empService; //修改员工 @PutMapping public Result update(@RequestBody Emp emp){ empService.update(emp); return Result.success(); } //省略... } \"]},{\"header\":\"3.2.4 postman测试\",\"slug\":\"_3-2-4-postman测试\",\"contents\":[]},{\"header\":\"3.2.5 前后端联调测试\",\"slug\":\"_3-2-5-前后端联调测试\",\"contents\":[]},{\"header\":\"4. 配置文件\",\"slug\":\"_4-配置文件\",\"contents\":[\"当前案例中存在的问题以及如何优化解决\"]},{\"header\":\"4.1 参数配置化\",\"slug\":\"_4-1-参数配置化\",\"contents\":[\"之前编写的程序中进行文件上传时，需要调用 AliOSSUtils 工具类，将文件上传到阿里云OSS对象存储服务当中。而在调用工具类进行文件上传时，需要一些参数：\",\"endpoint //阿里云OSS域名\",\"accessKeyID //用户身份ID\",\"accessKeySecret //用户密钥\",\"bucketName //存储空间的名字\",\"关于以上的这些阿里云相关配置信息，我们是直接写死在java代码中了(硬编码)，如果我们在做项目时每涉及到一个第三方技术服务，就将其参数硬编码，那么在Java程序中会存在两个问题：\",\"如果这些参数发生变化了，就必须在源程序代码中改动这些参数，然后需要重新进行代码的编译，将Java代码编译成class字节码文件再重新运行程序。（比较繁琐）\",\"如果开发的是一个真实的企业级项目， Java类可能会有很多，如果将这些参数分散的定义在各个Java类当中，如果要修改一个参数值，就需要在众多的Java代码当中来定位到对应的位置，再来修改参数，修改完毕之后再重新编译再运行。（参数配置过于分散， 不方便集中的管理和维护）\",\"为了解决以上分析的问题，可以将参数配置在配置文件中。\",\"#自定义的阿里云OSS配置信息 aliyun.oss.endpoint=https://oss-cn-hangzhou.aliyuncs.com aliyun.oss.accessKeyId=LTAI4GCH1vX6DKqJWxd6nEuW aliyun.oss.accessKeySecret=yBshYweHOpqDuhCArrVHwIiBKpyqSL aliyun.oss.bucketName=web-tlias \",\"在将阿里云OSS配置参数交给properties配置文件来管理之后，AliOSSUtils工具类\",\"@Component public class AliOSSUtils { /*以下4个参数没有指定值（默认值：null）*/ private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; //省略其他代码... } \",\"而此时如果直接调用AliOSSUtils类当中的upload方法进行文件上传时，这4项参数全部为null，原因是因为并没有给它赋值。\",\"此时我们是不是需要将配置文件当中所配置的属性值读取出来，并分别赋值给AliOSSUtils工具类当中的各个属性呢？那应该怎么做呢？\",\"因为application.properties是springboot项目默认的配置文件，所以springboot程序在启动时会默认读取application.properties配置文件，而我们可以使用一个现成的注解：@Value，获取配置文件中的数据。\",\"@Value 注解通常用于外部配置的属性注入，具体用法为： @Value(\\\"${配置文件中的key}\\\")\",\"@Component public class AliOSSUtils { @Value(\\\"${aliyun.oss.endpoint}\\\") private String endpoint; @Value(\\\"${aliyun.oss.accessKeyId}\\\") private String accessKeyId; @Value(\\\"${aliyun.oss.accessKeySecret}\\\") private String accessKeySecret; @Value(\\\"${aliyun.oss.bucketName}\\\") private String bucketName; //省略其他代码... } \",\"使用postman测试：\"]},{\"header\":\"4.2 yml配置文件\",\"slug\":\"_4-2-yml配置文件\",\"contents\":[\"在springboot项目中是支持多种配置方式的，除了支持properties配置文件以外，还支持另外一种类型的配置文件\",\"application.properties\",\"server.port=8080 server.address=127.0.0.1 \",\"application.yml\",\"server: port: 8080 address: 127.0.0.1 \",\"application.yaml\",\"server: port: 8080 address: 127.0.0.1 \",\"yml 格式的配置文件，后缀名有两种：\",\"yml （推荐）\",\"yaml\",\"常见配置文件格式对比：\",\"yml 格式的数据特点\",\"容易阅读\",\"容易与脚本语言交互\",\"以数据为核心，重数据轻格式\",\"yml配置文件的基本语法：\",\"大小写敏感\",\"数值前边必须有空格，作为分隔符\",\"使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）\",\"缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\",\"#表示注释，从这个字符一直到行尾，都会被解析器忽略\",\"yml文件中常见的两类数据格式\",\"定义对象或Map集合\",\"定义数组、list或set集合\",\"对象/ Map集合\",\"user: name: zhangsan age: 18 password: 123456 \",\"数组 / List / Set集合\",\"hobby: - java - game - sport \",\"将使用的配置文件，变更为application.yml配置方式：\",\"修改application.properties名字为：_application.properties（名字随便更换，只要加载不到即可）\",\"创建新的配置文件： application.yml\",\"原有application.properties文件：\",\"新建的application.yml文件：\",\"spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/tlias username: root password: 1234 servlet: multipart: max-file-size: 10MB max-request-size: 100MB mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl map-underscore-to-camel-case: true aliyun: oss: endpoint: https://oss-cn-hangzhou.aliyuncs.com accessKeyId: LTAI4GCH1vX6DKqJWxd6nEuW accessKeySecret: yBshYweHOpqDuhCArrVHwIiBKpyqSL bucketName: web-397 \"]},{\"header\":\"4.3 @ConfigurationProperties\",\"slug\":\"_4-3-configurationproperties\",\"contents\":[\"在application.properties或者application.yml中配置了阿里云OSS的四项参数之后，如果java程序中需要这四项参数数据，直接通过@Value注解来进行注入。如果需要注入的属性较多(例：需要20多个参数数据)，写起来就会比较繁琐。\",\"在Spring中给我们提供了一种简化方式，可以直接将配置文件中配置项的值自动的注入到对象的属性中。\",\"Spring提供的简化方式：\",\"创建一个实现类，且实体类中的属性名和配置文件当中key的名字必须要一致\",\"比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter / setter方法\",\"将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象\",\"在实体类上添加@ConfigurationProperties注解，并通过prefix属性来指定配置参数项的前缀\",\"实体类：AliOSSProperties\",\"import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; /*阿里云OSS相关配置*/ @Data @Component @ConfigurationProperties(prefix = \\\"aliyun.oss\\\") public class AliOSSProperties { //区域 private String endpoint; //身份ID private String accessKeyId ; //身份密钥 private String accessKeySecret ; //存储空间 private String bucketName; } \",\"AliOSSUtils工具类：\",\"import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; import java.util.UUID; @Component //当前类对象由Spring创建和管理 public class AliOSSUtils { //注入配置参数实体类对象 @Autowired private AliOSSProperties aliOSSProperties; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\\\".\\\")); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //文件访问路径 String url =aliOSSProperties.getEndpoint().split(\\\"//\\\")[0] + \\\"//\\\" + aliOSSProperties.getBucketName() + \\\".\\\" + aliOSSProperties.getEndpoint().split(\\\"//\\\")[1] + \\\"/\\\" + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } \",\"添加注解后，会发现idea窗口上面出现一个红色警告：\",\"这个警告提示是提示还需要引入一个依赖：\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-configuration-processor</artifactId> </dependency> \",\"在pom.xml文件当中配置了这项依赖之后，重新启动服务，就会看到在properties或者是yml配置文件当中，就会提示阿里云 OSS 相关的配置项。所以这项依赖它的作用就是会自动的识别被@ConfigurationProperties注解标识的bean对象。\",\"刚才的红色警告，已经变成了一个灰色的提示，提示我们需要重新运行springboot服务\",\"区分@ConfigurationProperties注解 @Value注解\",\"相同点：都是用来注入外部配置的属性的。\",\"不同点：\",\"@Value注解只能一个一个的进行外部属性的注入。\",\"@ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中。\"]}]},\"/BackEnd/SpringBoot/springboot05.html\":{\"title\":\"SpringBoot案例-登录认证\",\"contents\":[{\"header\":\"1. 登录功能\",\"slug\":\"_1-登录功能\",\"contents\":[]},{\"header\":\"1.1 需求\",\"slug\":\"_1-1-需求\",\"contents\":[\"输入用户名及密码，点击 \\\"登录\\\" 按钮就要请求服务器，服务端判断用户输入的用户名或者密码是否正确。如果正确，则返回成功结果，前端跳转至系统首页面。\"]},{\"header\":\"1.2 接口文档\",\"slug\":\"_1-2-接口文档\",\"contents\":[\"参照接口文档来开发登录功能\",\"基本信息\",\"请求路径：/login 请求方式：POST 接口描述：该接口用于员工登录Tlias智能学习辅助系统，登录完毕后，系统下发JWT令牌。 \",\"请求参数\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"备注\",\"username\",\"string\",\"必须\",\"用户名\",\"password\",\"string\",\"必须\",\"密码\",\"请求数据样例：\",\"{ \\\"username\\\": \\\"jinyong\\\", \\\"password\\\": \\\"123456\\\" } \",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"默认值\",\"备注\",\"其他信息\",\"code\",\"number\",\"必须\",\"响应码, 1 成功 ; 0 失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"string\",\"必须\",\"返回的数据 , jwt令牌\",\"响应数据样例：\",\"{ \\\"code\\\": 1, \\\"msg\\\": \\\"success\\\", \\\"data\\\": \\\"eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo\\\" } \"]},{\"header\":\"1.3 思路分析\",\"slug\":\"_1-3-思路分析\",\"contents\":[\"登录服务端的核心逻辑就是： 接收前端请求传递的用户名和密码，然后再根据用户名和密码查询用户信息 如果用户信息存在，则说明用户输入的用户名和密码正确。 如果查询到的用户不存在，则说明用户输入的用户名和密码错误。\"]},{\"header\":\"1.4 功能开发\",\"slug\":\"_1-4-功能开发\",\"contents\":[\"LoginController:\",\"@RestController public class LoginController { @Autowired private EmpService empService; @PostMapping(\\\"/login\\\") public Result login(@RequestBody Emp emp){ Emp e = empService.login(emp); return e != null ? Result.success():Result.error(\\\"用户名或密码错误\\\"); } } \",\"EmpService:\",\"public interface EmpService { /** * 用户登录 * @param emp * @return */ public Emp login(Emp emp); //省略其他代码... } \",\"EmpServiceImpl:\",\"@Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override public Emp login(Emp emp) { //调用dao层功能：登录 Emp loginEmp = empMapper.getByUsernameAndPassword(emp); //返回查询结果给Controller return loginEmp; } //省略其他代码... } \",\"EmpMapper:\",\"@Mapper public interface EmpMapper { @Select(\\\"select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time \\\" + \\\"from emp \\\" + \\\"where username=#{username} and password =#{password}\\\") public Emp getByUsernameAndPassword(Emp emp); //省略其他代码... } \"]},{\"header\":\"1.5 测试\",\"slug\":\"_1-5-测试\",\"contents\":[\"发起POST请求，访问：http://localhost:8080/login\",\"先退出系统，进入到登录页面：\",\"在登录页面输入账户密码：\",\"登录成功之后进入到后台管理系统页面：\"]},{\"header\":\"2. 登录校验\",\"slug\":\"_2-登录校验\",\"contents\":[]},{\"header\":\"2.1 问题分析\",\"slug\":\"_2-1-问题分析\",\"contents\":[\"在浏览器中新的页面上输入地址：http://localhost:9528/#/system/dept，没有登录仍然可以进入到后端管理系统页面。\",\"什么是登录校验？\",\"指的是服务器端接收到浏览器发送过来的请求之后，首先对请求进行校验\",\"先要校验用户登录了没有，如果用户已经登录，直接执行对应的业务操作就可以了\",\"如果用户没有登录，此时就不允许他执行相关的业务操作，直接给前端响应一个错误的结果，最终跳转到登录页面，要求他登录成功之后，再来访问对应的数据。\",\"HTTP协议是无状态协议\",\"什么是无状态的协议？\",\"指的是每一次请求都是独立的，下一次请求并不会携带上一次请求的数据。\",\"而浏览器与服务器之间进行交互，基于HTTP协议也就意味着现在通过浏览器来访问了登陆这个接口，实现了登陆的操作，接下来在执行其他业务操作时，服务器也并不知道这个员工到底登陆了没有。\",\"HTTP协议是无状态的，两次请求之间是独立的，所以无法判断这个员工到底登陆了没有。\",\"实现登录校验操作，分为两部分：\",\"在员工登录成功后，需要将用户登录成功的信息存起来，记录用户已经登录成功的标记。\",\"在浏览器发起请求时，需要在服务端进行统一拦截，拦截后进行登录校验。\",\"涉及到的web开发中的 两个技术\",\"会话技术\",\"统一拦截技术\",\"而统一拦截技术现实方案也有两种：\",\"Servlet 规范中的 Filter 过滤器\",\"Spring 提供的 interceptor 拦截器\"]},{\"header\":\"2.2 会话技术\",\"slug\":\"_2-2-会话技术\",\"contents\":[\"什么是会话？\",\"在web开发当中，会话指的就是浏览器与服务器之间的一次连接，就称为一次会话。\",\"在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，会话就结束了。在一次会话当中，是可以包含多次请求和响应的。\",\"比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）\",\"第1次：访问的是登录的接口，完成登录操作\",\"第2次：访问的是部门管理接口，查询所有部门数据\",\"第3次：访问的是员工管理接口，查询员工数据\",\"只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。\",\"会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。\",\"服务器会接收很多的请求，但是服务器是需要识别出这些请求是不是同一个浏览器发出来的。比如：1和2这两个请求是不是同一个浏览器发出来的，3和5这两个请求不是同一个浏览器发出来的。如果是同一个浏览器发出来的，就说明是同一个会话。如果是不同的浏览器发出来的，就说明是不同的会话。而识别多次请求是否来自于同一浏览器的过程，我们就称为会话跟踪。\",\"会话跟踪技术有两种：\",\"Cookie（客户端会话跟踪技术）\",\"数据存储在客户端浏览器当中\",\"Session（服务端会话跟踪技术）\",\"数据存储在储在服务端\",\"令牌技术\"]},{\"header\":\"2.2.1 会话跟踪方案\",\"slug\":\"_2-2-1-会话跟踪方案\",\"contents\":[\"Cookie:\",\"cookie 是客户端会话跟踪技术，它是存储在客户端浏览器的\",\"比如第一次请求了登录接口，登录接口执行完成之后，就可以设置一个cookie，在 cookie 当中可以存储用户相关的一些数据信息。比如在 cookie 当中存储当前登录用户的用户名，用户的ID。\",\"服务器端在给客户端在响应数据的时候，会自动的将 cookie 响应给浏览器，浏览器接收到响应回来的 cookie 之后，会自动的将 cookie 的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的 cookie 自动地携带到服务端。\",\"接下来在服务端我们就可以获取到 cookie 的值。可以去判断一下这个 cookie 的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在 cookie 的值，就说明客户端之前已经登录完成了。这样就可以基于 cookie 在同一次会话的不同请求之间来共享数据。\",\"3 个自动：\",\"服务器会 自动 的将 cookie 响应给浏览器。\",\"浏览器接收到响应回来的数据之后，会 自动 的将 cookie 存储在浏览器本地。\",\"在后续的请求当中，浏览器会 自动 的将 cookie 携带到服务器端。\",\"为什么这一切都是自动化进行的？\",\"因为 cookie 它是 HTP 协议当中所支持的技术，而各大浏览器厂商都支持了这一标准。\",\"HTTP 协议官方提供了一个响应头和请求头：\",\"响应头 Set-Cookie ：设置Cookie数据的\",\"请求头 Cookie：携带Cookie数据的\",\"代码测试:\",\"@Slf4j @RestController public class SessionController { //设置Cookie @GetMapping(\\\"/c1\\\") public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\\\"login_username\\\",\\\"itheima\\\")); //设置Cookie/响应Cookie return Result.success(); } //获取Cookie @GetMapping(\\\"/c2\\\") public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for (Cookie cookie : cookies) { if(cookie.getName().equals(\\\"login_username\\\")){ System.out.println(\\\"login_username: \\\"+cookie.getValue()); //输出name为login_username的cookie } } return Result.success(); } } \",\"访问c1接口，设置Cookie，http://localhost:8080/c1\",\"设置的cookie，通过响应头Set-Cookie响应给浏览器，并且浏览器会将Cookie，存储在浏览器端。\",\"访问c2接口 http://localhost:8080/c2，此时浏览器会自动的将Cookie携带到服务端，是通过请求头Cookie，携带的。\",\"优缺点:\",\"优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带，都是浏览器自动进行的）\",\"缺点： \",\"移动端APP(Android、IOS)中无法使用Cookie\",\"不安全，用户可以自己禁用Cookie\",\"Cookie不能跨域\",\"跨域介绍： \",\"现在的项目，大部分都是前后端分离的，前后端最终也会分开部署，前端部署在服务器 192.168.150.200 上，端口 80，后端部署在 192.168.150.100上，端口 8080\",\"打开浏览器直接访问前端工程，访问url：http://192.168.150.200/login.html\",\"在该页面发起请求到服务端，而服务端所在地址不再是localhost，而是服务器的IP地址192.168.150.100，假设访问接口地址为：http://192.168.150.100:8080/login\",\"那此时就存在跨域操作了，因为我们是在 http://192.168.150.200/login.html 这个页面上访问了http://192.168.150.100:8080/login 接口\",\"此时如果服务器设置了一个Cookie，这个Cookie是不能使用的，因为Cookie无法跨域\",\"区分跨域的维度：\",\"协议\",\"IP/协议\",\"端口\",\"只要上述的三个维度有任何一个维度不同，那就是跨域操作\",\"举例：\",\"​[http://192.168.150.200/login.html] ----------> [https://192.168.150.200/login] [协议不同，跨域]\",\"[http://192.168.150.200/login.html] ----------> [http://192.168.150.100/login] [IP不同，跨域]\",\"​[http://192.168.150.200/login.html] ----------> [http://192.168.150.200:8080/login] [端口不同，跨域]\",\"[http://192.168.150.200/login.html] ----------> [http://192.168.150.200/login] [不跨域]\",\"Session:\",\"它是服务器端会话跟踪技术，所以它是存储在服务器端的。而 Session 的底层其实就是基 Cookie 来实现的。\",\"获取Session\",\"基于 Session 来进行会话跟踪，浏览器在第一次请求服务器的时候，直接在服务器当中来获取到会话对象Session。如果是第一次请求Session ，会话对象是不存在的，这个时候服务器会自动的创建一个会话对象Session 。而每一个会话对象Session ，它都有一个ID（示意图中Session后面括号中的1，就表示ID），称之为 Session 的ID。\",\"响应Cookie (JSESSIONID)\",\"接下来，服务器端在给浏览器响应数据的时候，它会将 Session 的 ID 通过 Cookie 响应给浏览器。其实在响应头当中增加了一个 Set-Cookie 响应头。这个 Set-Cookie 响应头对应的值是不是cookie？ cookie 的名字是固定的 JSESSIONID 代表的服务器端会话对象 Session 的 ID。浏览器会自动识别这个响应头，然后自动将Cookie存储在浏览器本地。\",\"查找Session\",\"在后续的每一次请求当中，都会将 Cookie 的数据获取出来，并且携带到服务端。服务器拿到JSESSIONID这个 Cookie 的值，也就是 Session 的ID。拿到 ID 之后，就会从众多的 Session 当中来找到当前请求对应的会话对象Session。\",\"代码测试:\",\"@Slf4j @RestController public class SessionController { @GetMapping(\\\"/s1\\\") public Result session1(HttpSession session){ log.info(\\\"HttpSession-s1: {}\\\", session.hashCode()); session.setAttribute(\\\"loginUser\\\", \\\"tom\\\"); //往session中存储数据 return Result.success(); } @GetMapping(\\\"/s2\\\") public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); log.info(\\\"HttpSession-s2: {}\\\", session.hashCode()); Object loginUser = session.getAttribute(\\\"loginUser\\\"); //从session中获取数据 log.info(\\\"loginUser: {}\\\", loginUser); return Result.success(loginUser); } } \",\"A. 访问 s1 接口，http://localhost:8080/s1\",\"请求完成之后，在响应头中，就会看到有一个Set-Cookie的响应头，里面响应回来了一个Cookie，就是JSESSIONID，这个就是服务端会话对象 Session 的ID。\",\"B. 访问 s2 接口，http://localhost:8080/s2\",\"在后续的每次请求时，都会将Cookie的值，携带到服务端，服务端接收到Cookie之后，会自动的根据JSESSIONID的值，找到对应的会话对象Session。\",\"那经过这两步测试，在控制台中输出如下日志：\",\"两次请求，获取到的Session会话对象的hashcode是一样的，就说明是同一个会话对象。 并且，第一次请求时，往Session会话对象中存储的值，第二次请求时，也获取到了。 这样就可以通过Session会话对象，在同一个会话的多次请求之间来进行数据共享了。\",\"优缺点:\",\"优点：Session是存储在服务端的，安全\",\"缺点： \",\"服务器集群环境下无法直接使用Session\",\"移动端APP(Android、IOS)中无法使用Cookie\",\"用户可以自己禁用Cookie\",\"Cookie不能跨域\",\"PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案，也就失效了。 服务器集群环境为何无法使用Session？ \",\"首先，现在所开发的项目，一般都不会只部署在一台服务器上，因为一台服务器会存在一个很大的问题，就是单点故障。所谓单点故障，指的就是一旦这台服务器挂了，整个应用都没法访问了。\",\"​ \",\"所以在现在的企业项目开发当中，最终部署的时候都是以集群的形式来进行部署，也就是同一个项目它会部署多份。比如这个项目现在就部署了 3 份。\",\"而用户在访问的时候，到底访问这三台其中的哪一台？其实用户在访问的时候，他会访问一台前置的服务器，我们叫负载均衡服务器，它的作用就是将前端发起的请求均匀的分发给后面的这三台服务器。\",\"此时通过 session 来进行会话跟踪，可能就会存在这样一个问题。用户打开浏览器要进行登录操作，此时会发起登录请求。登录请求到达负载均衡服务器，将这个请求转给了第一台 Tomcat 服务器。\",\"Tomcat 服务器接收到请求之后，要获取到会话对象session。获取到会话对象 session 之后，要给浏览器响应数据，最终在给浏览器响应数据的时候，就会携带这么一个 cookie 的名字，就是 JSESSIONID ，下一次再请求的时候，是不是又会将 Cookie 携带到服务端？\",\"好。此时假如又执行了一次查询操作，要查询部门的数据。这次请求到达负载均衡服务器之后，负载均衡服务器将这次请求转给了第二台 Tomcat 服务器，此时他就要到第二台 Tomcat 服务器当中。根据JSESSIONID 也就是对应的 session 的 ID 值，要找对应的 session 会话对象。\",\"请问在第二台服务器当中有没有这个ID的会话对象 Session， 是没有的。此时是不是就出现问题了？我同一个浏览器发起了 2 次请求，结果获取到的不是同一个会话对象，这就是Session这种会话跟踪方案它的缺点，在服务器集群环境下无法直接使用Session。\",\"令牌技术：\",\"其实它就是一个用户身份的标识，本质就是一个字符串。\",\"通过令牌技术来跟踪会话，在请求登录接口的时候，如果登录成功，会生成一个令牌，令牌就是用户的合法身份凭证。在响应数据的时候，服务器直接将令牌响应给前端。\",\"在前端程序当中接收到令牌之后，就需要将这个令牌存储起来。这个存储可以存储在 cookie 当中，也可以存储在其他的存储空间(比如：localStorage)当中。\",\"在后续的每一次请求当中，都需要将令牌携带到服务端。携带到服务端之后，接下来我们就需要来校验令牌的有效性。如果令牌是有效的，就说明用户已经执行了登录操作，如果令牌是无效的，就说明用户之前并未执行登录操作。\",\"此时，如果是在同一次会话的多次请求之间，如果想共享数据，将共享的数据存储在令牌当中就可以了。\",\"优缺点:\",\"优点： \",\"支持PC端、移动端\",\"解决集群环境下的认证问题\",\"减轻服务器的存储压力（无需在服务器端存储）\",\"缺点：需要自己实现（包括令牌的生成、令牌的传递、令牌的校验）\",\"针对于这三种方案，现在企业开发当中使用的最多的就是第三种令牌技术进行会话跟踪。\"]},{\"header\":\"2.3 JWT令牌\",\"slug\":\"_2-3-jwt令牌\",\"contents\":[]},{\"header\":\"2.3.1 介绍\",\"slug\":\"_2-3-1-介绍\",\"contents\":[\"JWT全称：JSON Web Token （官网：[https://jwt.io/]）\",\"定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。\",\"简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。\",\"自包含：指的是jwt令牌，看似是一个随机的字符串，但是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。\",\"简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。\",\"JWT的组成\",\"JWT令牌由三个部分组成，三个部分之间使用英文的点来分割\",\"第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{\\\"alg\\\":\\\"HS256\\\",\\\"type\\\":\\\"JWT\\\"}\",\"第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{\\\"id\\\":\\\"1\\\",\\\"username\\\":\\\"Tom\\\"}\",\"第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，加入指定秘钥，通过指定签名算法计算而来。\",\"签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，所以整个jwt 令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败，所以它是非常安全可靠的。\",\"JWT是如何将原始的JSON格式数据，转变为字符串的呢？\",\"其实在生成JWT令牌时，会对JSON格式的数据进行一次编码：进行base64编码\",\"Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号\",\"需要注意的是Base64是编码方式，而不是加密方式。\",\"JWT令牌最典型的应用场景就是登录认证：\",\"在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。\",\"前端拿到jwt令牌之后，会将jwt令牌存储起来。在后续的每一次请求中都会将jwt令牌携带到服务端。\",\"服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。\",\"整个流程当中涉及到两步操作：\",\"在登录成功之后，要生成令牌。\",\"每一次请求当中，要接收令牌并对令牌进行校验。\"]},{\"header\":\"2.3.2 生成和校验\",\"slug\":\"_2-3-2-生成和校验\",\"contents\":[\"要想使用JWT令牌，需要先引入JWT的依赖：\",\"<!-- JWT依赖--> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt</artifactId> <version>0.9.1</version> </dependency> \",\"在引入完JWT依赖后，就可以调用工具包中提供的API来完成JWT令牌的生成和校验\",\"工具类：Jwts\",\"生成JWT代码实现：\",\"@Test public void genJwt(){ Map<String,Object> claims = new HashMap<>(); claims.put(\\\"id\\\",1); claims.put(\\\"username\\\",\\\"Tom\\\"); String jwt = Jwts.builder() .setClaims(claims) //自定义内容(载荷) .signWith(SignatureAlgorithm.HS256, \\\"itheima\\\") //签名算法 .setExpiration(new Date(System.currentTimeMillis() + 24*3600*1000)) //有效期 .compact(); System.out.println(jwt); } \",\"运行测试方法：\",\"eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ. fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk \",\"输出的结果就是生成的JWT令牌,，通过英文的点分割对三个部分进行分割 将生成的令牌复制一下，打开JWT的官网\",\"第一部分解析出来，看到JSON格式的原始数据，所使用的签名算法为HS256。\",\"第二个部分是自定义的数据，之前自定义的数据就是id，还有一个exp代表的是所设置的过期时间。\",\"由于前两个部分是base64编码，所以是可以直接解码出来。但最后一个部分并不是base64编码，是经过签名算法计算出来的，所以最后一个部分是不会解析的。\",\"校验JWT令牌(解析生成的令牌)：\",\"@Test public void parseJwt(){ Claims claims = Jwts.parser() .setSigningKey(\\\"itheima\\\")//指定签名密钥（必须保证和生成令牌时使用相同的签名密钥） .parseClaimsJws(\\\"eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjcyNzI5NzMwfQ.fHi0Ub8npbyt71UqLXDdLyipptLgxBUg_mSuGJtXtBk\\\") .getBody(); System.out.println(claims); } \",\"运行测试方法：\",\"{id=1, exp=1672729730} \",\"令牌解析后，可以看到id和过期时间，如果在解析的过程当中没有报错，就说明解析成功了。\",\"测试：把令牌header中的数字9变为8，运行测试方法后发现报错：\",\"原header： eyJhbGciOiJIUzI1NiJ9\",\"修改为： eyJhbGciOiJIUzI1NiJ8\",\"结论：篡改令牌中的任何一个字符，在对令牌进行解析时都会报错，所以JWT令牌是非常安全可靠的。\",\"继续测试：修改生成令牌的时指定的过期时间，修改为1分钟\",\"@Test public void genJwt(){ Map<String,Object> claims = new HashMap<>(); claims.put(“id”,1); claims.put(“username”,“Tom”); String jwt = Jwts.builder() .setClaims(claims) //自定义内容(载荷) .signWith(SignatureAlgorithm.HS256, “itheima”) //签名算法 .setExpiration(new Date(System.currentTimeMillis() + 60*1000)) //有效期60秒 .compact(); System.out.println(jwt); //输出结果：eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjczMDA5NzU0fQ.RcVIR65AkGiax-ID6FjW60eLFH3tPTKdoK7UtE4A1ro } @Test public void parseJwt(){ Claims claims = Jwts.parser() .setSigningKey(\\\"itheima\\\")//指定签名密钥 .parseClaimsJws(\\\"eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNjczMDA5NzU0fQ.RcVIR65AkGiax-ID6FjW60eLFH3tPTKdoK7UtE4A1ro\\\") .getBody(); System.out.println(claims); } \",\"等待1分钟之后运行测试方法发现也报错了，说明：JWT令牌过期后，令牌就失效了，解析的为非法令牌。\",\"注意\",\"JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。\",\"如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。\"]},{\"header\":\"2.3.3 登录下发令牌\",\"slug\":\"_2-3-3-登录下发令牌\",\"contents\":[\"注\",\"生成令牌 \",\"在登录成功之后来生成一个JWT令牌，并且把这个令牌直接返回给前端\",\"校验令牌 \",\"拦截前端请求，从请求中获取到令牌，对令牌进行解析校验\",\"JWT令牌怎么返回给前端呢？（主要看响应数据）：\",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"默认值\",\"备注\",\"其他信息\",\"code\",\"number\",\"必须\",\"响应码, 1 成功 ; 0 失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"string\",\"必须\",\"返回的数据 , jwt令牌\",\"响应数据样例：\",\"{ \\\"code\\\": 1, \\\"msg\\\": \\\"success\\\", \\\"data\\\": \\\"eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo\\\" } \",\"备注说明\",\"用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头header中携带到服务端，请求头的名称为 token ，值为登录时下发的JWT令牌。\",\"如果检测到用户未登录，则会返回如下固定错误信息：\",\"{ \\\"code\\\": 0, \\\"msg\\\": \\\"NOT_LOGIN\\\", \\\"data\\\": null } \",\"实现步骤：\",\"引入JWT工具类\",\"登录完成后，调用工具类生成JWT令牌并返回\",\"JWT工具类:\",\"public class JwtUtils { private static String signKey = \\\"itheima\\\";//签名密钥 private static Long expire = 43200000L; //有效时间 /** * 生成JWT令牌 * @param claims JWT第二部分负载 payload 中存储的内容 * @return */ public static String generateJwt(Map<String, Object> claims){ String jwt = Jwts.builder() .addClaims(claims)//自定义信息（有效载荷） .signWith(SignatureAlgorithm.HS256, signKey)//签名算法（头部） .setExpiration(new Date(System.currentTimeMillis() + expire))//过期时间 .compact(); return jwt; } /** * 解析JWT令牌 * @param jwt JWT令牌 * @return JWT第二部分负载 payload 中存储的内容 */ public static Claims parseJWT(String jwt){ Claims claims = Jwts.parser() .setSigningKey(signKey)//指定签名密钥 .parseClaimsJws(jwt)//指定令牌Token .getBody(); return claims; } } \",\"登录成功，生成JWT令牌并返回:\",\"@RestController @Slf4j public class LoginController { //依赖业务层对象 @Autowired private EmpService empService; @PostMapping(\\\"/login\\\") public Result login(@RequestBody Emp emp) { //调用业务层：登录功能 Emp loginEmp = empService.login(emp); //判断：登录用户是否存在 if(loginEmp !=null ){ //自定义信息 Map<String , Object> claims = new HashMap<>(); claims.put(\\\"id\\\", loginEmp.getId()); claims.put(\\\"username\\\",loginEmp.getUsername()); claims.put(\\\"name\\\",loginEmp.getName()); //使用JWT工具类，生成身份令牌 String token = JwtUtils.generateJwt(claims); return Result.success(token); } return Result.error(\\\"用户名或密码错误\\\"); } } \",\"重启服务，打开postman测试登录接口：\",\"打开浏览器完成前后端联调操作：利用开发者工具，抓取一下网络请求\",\"登录请求完成后，可以看到JWT令牌已经响应给了前端，此时前端就会将JWT令牌存储在浏览器本地。\",\"服务器响应的JWT令牌存储在本地浏览器哪里了呢？\",\"在当前案例中，JWT令牌存储在浏览器的本地存储空间local storage中了。 local storage是浏览器的本地存储，在移动端也是支持的。\",\"在发起一个查询部门数据的请求，此时可以看到在请求头中包含一个token(JWT令牌)，后续的每一次请求当中，都会将这个令牌携带到服务端。\"]},{\"header\":\"2.4 过滤器Filter\",\"slug\":\"_2-4-过滤器filter\",\"contents\":[\"服务端需要统一拦截所有的请求，从而判断是否携带的有合法的JWT令牌。 那怎么样来统一拦截到所有的请求校验令牌的有效性呢？这里会学习两种解决方案：\",\"Filter过滤器\",\"Interceptor拦截器\"]},{\"header\":\"2.4.1 快速入门\",\"slug\":\"_2-4-1-快速入门\",\"contents\":[\"什么是Filter？\",\"Filter表示过滤器，是 JavaWeb三大组件(Servlet、Filter、Listener)之一。\",\"过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能 \",\"使用了过滤器之后，要想访问web服务器上的资源，必须先经过滤器，过滤器处理完毕之后，才可以访问对应的资源。\",\"过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理、敏感字符处理等。\",\"掌握过滤器的基本使用操作：\",\"第1步，定义过滤器 ：1.定义一个类，实现 Filter 接口，并重写其所有方法。\",\"第2步，配置过滤器：Filter类上加 @WebFilter 注解，配置拦截资源的路径。引导类上加 @ServletComponentScan 开启Servlet组件支持。\",\"定义过滤器：\",\"//定义一个类，实现一个标准的Filter过滤器的接口 public class DemoFilter implements Filter { @Override //初始化方法, 只调用一次 public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\\\"init 初始化方法执行了\\\"); } @Override //拦截到请求之后调用, 调用多次 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\\\"Demo 拦截到了请求...放行前逻辑\\\"); //放行 chain.doFilter(request,response); } @Override //销毁方法, 只调用一次 public void destroy() { System.out.println(\\\"destroy 销毁方法执行了\\\"); } } \",\"init方法：过滤器的初始化方法。在web服务器启动的时候会自动的创建Filter过滤器对象，在创建过滤器对象的时候会自动调用init初始化方法，这个方法只会被调用一次。\",\"doFilter方法：这个方法是在每一次拦截到请求之后都会被调用，所以这个方法是会被调用多次的，每拦截到一次请求就会调用一次doFilter()方法。\",\"destroy方法： 是销毁的方法。当关闭服务器的时候，它会自动的调用销毁方法destroy，而这个销毁方法也只会被调用一次。\",\"Filter的配置非常简单，只需要在Filter类上添加一个注解：@WebFilter，并指定属性urlPatterns，通过这个属性指定过滤器要拦截哪些请求\",\"@WebFilter(urlPatterns = \\\"/*\\\") //配置过滤器要拦截的请求路径（ /* 表示拦截浏览器的所有请求 ） public class DemoFilter implements Filter { @Override //初始化方法, 只调用一次 public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\\\"init 初始化方法执行了\\\"); } @Override //拦截到请求之后调用, 调用多次 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\\\"Demo 拦截到了请求...放行前逻辑\\\"); //放行 chain.doFilter(request,response); } @Override //销毁方法, 只调用一次 public void destroy() { System.out.println(\\\"destroy 销毁方法执行了\\\"); } } \",\"在Filter类上面加了@WebFilter注解之后，还需要在启动类上面加上一个注解 @ServletComponentScan，通过这个@ServletComponentScan注解来开启SpringBoot项目对于Servlet组件的支持。\",\"@ServletComponentScan @SpringBootApplication public class TliasWebManagementApplication { public static void main(String[] args) { SpringApplication.run(TliasWebManagementApplication.class, args); } } \",\"重新启动服务，打开浏览器，执行部门管理的请求，可以看到控制台输出了过滤器中的内容：\",\"注意事项：\",\"​在过滤器Filter中，如果不执行放行操作，将无法访问后面的资源。 放行操作：chain.doFilter(request, response);\"]},{\"header\":\"2.4.2 Filter详解\",\"slug\":\"_2-4-2-filter详解\",\"contents\":[\"过滤器的执行流程\",\"过滤器的拦截路径配置\",\"过滤器链\",\"执行流程:\",\"拦截到了请求之后，如果希望继续访问后面的web资源，就要执行放行操作，放行就是调用 FilterChain对象当中的doFilter()方法，在调用doFilter()这个方法之前所编写的代码属于放行之前的逻辑。\",\"在放行后访问完 web 资源之后还会回到过滤器当中，回到过滤器之后如有需求还可以执行放行之后的逻辑，放行之后的逻辑写在doFilter()这行代码之后。\",\"@WebFilter(urlPatterns = \\\"/*\\\") public class DemoFilter implements Filter { @Override //初始化方法, 只调用一次 public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\\\"init 初始化方法执行了\\\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"DemoFilter 放行前逻辑.....\\\"); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\\\"DemoFilter 放行后逻辑.....\\\"); } @Override //销毁方法, 只调用一次 public void destroy() { System.out.println(\\\"destroy 销毁方法执行了\\\"); } } \",\"拦截路径:\",\"Filter可以根据需求，配置不同的拦截资源路径：\",\"拦截路径\",\"urlPatterns值\",\"含义\",\"拦截具体路径\",\"/login\",\"只有访问 /login 路径时，才会被拦截\",\"目录拦截\",\"/emps/*\",\"访问/emps下的所有资源，都会被拦截\",\"拦截所有\",\"/*\",\"访问所有资源，都会被拦截\",\"@WebFilter(urlPatterns = \\\"/login\\\") //拦截/login具体路径 public class DemoFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"DemoFilter 放行前逻辑.....\\\"); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\\\"DemoFilter 放行后逻辑.....\\\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void destroy() { Filter.super.destroy(); } } \",\"测试1：访问部门管理请求，发现过滤器没有拦截请求\",\"测试2：访问登录请求/login，发现过滤器拦截请求\",\"测试\\\"目录拦截\\\"：\",\"@WebFilter(urlPatterns = \\\"/depts/*\\\") //拦截所有以/depts开头，后面是什么无所谓 public class DemoFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"DemoFilter 放行前逻辑.....\\\"); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\\\"DemoFilter 放行后逻辑.....\\\"); } @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void destroy() { Filter.super.destroy(); } } \",\"测试1：访问部门管理请求，发现过滤器拦截了请求\",\"测试2：访问登录请求/login，发现过滤器没有拦截请求\",\"过滤器链:\",\"指的是在一个web应用程序当中，可以配置多个过滤器，多个过滤器就形成了一个过滤器链。\",\"验证步骤：\",\"在filter包下再来新建一个Filter过滤器类：AbcFilter\",\"在AbcFilter过滤器中编写放行前和放行后逻辑\",\"配置AbcFilter过滤器拦截请求路径为：/*\",\"重启SpringBoot服务，查看DemoFilter、AbcFilter的执行日志\",\"AbcFilter过滤器：\",\"@WebFilter(urlPatterns = \\\"/*\\\") public class AbcFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\\\"Abc 拦截到了请求... 放行前逻辑\\\"); //放行 chain.doFilter(request,response); System.out.println(\\\"Abc 拦截到了请求... 放行后逻辑\\\"); } } \",\"DemoFilter过滤器：\",\"@WebFilter(urlPatterns = \\\"/*\\\") public class DemoFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"DemoFilter 放行前逻辑.....\\\"); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\\\"DemoFilter 放行后逻辑.....\\\"); } } \",\"打开浏览器访问登录接口：\",\"注解方式配置的Filter过滤器，它的执行优先级是按时过滤器类名的自动排序确定的 类名排名越靠前，优先级越高。\",\"假如想让DemoFilter先执行，怎么办呢？答案就是修改类名。\",\"测试：修改AbcFilter类名为XbcFilter，运行程序查看控制台日志\",\"@WebFilter(urlPatterns = \\\"/*\\\") public class XbcFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\\\"Xbc 拦截到了请求...放行前逻辑\\\"); //放行 chain.doFilter(request,response); System.out.println(\\\"Xbc 拦截到了请求...放行后逻辑\\\"); } } \"]},{\"header\":\"2.4.3 登录校验-Filter\",\"slug\":\"_2-4-3-登录校验-filter\",\"contents\":[\"分析：\",\"登录校验的基本流程：\",\"要进入后台管理系统，必须先完成登录操作，此时就需要访问登录接口login。\",\"登录成功之后，会在服务端生成一个JWT令牌，并且把JWT令牌返回给前端，前端会将JWT令牌存储下来。\",\"在后续的每一次请求当中，都会将JWT令牌携带到服务端，请求到达服务端之后，要想去访问对应的业务功能，此时必须先要校验令牌的有效性。\",\"对于校验令牌的这一块操作，使用登录校验的过滤器，在过滤器当中来校验令牌的有效性。如果令牌是无效的，就响应一个错误的信息，也不会再去放行访问对应的资源了。如果令牌存在，并且它是有效的，此时就会放行去访问对应的web资源，执行相应的业务操作。\",\"两个问题：\",\"所有的请求，拦截到了之后，都需要校验令牌吗？\",\"答案：登录请求例外\",\"拦截到请求后，什么情况下才可以放行，执行业务操作？\",\"答案：有令牌，且令牌校验通过(合法)；否则都返回未登录错误结果\",\"具体流程:\",\"基于上面的业务流程，分析出具体的操作步骤：\",\"获取请求url\",\"判断请求url中是否包含login，如果包含，说明是登录操作，放行\",\"获取请求头中的令牌（token）\",\"判断令牌是否存在，如果不存在，返回错误结果（未登录）\",\"解析token，如果解析失败，返回错误结果（未登录）\",\"放行\",\"代码实现:\",\"基本信息\",\"请求路径：/login 请求方式：POST 接口描述：该接口用于员工登录Tlias智能学习辅助系统，登录完毕后，系统下发JWT令牌。 \",\"请求参数\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"备注\",\"username\",\"string\",\"必须\",\"用户名\",\"password\",\"string\",\"必须\",\"密码\",\"请求数据样例：\",\"{ \\\"username\\\": \\\"jinyong\\\", \\\"password\\\": \\\"123456\\\" } \",\"响应数据\",\"参数格式：application/json\",\"参数说明：\",\"名称\",\"类型\",\"是否必须\",\"默认值\",\"备注\",\"其他信息\",\"code\",\"number\",\"必须\",\"响应码, 1 成功 ; 0 失败\",\"msg\",\"string\",\"非必须\",\"提示信息\",\"data\",\"string\",\"必须\",\"返回的数据 , jwt令牌\",\"响应数据样例：\",\"{ \\\"code\\\": 1, \\\"msg\\\": \\\"success\\\", \\\"data\\\": \\\"eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoi6YeR5bq4IiwiaWQiOjEsInVzZXJuYW1lIjoiamlueW9uZyIsImV4cCI6MTY2MjIwNzA0OH0.KkUc_CXJZJ8Dd063eImx4H9Ojfrr6XMJ-yVzaWCVZCo\\\" } \",\"备注说明\",\"用户登录成功后，系统会自动下发JWT令牌，然后在后续的每次请求中，都需要在请求头header中携带到服务端，请求头的名称为 token ，值为 登录时下发的JWT令牌。\",\"如果检测到用户未登录，则会返回如下固定错误信息：\",\"{ \\\"code\\\": 0, \\\"msg\\\": \\\"NOT_LOGIN\\\", \\\"data\\\": null } \",\"登录校验过滤器：LoginCheckFilter:\",\"@Slf4j @WebFilter(urlPatterns = \\\"/*\\\") //拦截所有请求 public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException { //前置：强制转换为http协议的请求对象、响应对象 （转换原因：要使用子类中特有方法） HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; //1.获取请求url String url = request.getRequestURL().toString(); log.info(\\\"请求路径：{}\\\", url); //请求路径：http://localhost:8080/login //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行 if(url.contains(\\\"/login\\\")){ chain.doFilter(request, response);//放行请求 return;//结束当前方法的执行 } //3.获取请求头中的令牌（token） String token = request.getHeader(\\\"token\\\"); log.info(\\\"从请求头中获取的令牌：{}\\\",token); //4.判断令牌是否存在，如果不存在，返回错误结果（未登录） if(!StringUtils.hasLength(token)){ log.info(\\\"Token不存在\\\"); Result responseResult = Result.error(\\\"NOT_LOGIN\\\"); //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类) String json = JSONObject.toJSONString(responseResult); response.setContentType(\\\"application/json;charset=utf-8\\\"); //响应 response.getWriter().write(json); return; } //5.解析token，如果解析失败，返回错误结果（未登录） try { JwtUtils.parseJWT(token); }catch (Exception e){ log.info(\\\"令牌解析失败!\\\"); Result responseResult = Result.error(\\\"NOT_LOGIN\\\"); //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类) String json = JSONObject.toJSONString(responseResult); response.setContentType(\\\"application/json;charset=utf-8\\\"); //响应 response.getWriter().write(json); return; } //6.放行 chain.doFilter(request, response); } } \",\"在上述过滤器的功能实现中，使用到了一个第三方json处理的工具包fastjson\",\"<dependency> <groupId>com.alibaba</groupId> <artifactId>fastjson</artifactId> <version>1.2.76</version> </dependency> \",\"测试前先把之前所编写的测试使用的过滤器，暂时注释掉。直接将@WebFilter注解给注释掉即可。\",\"测试1：未登录是否可以访问部门管理页面\",\"关闭浏览器，重新打开，在地址栏中输入：http://localhost:9528/#/system/dept\",\"由于用户没有登录，登录校验过滤器返回错误信息，前端页面根据返回的错误信息结果，自动跳转到登录页面了\",\"测试2：先进行登录操作，再访问部门管理页面\",\"登录校验成功之后，可以正常访问相关业务操作页面\"]},{\"header\":\"2.5 拦截器Interceptor\",\"slug\":\"_2-5-拦截器interceptor\",\"contents\":[]},{\"header\":\"2.5.1 快速入门\",\"slug\":\"_2-5-1-快速入门\",\"contents\":[\"什么是拦截器？\",\"是一种动态拦截方法调用的机制，类似于过滤器。\",\"拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。\",\"拦截器的作用：\",\"拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。\",\"分为两步：\",\"定义拦截器\",\"注册配置拦截器\",\"自定义拦截器： 实现HandlerInterceptor接口，并重写其所有方法\",\"//自定义拦截器 @Component public class LoginCheckInterceptor implements HandlerInterceptor { //目标资源方法执行前执行。 返回true：放行 返回false：不放行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"preHandle .... \\\"); return true; //true表示放行 } //目标资源方法执行后执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\\\"postHandle ... \\\"); } //视图渲染完毕后执行，最后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\\\"afterCompletion .... \\\"); } } \",\"注意：\",\"preHandle方法：目标资源方法执行前执行。 返回true：放行 返回false：不放行\",\"postHandle方法：目标资源方法执行后执行\",\"afterCompletion方法：视图渲染完毕后执行，最后执行\",\"注册配置拦截器：实现WebMvcConfigurer接口，并重写addInterceptors方法\",\"@Configuration public class WebConfig implements WebMvcConfigurer { //自定义的拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor).addPathPatterns(\\\"/**\\\");//设置拦截器拦截的请求路径（ /** 表示拦截所有请求） } } \",\"重新启动SpringBoot服务，打开postman测试：\",\"再来做一个测试：将拦截器中返回值改为false\",\"使用postman，再次点击send发送请求后，没有响应数据，说明请求被拦截了没有放行\"]},{\"header\":\"2.5.2 Interceptor详解\",\"slug\":\"_2-5-2-interceptor详解\",\"contents\":[\"拦截器的拦截路径配置\",\"拦截器的执行流程\",\"拦截路径:\",\"在注册配置拦截器的时候，要指定拦截器的拦截路径，通过addPathPatterns(\\\"要拦截路径\\\")方法，就可以指定要拦截哪些资源。\",\"还可以指定不拦截哪些资源，只需要调用excludePathPatterns(\\\"不拦截路径\\\")方法，指定哪些资源不需要拦截。\",\"@Configuration public class WebConfig implements WebMvcConfigurer { //拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor) .addPathPatterns(\\\"/**\\\")//设置拦截器拦截的请求路径（ /** 表示拦截所有请求） .excludePathPatterns(\\\"/login\\\");//设置不拦截的请求路径 } } \",\"拦截路径\",\"含义\",\"举例\",\"/*\",\"一级路径\",\"能匹配/depts，/emps，/login，不能匹配 /depts/1\",\"/**\",\"任意级路径\",\"能匹配/depts，/depts/1，/depts/1/2\",\"/depts/*\",\"/depts下的一级路径\",\"能匹配/depts/1，不能匹配/depts/1/2，/depts\",\"/depts/**\",\"/depts下的任意级路径\",\"能匹配/depts，/depts/1，/depts/1/2，不能匹配/emps/1\",\"下面演示下/**与/*的区别：\",\"修改拦截器配置，把拦截路径设置为/*\",\"@Configuration public class WebConfig implements WebMvcConfigurer { //拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor) .addPathPatterns(\\\"/*\\\") .excludePathPatterns(\\\"/login\\\");//设置不拦截的请求路径 } } \",\"使用postman测试：http://localhost:8080/emps/1\",\"控制台没有输出拦截器中的日志信息，说明/*没有匹配到拦截路径/emp/1 。\",\"执行流程:\",\"通过执行流程，能清晰的知道过滤器与拦截器的执行时机。\",\"打开浏览器访问部署在web服务器当中的web应用时，此时所定义的过滤器会拦截到这次请求。拦截到这次请求之后，它会先执行放行前的逻辑，然后再执行放行操作。而由于当前是基于springboot开发的，所以放行之后是进入到了spring的环境当中，也就是要来访问所定义的controller当中的接口方法。\",\"Tomcat并不识别所编写的Controller程序，但是它识别Servlet程序，所以在Spring的Web环境中提供了一个非常核心的Servlet：DispatcherServlet（前端控制器），所有请求都会先进行到DispatcherServlet，再将请求转给Controller。\",\"定义了拦截器后，会在执行Controller的方法之前，请求被拦截器拦截住。执行preHandle()方法，这个方法执行完成后需要返回一个布尔类型的值，如果返回true，就表示放行本次操作，才会继续访问controller中的方法；如果返回false，则不会放行（controller中的方法也不会执行）。\",\"controller当中的方法执行完毕，再执行postHandle()这个方法以及afterCompletion() 方法，然后再返回给DispatcherServlet，最终再来执行过滤器当中放行后的这一部分逻辑的逻辑。执行完毕之后，最终给浏览器响应数据。\",\"演示过滤器和拦截器同时存在的执行流程：\",\"开启LoginCheckInterceptor拦截器\",\"@Component public class LoginCheckInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"preHandle .... \\\"); return true; //true表示放行 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\\\"postHandle ... \\\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\\\"afterCompletion .... \\\"); } } \",\"@Configuration public class WebConfig implements WebMvcConfigurer { //拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor) .addPathPatterns(\\\"/**\\\")//拦截所有请求 .excludePathPatterns(\\\"/login\\\");//不拦截登录请求 } } \",\"开启DemoFilter过滤器\",\"@WebFilter(urlPatterns = \\\"/*\\\") public class DemoFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\\\"DemoFilter 放行前逻辑.....\\\"); //放行请求 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\\\"DemoFilter 放行后逻辑.....\\\"); } } \",\"重启SpringBoot服务后，清空日志，打开Postman，测试查询部门：\",\"过滤器和拦截器之间的区别：\",\"接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口。\",\"拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。\"]},{\"header\":\"2.5.3 登录校验- Interceptor\",\"slug\":\"_2-5-3-登录校验-interceptor\",\"contents\":[\"登录校验拦截器:\",\"//自定义拦截器 @Component //当前拦截器对象由Spring创建和管理 @Slf4j public class LoginCheckInterceptor implements HandlerInterceptor { //前置方式 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"preHandle .... \\\"); //1.获取请求url //2.判断请求url中是否包含login，如果包含，说明是登录操作，放行 //3.获取请求头中的令牌（token） String token = request.getHeader(\\\"token\\\"); log.info(\\\"从请求头中获取的令牌：{}\\\",token); //4.判断令牌是否存在，如果不存在，返回错误结果（未登录） if(!StringUtils.hasLength(token)){ log.info(\\\"Token不存在\\\"); //创建响应结果对象 Result responseResult = Result.error(\\\"NOT_LOGIN\\\"); //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类) String json = JSONObject.toJSONString(responseResult); //设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8） response.setContentType(\\\"application/json;charset=utf-8\\\"); //响应 response.getWriter().write(json); return false;//不放行 } //5.解析token，如果解析失败，返回错误结果（未登录） try { JwtUtils.parseJWT(token); }catch (Exception e){ log.info(\\\"令牌解析失败!\\\"); //创建响应结果对象 Result responseResult = Result.error(\\\"NOT_LOGIN\\\"); //把Result对象转换为JSON格式字符串 (fastjson是阿里巴巴提供的用于实现对象和json的转换工具类) String json = JSONObject.toJSONString(responseResult); //设置响应头 response.setContentType(\\\"application/json;charset=utf-8\\\"); //响应 response.getWriter().write(json); return false; } //6.放行 return true; } \",\"注册配置拦截器:\",\"@Configuration public class WebConfig implements WebMvcConfigurer { //拦截器对象 @Autowired private LoginCheckInterceptor loginCheckInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //注册自定义拦截器对象 registry.addInterceptor(loginCheckInterceptor) .addPathPatterns(\\\"/**\\\") .excludePathPatterns(\\\"/login\\\"); } } \",\"登录校验的拦截器编写完成后（关闭登录校验Filter过滤器）\",\"测试1：未登录是否可以访问部门管理页面\",\"关闭浏览器，重新打开，在地址栏中输入：http://localhost:9528/#/system/dept\",\"由于用户没有登录，校验机制返回错误信息，前端页面根据返回的错误信息结果，自动跳转到登录页面了\",\"测试2：先进行登录操作，再访问部门管理页面\",\"登录校验成功之后，可以正常访问相关业务操作页面\"]},{\"header\":\"3. 异常处理\",\"slug\":\"_3-异常处理\",\"contents\":[]},{\"header\":\"3.1 当前问题\",\"slug\":\"_3-1-当前问题\",\"contents\":[\"打开浏览器，访问系统中的新增部门操作，系统中已经有了 \\\"就业部\\\" 这个部门，再增加一个就业部\",\"点击确定之后，窗口关闭了，页面没有任何反应，就业部也没有添加上。 F12网络请求报错了\",\"状态码为500，表示服务器端异常\",\"上述错误信息的含义是：dept部门表的name字段的值就业部重复了，再添加就业部这个部门时，就违反了唯一约束，此时就会报错。\",\"响应回来的数据是一个JSON格式的数据。但这种JSON格式的数据不是开发规范当中所提到的统一响应结果Result。由于返回的数据不符合开发规范，所以前端并不能解析出响应的JSON数据。\",\"出现异常之后，当前案例项目的异常是怎么处理的？\",\"答案：没有做任何的异常处理\",\"没有做任何的异常处理时，三层架构处理异常的方案：\",\"Mapper接口在操作数据库的时候出错了，此时异常会往上抛(谁调用Mapper就抛给谁)，会抛给service。\",\"service 中也存在异常了，会抛给controller。\",\"而在controller当中，没有做任何的异常处理，所以最终异常会再往上抛。最终抛给框架之后，框架就会返回一个JSON格式的数据，里面封装的就是错误的信息，但是框架返回的JSON格式的数据并不符合我们的开发规范。\"]},{\"header\":\"3.2 解决方案\",\"slug\":\"_3-2-解决方案\",\"contents\":[\"那么在三层构架项目中，出现了异常，该如何处理?\",\"方案一：在所有Controller的所有方法中进行try…catch处理 \",\"缺点：代码臃肿（不推荐）\",\"方案二：全局异常处理器 \",\"好处：简单、优雅（推荐）\"]},{\"header\":\"3.3 全局异常处理器\",\"slug\":\"_3-3-全局异常处理器\",\"contents\":[\"定义全局异常处理器非常简单，就是定义一个类，在类上加上一个注解@RestControllerAdvice，加上这个注解就代表我们定义了一个全局异常处理器。\",\"在全局异常处理器当中，需要定义一个方法来捕获异常，在这个方法上需要加上注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定要捕获的是哪一类型的异常。\",\"@RestControllerAdvice public class GlobalExceptionHandler { //处理异常 @ExceptionHandler(Exception.class) //指定能够处理的异常类型 public Result ex(Exception e){ e.printStackTrace();//打印堆栈中的异常信息 //捕获到异常之后，响应一个标准的Result return Result.error(\\\"对不起,操作失败,请联系管理员\\\"); } } \",\"@RestControllerAdvice = @ControllerAdvice + @ResponseBody\",\"处理异常的方法返回值会转换为json后再响应给前端\",\"重新启动SpringBoot服务，打开浏览器，依然添加已存在的 \\\"就业部\\\"\",\"异常已经被全局异常处理器捕获了。然后返回的错误信息，被前端程序正常解析，提示出了对应的错误提示信息。\",\"主要涉及到两个注解\",\"@RestControllerAdvice //表示当前类为全局异常处理器\",\"@ExceptionHandler  //指定可以捕获哪种类型的异常进行处理\"]}]},\"/BackEnd/SpringBoot/springboot06.html\":{\"title\":\"SpringBoot事务、AOP\",\"contents\":[{\"header\":\"1. 事务管理\",\"slug\":\"_1-事务管理\",\"contents\":[]},{\"header\":\"1.1 事务回顾\",\"slug\":\"_1-1-事务回顾\",\"contents\":[\"事务是一组操作的集合，它是一个不可分割的工作单位。事务会把所有的操作作为一个整体，一起向数据库提交或者是撤销操作请求。所以这组操作要么同时成功，要么同时失败。\",\"事务的操作\",\"开启事务（一组操作开始前，开启事务）：start transaction / begin ;\",\"提交事务（这组操作全部成功后，提交事务）：commit ;\",\"回滚事务（中间任何一个操作出现异常，回滚事务）：rollback ;\"]},{\"header\":\"1.2 Spring事务管理\",\"slug\":\"_1-2-spring事务管理\",\"contents\":[]},{\"header\":\"1.2.1 案例\",\"slug\":\"_1-2-1-案例\",\"contents\":[\"需求：当部门解散了不仅需要把部门信息删除了，还需要把该部门下的员工数据也删除了。\",\"步骤：\",\"根据ID删除部门数据\",\"根据部门ID删除该部门下的员工\",\"代码实现：\",\"DeptServiceImpl\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; //根据部门id，删除部门信息及部门下的所有员工 @Override public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } } \",\"DeptMapper\",\"@Mapper public interface DeptMapper { /** * 根据id删除部门信息 * @param id 部门id */ @Delete(\\\"delete from dept where id = #{id}\\\") void deleteById(Integer id); } \",\"EmpMapper\",\"@Mapper public interface EmpMapper { //根据部门id删除部门下所有员工 @Delete(\\\"delete from emp where dept_id=#{deptId}\\\") public int deleteByDeptId(Integer deptId); } \",\"重启SpringBoot服务，使用postman测试部门删除：\",\"代码正常情况下，dept表和Em表中的数据已删除\",\"修改DeptServiceImpl类中代码，添加可能出现异常的代码：\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; //根据部门id，删除部门信息及部门下的所有员工 @Override public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 int i = 1/0; //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } } \",\"重启SpringBoot服务，使用postman测试部门删除：\",\"查看数据库表：\",\"删除了2号部门\",\"2号部门下的员工数据没有删除\",\"以上程序出现的问题：即使程序运行抛出了异常，部门依然删除了，但是部门下的员工却没有删除，造成了数据的不一致。\"]},{\"header\":\"1.2.2 原因分析\",\"slug\":\"_1-2-2-原因分析\",\"contents\":[\"先执行根据id删除部门的操作，这步执行完毕，数据库表 dept 中的数据就已经删除了。\",\"执行 1/0 操作，抛出异常\",\"抛出异常之前，下面所有的代码都不会执行了，根据部门ID删除该部门下的员工，这个操作也不会执行 。\",\"此时，在delete删除业务功能中添加事务\",\"在方法运行之前，开启事务，如果方法成功执行，就提交事务，如果方法执行的过程当中出现异常了，就回滚事务。\"]},{\"header\":\"1.2.3 Transactional注解\",\"slug\":\"_1-2-3-transactional注解\",\"contents\":[\"@Transactional作用\",\"在方法执行开始之前开启事务，方法执行完毕之后提交事务。如果这个方法执行的过程当中出现了异常，就会进行事务的回滚操作。\",\"@Transactional注解\",\"一般会在业务层当中来控制事务，因为在业务层当中，一个业务功能可能会包含多个数据访问的操作。\",\"在业务层来控制事务，可以将多个数据访问操作控制在一个事务范围内。\",\"@Transactional注解书写位置\",\"方法: 当前方法交给spring进行事务管理\",\"类: 当前类中所有的方法都交由spring进行事务管理\",\"接口: 接口下所有的实现类当中所有的方法都交给spring 进行事务管理\",\"在业务方法delete上加上 @Transactional 来控制事务\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Override @Transactional //当前方法添加了事务管理 public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 int i = 1/0; //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } } \",\"重启SpringBoot服务，使用postman测试：\",\"添加Spring事务管理后，由于服务端程序引发了异常，所以事务进行回滚。\",\"说明：在application.yml配置文件中开启事务管理日志，这样就可以在控制台看到和事务相关的日志信息了\",\"#spring事务管理日志 logging: level: org.springframework.jdbc.support.JdbcTransactionManager: debug \"]},{\"header\":\"1.3 事务进阶\",\"slug\":\"_1-3-事务进阶\",\"contents\":[\"@Transactional注解当中的两个常见的属性：\",\"异常回滚的属性：rollbackFor\",\"事务传播行为：propagation\"]},{\"header\":\"1.3.1 rollbackFor\",\"slug\":\"_1-3-1-rollbackfor\",\"contents\":[\"@Transactional public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 int i = 1/0; //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } \",\"修改业务功能代码，在模拟异常的位置上直接抛出Exception异常（编译时异常）\",\"@Transactional public void delete(Integer id) throws Exception { //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 if(true){ throw new Exception(\\\"出现异常了```\\\"); } //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } \",\"说明：在service中向上抛出一个Exception编译时异常之后，由于是controller调用service，所以在controller中要有异常处理代码，此时选择在controller中继续把异常向上抛。\",\"@DeleteMapping(\\\"/depts/{id}\\\") public Result delete(@PathVariable Integer id) throws Exception { //日志记录 log.info(\\\"根据id删除部门\\\"); //调用service层功能 deptService.delete(id); //响应 return Result.success(); } \",\"重新启动服务后测试：\",\"抛出异常之后事务会不会回滚\",\"现有表中数据：\",\"使用postman测试，删除5号部门\",\"发生了Exception异常，但事务依然提交了\",\"dept表中数据：\",\"结论：默认情况下，只有出现RuntimeException(运行时异常)才会回滚事务。\",\"配置@Transactional注解当中的rollbackFor属性，通过rollbackFor这个属性可以指定出现何种异常类型回滚事务。\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Override @Transactional(rollbackFor=Exception.class) public void delete(Integer id){ //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常发生 int num = id/0; //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); } } \",\"重新启动服务，测试删除部门的操作：\",\"控制台日志：执行了删除3号部门的操作， 因为异常又进行了事务回滚\",\"数据表：3号部门没有删除\",\"结论：\",\"在Spring的事务管理中，默认只有运行时异常 RuntimeException才会回滚。\",\"如果还需要回滚指定类型的异常，可以通过rollbackFor属性来指定。\"]},{\"header\":\"1.3.3 propagation\",\"slug\":\"_1-3-3-propagation\",\"contents\":[\"这个属性是用来配置事务的传播行为的。\",\"所谓事务的传播行为，指的就是在A方法运行的时候，首先会开启一个事务，在A方法当中又调用了B方法， B方法自身也具有事务，那么B方法在运行的时候，到底是加入到A方法的事务当中来，还是B方法在运行的时候新建一个事务？这个就涉及到了事务的传播行为。\",\"常见的事务传播行为。\",\"属性值\",\"含义\",\"REQUIRED\",\"【默认值】需要事务，有则加入，无则创建新事务\",\"REQUIRES_NEW\",\"需要新事务，无论有无，总是创建新事务\",\"SUPPORTS\",\"支持事务，有则加入，无则在无事务状态中运行\",\"NOT_SUPPORTED\",\"不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务\",\"MANDATORY\",\"必须有事务，否则抛异常\",\"NEVER\",\"必须没事务，否则抛异常\",\"…\",\"案例:\",\"需求： 解散部门时需要记录操作日志\",\"由于解散部门是一个非常重要而且非常危险的操作，所以在业务当中要求每一次执行解散部门的操作都需要留下痕迹，就是要记录操作日志。而且还要求无论是执行成功了还是执行失败了，都需要留下痕迹。\",\"步骤：\",\"执行解散部门的业务：先删除部门，再删除部门下的员工（前面已实现）\",\"记录解散部门的日志，到日志表（未实现）\",\"准备工作：\",\"创建数据库表 dept_log 日志表：\",\"create table dept_log( id int auto_increment comment '主键ID' primary key, create_time datetime null comment '操作时间', description varchar(300) null comment '操作描述' )comment '部门操作日志表'; \",\"引入资料中提供的实体类：DeptLog\",\"@Data @NoArgsConstructor @AllArgsConstructor public class DeptLog { private Integer id; private LocalDateTime createTime; private String description; } \",\"引入资料中提供的Mapper接口：DeptLogMapper\",\"@Mapper public interface DeptLogMapper { @Insert(\\\"insert into dept_log(create_time,description) values(#{createTime},#{description})\\\") void insert(DeptLog log); } \",\"引入资料中提供的业务接口：DeptLogService\",\"public interface DeptLogService { void insert(DeptLog deptLog); } \",\"引入资料中提供的业务实现类：DeptLogServiceImpl\",\"@Service public class DeptLogServiceImpl implements DeptLogService { @Autowired private DeptLogMapper deptLogMapper; @Transactional //事务传播行为：有事务就加入、没有事务就新建事务 @Override public void insert(DeptLog deptLog) { deptLogMapper.insert(deptLog); } } \",\"代码实现:\",\"业务实现类：DeptServiceImpl\",\"@Slf4j @Service //@Transactional //当前业务实现类中的所有的方法，都添加了spring事务管理机制 public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Autowired private EmpMapper empMapper; @Autowired private DeptLogService deptLogService; //根据部门id，删除部门信息及部门下的所有员工 @Override @Log @Transactional(rollbackFor = Exception.class) public void delete(Integer id) throws Exception { try { //根据部门id删除部门信息 deptMapper.deleteById(id); //模拟：异常 if(true){ throw new Exception(\\\"出现异常了```\\\"); } //删除部门下的所有员工信息 empMapper.deleteByDeptId(id); }finally { //不论是否有异常，最终都要执行的代码：记录日志 DeptLog deptLog = new DeptLog(); deptLog.setCreateTime(LocalDateTime.now()); deptLog.setDescription(\\\"执行了解散部门的操作，此时解散的是\\\"+id+\\\"号部门\\\"); //调用其他业务类中的方法 deptLogService.insert(deptLog); } } //省略其他代码... } \",\"测试:\",\"重新启动SpringBoot服务，测试删除3号部门\",\"执行了删除3号部门操作\",\"执行了插入部门日志操作\",\"程序发生Exception异常\",\"执行事务回滚（删除、插入操作因为在一个事务范围内，两个操作都会被回滚）\",\"然后在dept_log表中没有记录日志数据\",\"原因分析:\",\"在执行delete操作时开启了一个事务\",\"当执行insert操作时，insert设置的事务传播行是默认值REQUIRED，表示有事务就加入，没有则新建事务\",\"此时：delete和insert操作使用了同一个事务，同一个事务中的多个操作，要么同时成功，要么同时失败，所以当异常发生时进行事务回滚，就会回滚delete和insert操作\",\"解决方案：\",\"在DeptLogServiceImpl类中insert方法上，添加 @Transactional(propagation = Propagation.REQUIRES_NEW)\",\"Propagation.REQUIRES_NEW ：不论是否有事务，都创建新事务 ，运行在一个独立的事务中。\",\"@Service public class DeptLogServiceImpl implements DeptLogService { @Autowired private DeptLogMapper deptLogMapper; //事务传播行为：不论是否有事务，都新建事务 @Transactional(propagation = Propagation.REQUIRES_NEW) @Override public void insert(DeptLog deptLog) { deptLogMapper.insert(deptLog); } } \",\"重启SpringBoot服务，再次测试删除3号部门：\",\"REQUIRED ：大部分情况下都是用该传播行为即可。\",\"REQUIRES_NEW ：不希望事务之间相互影响时，可以使用该传播行为。 比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。\"]},{\"header\":\"2. AOP基础\",\"slug\":\"_2-aop基础\",\"contents\":[]},{\"header\":\"2.1 AOP概述\",\"slug\":\"_2-1-aop概述\",\"contents\":[\"什么是AOP？\",\"Aspect Oriented Programming（面向切面编程、面向方面编程）\",\"面向切面编程就是面向特定方法编程。\",\"比如，一个项目中开发了很多的业务功能。\",\"有一些业务功能执行效率比较低，执行耗时较长，需要针对于这些业务方法进行优化\",\"如果在每一个模块下的业务方法中，添加记录开始时间、结束时间、计算执行耗时的代码，就会让程序员的工作变得非常繁琐。\",\"AOP的作用：在程序运行期间在不修改源代码的基础上对已有方法进行增强（无侵入性: 解耦）\",\"此时，调用部门管理的 list 业务方法时啊，并不会直接执行 list 方法的逻辑，而是会执行定义的 模板方法 ， 然后再模板方法中：\",\"记录方法运行开始时间\",\"运行原始的业务方法（那此时原始的业务方法，就是 list 方法）\",\"记录方法运行结束时间，计算方法执行耗时\",\"其实，AOP面向切面编程和OOP面向对象编程一样，它们都仅仅是一种编程思想，而动态代理技术是这种思想最主流的实现方式。 Spring的AOP是Spring框架的高级技术，旨在管理bean对象的过程中底层使用动态代理机制，对特定的方法进行编程(功能增强)。\",\"AOP的优势\",\"减少重复代码\",\"提高开发效率\",\"维护方便\"]},{\"header\":\"2.2 AOP快速入门\",\"slug\":\"_2-2-aop快速入门\",\"contents\":[\"需求： 统计各个业务层方法执行耗时。\",\"实现步骤：\",\"导入依赖：在pom.xml中导入AOP的依赖\",\"编写AOP程序：针对于特定方法根据业务需要进行编程\",\"pom.xml:\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency> \",\"AOP程序：TimeAspect:\",\"@Component @Aspect //当前类为切面类 @Slf4j public class TimeAspect { @Around(\\\"execution(* com.itheima.service.*.*(..))\\\") public Object recordTime(ProceedingJoinPoint pjp) throws Throwable { //记录方法执行开始时间 long begin = System.currentTimeMillis(); //执行原始方法 Object result = pjp.proceed(); //记录方法执行结束时间 long end = System.currentTimeMillis(); //计算方法执行耗时 log.info(pjp.getSignature()+\\\"执行耗时: {}毫秒\\\",end-begin); return result; } } \",\"重新启动SpringBoot服务测试程序：\",\"查询3号部门信息\",\"查询所有部门信息（同样执行AOP程序）\",\"AOP的功能\",\"记录系统的操作日志\",\"权限控制\",\"事务管理：Spring事务管理，底层其实也是通过AOP来实现的，只要添加@Transactional注解之后，AOP程序自动会在原始方法运行前先来开启事务，在原始方法运行完毕之后提交或回滚事务\",\"AOP面向切面编程的一些优势\",\"代码无侵入：没有修改原始的业务方法，就已经对原始的业务方法进行了功能的增强或者是功能的改变\",\"减少了重复代码\",\"提高开发效率\",\"维护方便\"]},{\"header\":\"2.3 AOP核心概念\",\"slug\":\"_2-3-aop核心概念\",\"contents\":[\"1. 连接点：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息）\",\"例如：入门程序当中所有的业务方法都是可以被aop控制的方法。\",\"2. 通知：Advice，指哪些重复的逻辑，也就是共性功能（最终体现为一个方法）\",\"在入门程序中统计各个业务方法的执行耗时，在AOP面向切面编程当中，只需要将这部分重复的代码逻辑抽取出来单独定义。抽取出来的这一部分重复的逻辑，也就是共性的功能。\",\"3. 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用\",\"在通知当中，定义的共性功能到底要应用在哪些方法上？此时就涉及到了切入点pointcut概念。切入点指的是匹配连接点的条件。通知仅会在切入点方法运行时才会被应用。\",\"在aop的开发当中，通常会通过一个切入点表达式来描述切入点。\",\"假如：切入点表达式改为DeptServiceImpl.list()，此时就代表仅仅只有list这一个方法是切入点。只有list()方法在运行的时候才会应用通知。\",\"4. 切面：Aspect，描述通知与切入点的对应关系（通知+切入点）\",\"当通知和切入点结合在一起，就形成了一个切面。通过切面就能够描述当前aop程序需要针对于哪个原始方法，在什么时候执行什么样的操作。\",\"切面所在的类，一般称为切面类（被@Aspect注解标识的类）\",\"5. 目标对象：Target，通知所应用的对象\",\"目标对象指的就是通知所应用的对象，就称之为目标对象。\",\"通知是如何与目标对象结合在一起，对目标对象当中的方法进行功能增强的。\",\"Spring的AOP底层是基于动态代理技术来实现的，也就是说在程序运行的时候，会自动的基于动态代理技术为目标对象生成一个对应的代理对象。在代理对象当中就会对目标对象当中的原始方法进行功能的增强。\"]},{\"header\":\"3. AOP进阶\",\"slug\":\"_3-aop进阶\",\"contents\":[]},{\"header\":\"3.1 通知类型\",\"slug\":\"_3-1-通知类型\",\"contents\":[\"@Around(\\\"execution(* com.itheima.service.*.*(..))\\\") public Object recordTime(ProceedingJoinPoint pjp) throws Throwable { //记录方法执行开始时间 long begin = System.currentTimeMillis(); //执行原始方法 Object result = pjp.proceed(); //记录方法执行结束时间 long end = System.currentTimeMillis(); //计算方法执行耗时 log.info(pjp.getSignature()+\\\"执行耗时: {}毫秒\\\",end-begin); return result; } \",\"在通知方法上加上了@Around注解，就代表当前通知是一个环绕通知。\",\"Spring中AOP的通知类型：\",\"@Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行\",\"@Before：前置通知，此注解标注的通知方法在目标方法前被执行\",\"@After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行\",\"@AfterReturning ： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行\",\"@AfterThrowing ： 异常后通知，此注解标注的通知方法发生异常后执行\",\"@Slf4j @Component @Aspect public class MyAspect1 { //前置通知 @Before(\\\"execution(* com.itheima.service.*.*(..))\\\") public void before(JoinPoint joinPoint){ log.info(\\\"before ...\\\"); } //环绕通知 @Around(\\\"execution(* com.itheima.service.*.*(..))\\\") public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { log.info(\\\"around before ...\\\"); //调用目标对象的原始方法执行 Object result = proceedingJoinPoint.proceed(); //原始方法如果执行时有异常，环绕通知中的后置代码不会在执行了 log.info(\\\"around after ...\\\"); return result; } //后置通知 @After(\\\"execution(* com.itheima.service.*.*(..))\\\") public void after(JoinPoint joinPoint){ log.info(\\\"after ...\\\"); } //返回后通知（程序在正常执行的情况下，会执行的后置通知） @AfterReturning(\\\"execution(* com.itheima.service.*.*(..))\\\") public void afterReturning(JoinPoint joinPoint){ log.info(\\\"afterReturning ...\\\"); } //异常通知（程序在出现异常的情况下，执行的后置通知） @AfterThrowing(\\\"execution(* com.itheima.service.*.*(..))\\\") public void afterThrowing(JoinPoint joinPoint){ log.info(\\\"afterThrowing ...\\\"); } } \",\"重新启动SpringBoot服务，进行测试：\",\"1. 没有异常情况下：\",\"使用postman测试查询所有部门数据\",\"查看idea中控制台日志输出\",\"程序没有发生异常的情况下，@AfterThrowing标识的通知方法不会执行。\",\"2. 出现异常情况下：\",\"修改DeptServiceImpl业务实现类中的代码： 添加异常\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public List<Dept> list() { List<Dept> deptList = deptMapper.list(); //模拟异常 int num = 10/0; return deptList; } //省略其他代码... } \",\"重新启动SpringBoot服务，测试发生异常情况下通知的执行：\",\"查看idea中控制台日志输出\",\"程序发生异常的情况下：\",\"@AfterReturning标识的通知方法不会执行，@AfterThrowing标识的通知方法执行\",\"@Around环绕通知中原始方法调用时有异常，通知中的环绕后的代码逻辑也不会在执行了 （因为原始方法调用已经出异常了）\",\"使用通知时的注意事项\",\"@Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行\",\"@Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。\",\"//前置通知 @Before(\\\"execution(* com.itheima.service.*.*(..))\\\") //环绕通知 @Around(\\\"execution(* com.itheima.service.*.*(..))\\\") //后置通知 @After(\\\"execution(* com.itheima.service.*.*(..))\\\") //返回后通知（程序在正常执行的情况下，会执行的后置通知） @AfterReturning(\\\"execution(* com.itheima.service.*.*(..))\\\") //异常通知（程序在出现异常的情况下，执行的后置通知） @AfterThrowing(\\\"execution(* com.itheima.service.*.*(..))\\\") \",\"怎么来解决这个切入点表达式重复的问题？ 答案就是：抽取\",\"Spring提供了@PointCut注解，作用是将公共的切入点表达式抽取出来，需要用到时引用该切入点表达式即可。\",\"@Slf4j @Component @Aspect public class MyAspect1 { //切入点方法（公共的切入点表达式） @Pointcut(\\\"execution(* com.itheima.service.*.*(..))\\\") private void pt(){ } //前置通知（引用切入点） @Before(\\\"pt()\\\") public void before(JoinPoint joinPoint){ log.info(\\\"before ...\\\"); } //环绕通知 @Around(\\\"pt()\\\") public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { log.info(\\\"around before ...\\\"); //调用目标对象的原始方法执行 Object result = proceedingJoinPoint.proceed(); //原始方法在执行时：发生异常 //后续代码不在执行 log.info(\\\"around after ...\\\"); return result; } //后置通知 @After(\\\"pt()\\\") public void after(JoinPoint joinPoint){ log.info(\\\"after ...\\\"); } //返回后通知（程序在正常执行的情况下，会执行的后置通知） @AfterReturning(\\\"pt()\\\") public void afterReturning(JoinPoint joinPoint){ log.info(\\\"afterReturning ...\\\"); } //异常通知（程序在出现异常的情况下，执行的后置通知） @AfterThrowing(\\\"pt()\\\") public void afterThrowing(JoinPoint joinPoint){ log.info(\\\"afterThrowing ...\\\"); } } \",\"需要注意的是：当切入点方法使用private修饰时，仅能在当前切面类中引用该表达式， 当外部其他切面类中也要引用当前类中的切入点表达式，就需要把private改为public 在引用的时候，具体的语法为：全类名.方法名()\",\"@Slf4j @Component @Aspect public class MyAspect2 { //引用MyAspect1切面类中的切入点表达式 @Before(\\\"com.itheima.aspect.MyAspect1.pt()\\\") public void before(){ log.info(\\\"MyAspect2 -> before ...\\\"); } } \"]},{\"header\":\"3.2 通知顺序\",\"slug\":\"_3-2-通知顺序\",\"contents\":[\"定义多个切面类：\",\"@Slf4j @Component @Aspect public class MyAspect2 { //前置通知 @Before(\\\"execution(* com.itheima.service.*.*(..))\\\") public void before(){ log.info(\\\"MyAspect2 -> before ...\\\"); } //后置通知 @After(\\\"execution(* com.itheima.service.*.*(..))\\\") public void after(){ log.info(\\\"MyAspect2 -> after ...\\\"); } } \",\"@Slf4j @Component @Aspect public class MyAspect3 { //前置通知 @Before(\\\"execution(* com.itheima.service.*.*(..))\\\") public void before(){ log.info(\\\"MyAspect3 -> before ...\\\"); } //后置通知 @After(\\\"execution(* com.itheima.service.*.*(..))\\\") public void after(){ log.info(\\\"MyAspect3 -> after ...\\\"); } } \",\"@Slf4j @Component @Aspect public class MyAspect4 { //前置通知 @Before(\\\"execution(* com.itheima.service.*.*(..))\\\") public void before(){ log.info(\\\"MyAspect4 -> before ...\\\"); } //后置通知 @After(\\\"execution(* com.itheima.service.*.*(..))\\\") public void after(){ log.info(\\\"MyAspect4 -> after ...\\\"); } } \",\"重新启动SpringBoot服务，测试通知的执行顺序：\",\"备注：\",\"把DeptServiceImpl实现类中模拟异常的代码删除或注释掉。\",\"注释掉其他切面类(把@Aspect注释即可)，仅保留MyAspect2、MyAspect3、MyAspect4 ，这样就可以清晰看到执行的结果，而不被其他切面类干扰。\",\"使用postman测试查询所有部门数据\",\"查看idea中控制台日志输出\",\"默认按照切面类的类名字母排序：\",\"目标方法前的通知方法：字母排名靠前的先执行\",\"目标方法后的通知方法：字母排名靠前的后执行\",\"控制通知的执行顺序有两种方式：\",\"修改切面类的类名（繁琐、不便管理）\",\"使用Spring提供的@Order注解\",\"使用@Order注解，控制通知的执行顺序：\",\"@Slf4j @Component @Aspect @Order(2) //切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行） public class MyAspect2 { //前置通知 @Before(\\\"execution(* com.itheima.service.*.*(..))\\\") public void before(){ log.info(\\\"MyAspect2 -> before ...\\\"); } //后置通知 @After(\\\"execution(* com.itheima.service.*.*(..))\\\") public void after(){ log.info(\\\"MyAspect2 -> after ...\\\"); } } \",\"@Slf4j @Component @Aspect @Order(3) //切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行） public class MyAspect3 { //前置通知 @Before(\\\"execution(* com.itheima.service.*.*(..))\\\") public void before(){ log.info(\\\"MyAspect3 -> before ...\\\"); } //后置通知 @After(\\\"execution(* com.itheima.service.*.*(..))\\\") public void after(){ log.info(\\\"MyAspect3 -> after ...\\\"); } } \",\"@Slf4j @Component @Aspect @Order(1) //切面类的执行顺序（前置通知：数字越小先执行; 后置通知：数字越小越后执行） public class MyAspect4 { //前置通知 @Before(\\\"execution(* com.itheima.service.*.*(..))\\\") public void before(){ log.info(\\\"MyAspect4 -> before ...\\\"); } //后置通知 @After(\\\"execution(* com.itheima.service.*.*(..))\\\") public void after(){ log.info(\\\"MyAspect4 -> after ...\\\"); } } \",\"重新启动SpringBoot服务，测试通知执行顺序：\"]},{\"header\":\"3.3 切入点表达式\",\"slug\":\"_3-3-切入点表达式\",\"contents\":[\"描述切入点方法的一种表达式\",\"作用：主要用来决定项目中的哪些方法需要加入通知\",\"常见形式：\",\"execution(……)：根据方法的签名来匹配\",\"@annotation(……) ：根据注解匹配\"]},{\"header\":\"3.3.1 execution\",\"slug\":\"_3-3-1-execution\",\"contents\":[\"execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：\",\"execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?) \",\"其中带?的表示可以省略的部分\",\"访问修饰符：可省略（比如: public、protected）\",\"包名.类名： 可省略\",\"throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）\",\"示例：\",\"@Before(\\\"execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))\\\") \",\"可以使用通配符描述切入点\",\"* ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分\",\".. ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数\",\"切入点表达式的语法规则\",\"方法的访问修饰符可以省略\",\"返回值可以使用*号代替（任意返回值类型）\",\"包名可以使用*号代替，代表任意包（一层包使用一个*）\",\"使用..配置包名，标识此包以及此包下的所有子包\",\"类名可以使用*号代替，标识任意类\",\"方法名可以使用*号代替，表示任意方法\",\"可以使用 * 配置参数，一个任意类型的参数\",\"可以使用.. 配置参数，任意个任意类型的参数\",\"切入点表达式示例:\",\"省略方法的修饰符号\",\"execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer)) \",\"使用*代替返回值类型\",\"execution(* com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer)) \",\"使用*代替包名（一层包使用一个*）\",\"execution(* com.itheima.*.*.DeptServiceImpl.delete(java.lang.Integer)) \",\"使用..省略包名\",\"execution(* com..DeptServiceImpl.delete(java.lang.Integer)) \",\"使用*代替类名\",\"execution(* com..*.delete(java.lang.Integer)) \",\"使用*代替方法名\",\"execution(* com..*.*(java.lang.Integer)) \",\"使用 * 代替参数\",\"execution(* com.itheima.service.impl.DeptServiceImpl.delete(*)) \",\"使用..省略参数\",\"execution(* com..*.*(..)) \",\"注意事项：\",\"根据业务需要，可以使用 且（&&）、或（||）、非（!） 来组合比较复杂的切入点表达式。\",\"execution(* com.itheima.service.DeptService.list(..)) || execution(* com.itheima.service.DeptService.delete(..)) \",\"切入点表达式的书写建议：\",\"所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是update开头\",\"//业务类 @Service public class DeptServiceImpl implements DeptService { public List<Dept> findAllDept() { //省略代码... } public Dept findDeptById(Integer id) { //省略代码... } public void updateDeptById(Integer id) { //省略代码... } public void updateDeptByMoreCondition(Dept dept) { //省略代码... } //其他代码... } \",\"//匹配DeptServiceImpl类中以find开头的方法 execution(* com.itheima.service.impl.DeptServiceImpl.find*(..)) \",\"描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性\",\"execution(* com.itheima.service.DeptService.*(..)) \",\"在满足业务需要的前提下，尽量缩小切入点的匹配范围。如：包名匹配尽量不使用 ..，使用 * 匹配单个包\",\"execution(* com.itheima.*.*.DeptServiceImpl.find*(..)) \"]},{\"header\":\"3.3.2 @annotation\",\"slug\":\"_3-3-2-annotation\",\"contents\":[\"实现步骤：\",\"编写自定义注解\",\"在业务类要做为连接点的方法上添加自定义注解\",\"自定义注解：MyLog\",\"@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface MyLog { } \",\"业务类：DeptServiceImpl\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override @MyLog //自定义注解（表示：当前方法属于目标方法） public List<Dept> list() { List<Dept> deptList = deptMapper.list(); //模拟异常 //int num = 10/0; return deptList; } @Override @MyLog //自定义注解（表示：当前方法属于目标方法） public void delete(Integer id) { //1. 删除部门 deptMapper.delete(id); } @Override public void save(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.save(dept); } @Override public Dept getById(Integer id) { return deptMapper.getById(id); } @Override public void update(Dept dept) { dept.setUpdateTime(LocalDateTime.now()); deptMapper.update(dept); } } \",\"切面类:\",\"@Slf4j @Component @Aspect public class MyAspect6 { //针对list方法、delete方法进行前置通知和后置通知 //前置通知 @Before(\\\"@annotation(com.itheima.anno.MyLog)\\\") public void before(){ log.info(\\\"MyAspect6 -> before ...\\\"); } //后置通知 @After(\\\"@annotation(com.itheima.anno.MyLog)\\\") public void after(){ log.info(\\\"MyAspect6 -> after ...\\\"); } } \",\"重启SpringBoot服务，测试查询所有部门数据，查看控制台日志：\",\"提示\",\"execution切入点表达式\",\"根据所指定的方法的描述信息来匹配切入点方法，这种方式也是最为常用的一种方式\",\"如果要匹配的切入点方法的方法名不规则，或者有一些比较特殊的需求，通过execution切入点表达式描述比较繁琐\",\"annotation 切入点表达式\",\"基于注解的方式来匹配切入点方法。这种方式虽然多一步操作，需要自定义一个注解，但是相对来比较灵活。需要匹配哪个方法，就在方法上加上对应的注解就可以了\"]},{\"header\":\"3.4 连接点\",\"slug\":\"_3-4-连接点\",\"contents\":[\"连接点可以简单理解为可以被AOP控制的方法。\",\"在SpringAOP当中，连接点又特指方法的执行。\",\"在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。\",\"对于@Around通知，获取连接点信息只能使用ProceedingJoinPoint类型\",\"对于其他四种通知，获取连接点信息只能使用JoinPoint，它是ProceedingJoinPoint的父类型\",\"示例代码：\",\"@Slf4j @Component @Aspect public class MyAspect7 { @Pointcut(\\\"@annotation(com.itheima.anno.MyLog)\\\") private void pt(){} //前置通知 @Before(\\\"pt()\\\") public void before(JoinPoint joinPoint){ log.info(joinPoint.getSignature().getName() + \\\" MyAspect7 -> before ...\\\"); } //后置通知 @Before(\\\"pt()\\\") public void after(JoinPoint joinPoint){ log.info(joinPoint.getSignature().getName() + \\\" MyAspect7 -> after ...\\\"); } //环绕通知 @Around(\\\"pt()\\\") public Object around(ProceedingJoinPoint pjp) throws Throwable { //获取目标类名 String name = pjp.getTarget().getClass().getName(); log.info(\\\"目标类名：{}\\\",name); //目标方法名 String methodName = pjp.getSignature().getName(); log.info(\\\"目标方法名：{}\\\",methodName); //获取方法执行时需要的参数 Object[] args = pjp.getArgs(); log.info(\\\"目标方法参数：{}\\\", Arrays.toString(args)); //执行原始方法 Object returnValue = pjp.proceed(); return returnValue; } } \",\"重新启动SpringBoot服务，执行查询部门数据的功能：\"]},{\"header\":\"4. AOP案例\",\"slug\":\"_4-aop案例\",\"contents\":[]},{\"header\":\"4.1 需求\",\"slug\":\"_4-1-需求\",\"contents\":[\"需求：将案例中增、删、改相关接口的操作日志记录到数据库表中\",\"就是当访问部门管理和员工管理当中的增、删、改相关功能接口时，需要详细的操作日志，并保存在数据表中，便于后期数据追踪。\",\"操作日志信息包含：\",\"操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长\",\"所记录的日志信息包括当前接口的操作人是谁操作的，什么时间点操作的，以及访问的是哪个类当中的哪个方法，在访问这个方法的时候传入进来的参数是什么，访问这个方法最终拿到的返回值是什么，以及整个接口方法的运行时长是多长时间。\"]},{\"header\":\"4.2 分析\",\"slug\":\"_4-2-分析\",\"contents\":[\"问题1：项目当中增删改相关的方法是不是有很多？\",\"很多\",\"问题2：需要针对每一个功能接口方法进行修改，在每一个功能接口当中都来记录这些操作日志吗？\",\"这种做法比较繁琐\",\"以上两个问题的解决方案：可以使用AOP解决(每一个增删改功能接口中要实现的记录操作日志的逻辑代码是相同)。\",\"可以把这部分记录操作日志的通用的、重复性的逻辑代码抽取出来定义在一个通知方法当中，通过AOP面向切面编程的方式，在不改动原始功能的基础上来对原始的功能进行增强。目前所增强的功能就是来记录操作日志，所以也可以使用AOP的技术来实现。使用AOP的技术来实现也是最为简单，最为方便的。\",\"问题3：既然要基于AOP面向切面编程的方式来完成的功能，那么要使用 AOP五种通知类型当中的哪种通知类型？\",\"答案：环绕通知\",\"所记录的操作日志当中包括：操作人、操作时间，访问的是哪个类、哪个方法、方法运行时参数、方法的返回值、方法的运行时长。\",\"方法返回值，是在原始方法执行后才能获取到的。\",\"方法的运行时长，需要原始方法运行之前记录开始时间，原始方法运行之后记录结束时间。通过计算获得方法的执行耗时。\",\"基于以上的分析确定要使用Around环绕通知。\",\"问题4：最后一个问题，切入点表达式该怎么写？\",\"答案：使用annotation来描述表达式\",\"要匹配业务接口当中所有的增删改的方法，而增删改方法在命名上没有共同的前缀或后缀。此时如果使用execution切入点表达式也可以，但是会比较繁琐。 当遇到增删改的方法名没有规律时，就可以使用 annotation切入点表达式\"]},{\"header\":\"4.3 步骤\",\"slug\":\"_4-3-步骤\",\"contents\":[\"案例的实现步骤其实就两步：\",\"准备工作 \",\"引入AOP的起步依赖\",\"导入数据库表结构，并引入对应的实体类\",\"编码实现 \",\"自定义注解@Log\",\"定义切面类，完成记录操作日志的逻辑\"]},{\"header\":\"4.4 实现\",\"slug\":\"_4-4-实现\",\"contents\":[]},{\"header\":\"4.4.1 准备工作\",\"slug\":\"_4-4-1-准备工作\",\"contents\":[\"AOP起步依赖\",\"<!--AOP起步依赖--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-aop</artifactId> </dependency> \",\"导入数据库表结构，并引入对应的实体类\",\"数据表\",\"-- 操作日志表 create table operate_log( id int unsigned primary key auto_increment comment 'ID', operate_user int unsigned comment '操作人', operate_time datetime comment '操作时间', class_name varchar(100) comment '操作的类名', method_name varchar(100) comment '操作的方法名', method_params varchar(1000) comment '方法参数', return_value varchar(2000) comment '返回值', cost_time bigint comment '方法执行耗时, 单位:ms' ) comment '操作日志表'; \",\"实体类\",\"//操作日志实体类 @Data @NoArgsConstructor @AllArgsConstructor public class OperateLog { private Integer id; //主键ID private Integer operateUser; //操作人ID private LocalDateTime operateTime; //操作时间 private String className; //操作类名 private String methodName; //操作方法名 private String methodParams; //操作方法参数 private String returnValue; //操作方法返回值 private Long costTime; //操作耗时 } \",\"Mapper接口\",\"@Mapper public interface OperateLogMapper { //插入日志数据 @Insert(\\\"insert into operate_log (operate_user, operate_time, class_name, method_name, method_params, return_value, cost_time) \\\" + \\\"values (#{operateUser}, #{operateTime}, #{className}, #{methodName}, #{methodParams}, #{returnValue}, #{costTime});\\\") public void insert(OperateLog log); } \"]},{\"header\":\"4.4.2 编码实现\",\"slug\":\"_4-4-2-编码实现\",\"contents\":[\"自定义注解@Log\",\"/** * 自定义Log注解 */ @Target({ElementType.METHOD}) @Documented @Retention(RetentionPolicy.RUNTIME) public @interface Log { } \",\"修改业务实现类，在增删改业务方法上添加@Log注解\",\"@Slf4j @Service public class EmpServiceImpl implements EmpService { @Autowired private EmpMapper empMapper; @Override @Log public void update(Emp emp) { emp.setUpdateTime(LocalDateTime.now()); //更新修改时间为当前时间 empMapper.update(emp); } @Override @Log public void save(Emp emp) { //补全数据 emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); //调用添加方法 empMapper.insert(emp); } @Override @Log public void delete(List<Integer> ids) { empMapper.delete(ids); } //省略其他代码... } \",\"以同样的方式，修改EmpServiceImpl业务类\",\"定义切面类，完成记录操作日志的逻辑\",\"@Slf4j @Component @Aspect //切面类 public class LogAspect { @Autowired private HttpServletRequest request; @Autowired private OperateLogMapper operateLogMapper; @Around(\\\"@annotation(com.itheima.anno.Log)\\\") public Object recordLog(ProceedingJoinPoint joinPoint) throws Throwable { //操作人ID - 当前登录员工ID //获取请求头中的jwt令牌, 解析令牌 String jwt = request.getHeader(\\\"token\\\"); Claims claims = JwtUtils.parseJWT(jwt); Integer operateUser = (Integer) claims.get(\\\"id\\\"); //操作时间 LocalDateTime operateTime = LocalDateTime.now(); //操作类名 String className = joinPoint.getTarget().getClass().getName(); //操作方法名 String methodName = joinPoint.getSignature().getName(); //操作方法参数 Object[] args = joinPoint.getArgs(); String methodParams = Arrays.toString(args); long begin = System.currentTimeMillis(); //调用原始目标方法运行 Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); //方法返回值 String returnValue = JSONObject.toJSONString(result); //操作耗时 Long costTime = end - begin; //记录操作日志 OperateLog operateLog = new OperateLog(null,operateUser,operateTime,className,methodName,methodParams,returnValue,costTime); operateLogMapper.insert(operateLog); log.info(\\\"AOP记录操作日志: {}\\\" , operateLog); return result; } } \",\"代码实现细节： 获取request对象，从请求头中获取到jwt令牌，解析令牌获取出当前用户的id。\",\"重启SpringBoot服务，测试操作日志记录功能：\",\"添加一个新的部门\",\"数据表\"]}]},\"/BackEnd/SpringBoot/springboot07.html\":{\"title\":\"SpringBoot原理\",\"contents\":[{\"header\":\"1. 配置优先级\",\"slug\":\"_1-配置优先级\",\"contents\":[\"SpringBoot项目当中支持的三类配置文件：\",\"application.properties\",\"application.yml\",\"application.yaml\",\"properties、yaml、yml三种配置文件同时存在\",\"properties、yaml、yml三种配置文件，优先级最高的是properties\",\"yaml、yml两种配置文件同时存在\",\"配置文件优先级排名（从高到低）：\",\"properties配置文件\",\"yml配置文件（主流）\",\"yaml配置文件\",\"在SpringBoot为了增强程序的扩展性，还支持另外两种常见的配置方式：\",\"Java系统属性配置 （格式： -Dkey=value）\",\"-Dserver.port=9000 \",\"命令行参数 （格式：--key=value）\",\"--server.port=10010 \",\"如何来指定Java系统属性和命令行参数呢？\",\"编辑启动程序的配置信息\",\"重启服务，同时配置Tomcat端口(三种配置文件、系统属性、命令行参数)，测试哪个Tomcat端口号生效：\",\"删除命令行参数配置，重启SpringBoot服务：\",\"优先级： 命令行参数 > 系统属性参数 > properties参数 > yml参数 > yaml参数\",\"思考：如果项目已经打包上线了，如何来设置Java系统属性和命令行参数呢？\",\"java -Dserver.port=9000 -jar XXXXX.jar --server.port=10010 \",\"演示打包程序运行时指定Java系统属性和命令行参数：\",\"执行maven打包指令package，把项目打成jar文件\",\"使用命令：java -jar 方式运行jar文件程序\",\"项目打包：\",\"运行jar程序：\",\"同时设置Java系统属性和命令行参数\",\"仅设置Java系统属性\",\"注意事项：\",\"Springboot项目进行打包时，需要引入插件 spring-boot-maven-plugin (基于官网骨架创建项目，会自动添加该插件)\"]},{\"header\":\"2. Bean管理\",\"slug\":\"_2-bean管理\",\"contents\":[\"Spring中的注解 @Component 以及三个衍生注解（@Controller、@Service、@Repository）来声明IOC容器中的bean对象\"]},{\"header\":\"2.1 获取Bean\",\"slug\":\"_2-1-获取bean\",\"contents\":[\"默认情况下，SpringBoot项目在启动的时候会自动的创建IOC容器(也称为Spring容器)，并且在启动的过程当中会自动的将bean对象都创建好，存放在IOC容器当中。应用程序在运行时需要依赖什么bean对象，就直接进行依赖注入就可以了。\",\"在Spring容器中提供了一些方法，可以主动从IOC容器中获取到bean对象，下面介绍3种常用方式：\",\"根据name获取bean\",\"Object getBean(String name) \",\"根据类型获取bean\",\"<T> T getBean(Class<T> requiredType) \",\"根据name获取bean（带类型转换）\",\"<T> T getBean(String name, Class<T> requiredType) \",\"思考：要从IOC容器当中来获取到bean对象，需要先拿到IOC容器对象，怎么样才能拿到IOC容器呢？\",\"想获取到IOC容器，直接将IOC容器对象注入进来就可以了\",\"控制器：DeptController\",\"@RestController @RequestMapping(\\\"/depts\\\") public class DeptController { @Autowired private DeptService deptService; public DeptController(){ System.out.println(\\\"DeptController constructor ....\\\"); } @GetMapping public Result list(){ List<Dept> deptList = deptService.list(); return Result.success(deptList); } @DeleteMapping(\\\"/{id}\\\") public Result delete(@PathVariable Integer id) { deptService.delete(id); return Result.success(); } @PostMapping public Result save(@RequestBody Dept dept){ deptService.save(dept); return Result.success(); } } \",\"业务实现类：DeptServiceImpl\",\"@Slf4j @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; @Override public List<Dept> list() { List<Dept> deptList = deptMapper.list(); return deptList; } @Override public void delete(Integer id) { deptMapper.delete(id); } @Override public void save(Dept dept) { dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.save(dept); } } \",\"Mapper接口：\",\"@Mapper public interface DeptMapper { //查询全部部门数据 @Select(\\\"select * from dept\\\") List<Dept> list(); //删除部门 @Delete(\\\"delete from dept where id = #{id}\\\") void delete(Integer id); //新增部门 @Insert(\\\"insert into dept(name, create_time, update_time) values (#{name},#{createTime},#{updateTime})\\\") void save(Dept dept); } \",\"测试类：\",\"@SpringBootTest class SpringbootWebConfig2ApplicationTests { @Autowired private ApplicationContext applicationContext; //IOC容器对象 //获取bean对象 @Test public void testGetBean(){ //根据bean的名称获取 DeptController bean1 = (DeptController) applicationContext.getBean(\\\"deptController\\\"); System.out.println(bean1); //根据bean的类型获取 DeptController bean2 = applicationContext.getBean(DeptController.class); System.out.println(bean2); //根据bean的名称 及 类型获取 DeptController bean3 = applicationContext.getBean(\\\"deptController\\\", DeptController.class); System.out.println(bean3); } } \",\"程序运行后控制台日志：\",\"问题：输出的bean对象地址值是一样的，说明IOC容器当中的bean对象有几个？\",\"答案：只有一个。 （默认情况下，IOC中的bean对象是单例）\",\"能不能将bean对象设置为非单例的(每次获取的bean都是一个新对象)？\",\"可以\",\"注意事项：\",\"上述所说的 【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。\"]},{\"header\":\"2.2 Bean作用域\",\"slug\":\"_2-2-bean作用域\",\"contents\":[\"默认bean对象是单例模式(只有一个实例对象)。那么如何设置bean对象为非单例呢？需要设置bean的作用域。\",\"在Spring中支持五种作用域，后三种在web环境才生效：\",\"作用域\",\"说明\",\"singleton\",\"容器内同名称的bean只有一个实例（单例）（默认）\",\"prototype\",\"每次使用该bean时会创建新的实例（非单例）\",\"request\",\"每个请求范围内会创建新的实例（web环境中，了解）\",\"session\",\"每个会话范围内会创建新的实例（web环境中，了解）\",\"application\",\"每个应用范围内会创建新的实例（web环境中，了解）\",\"借助Spring中的@Scope注解来进行配置作用域\",\"测试一:\",\"控制器\",\"//默认bean的作用域为：singleton (单例) @Lazy //延迟加载（第一次使用bean对象时，才会创建bean对象并交给ioc容器管理） @RestController @RequestMapping(\\\"/depts\\\") public class DeptController { @Autowired private DeptService deptService; public DeptController(){ System.out.println(\\\"DeptController constructor ....\\\"); } //省略其他代码... } \",\"测试类\",\"@SpringBootTest class SpringbootWebConfig2ApplicationTests { @Autowired private ApplicationContext applicationContext; //IOC容器对象 //bean的作用域 @Test public void testScope(){ for (int i = 0; i < 10; i++) { DeptController deptController = applicationContext.getBean(DeptController.class); System.out.println(deptController); } } } \",\"重启SpringBoot服务，运行测试方法，查看控制台打印的日志：\",\"注意事项：\",\"IOC容器中的bean默认使用的作用域：singleton (单例)\",\"默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化(延迟到第一次使用时)\",\"测试二:\",\"修改控制器DeptController代码：\",\"@Scope(\\\"prototype\\\") //bean作用域为非单例 @Lazy //延迟加载 @RestController @RequestMapping(\\\"/depts\\\") public class DeptController { @Autowired private DeptService deptService; public DeptController(){ System.out.println(\\\"DeptController constructor ....\\\"); } //省略其他代码... } \",\"重启SpringBoot服务，再次执行测试方法，查看控制台打印的日志：\",\"注意事项：\",\"prototype的bean，每一次使用该bean的时候都会创建一个新的实例\",\"实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性\"]},{\"header\":\"2.3 第三方Bean\",\"slug\":\"_2-3-第三方bean\",\"contents\":[\"像controller、service，dao三层体系下编写的类(自定义类)。要声明这些bean，只需要在类上加上@Component以及它的这三个衍生注解（@Controller、@Service、@Repository），就可以来声明这个bean对象了。 但是在我们项目开发当中，还有一种情况就是这个类它不是我们自己编写的，而是我们引入的第三方依赖当中提供的。\",\"在pom.xml文件中，引入dom4j：\",\"<!--Dom4j--> <dependency> <groupId>org.dom4j</groupId> <artifactId>dom4j</artifactId> <version>2.1.3</version> </dependency> \",\"dom4j就是第三方组织提供的。 dom4j中的SAXReader类就是第三方编写的。\",\"需要使用到SAXReader对象时，直接进行依赖注入是不是就可以了呢？\",\"按照之前的做法，需要在SAXReader类上添加一个注解@Component（将当前类交给IOC容器管理）\",\"结论：第三方提供的类是只读的。无法在第三方类上添加@Component注解或衍生注解。\",\"那么我们应该怎样使用并定义第三方的bean呢？\",\"如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component 及衍生注解声明bean的，就需要用到 @Bean 注解。\",\"解决方案1：在启动类上添加@Bean标识的方法:\",\"@SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } //声明第三方bean @Bean //将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean public SAXReader saxReader(){ return new SAXReader(); } } \",\"xml文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <emp> <name>Tom</name> <age>18</age> </emp> \",\"测试类：\",\"@SpringBootTest class SpringbootWebConfig2ApplicationTests { @Autowired private SAXReader saxReader; //第三方bean的管理 @Test public void testThirdBean() throws Exception { Document document = saxReader.read(this.getClass().getClassLoader().getResource(\\\"1.xml\\\")); Element rootElement = document.getRootElement(); String name = rootElement.element(\\\"name\\\").getText(); String age = rootElement.element(\\\"age\\\").getText(); System.out.println(name + \\\" : \\\" + age); } //省略其他代码... } \",\"重启SpringBoot服务，执行测试方法后，控制台输出日志：\",\"Tom : 18 \",\"说明：以上在启动类中声明第三方Bean的作法，不建议使用（项目中要保证启动类的纯粹性）\",\"解决方案2：在配置类中定义@Bean标识的方法:\",\"如果需要定义第三方Bean时， 通常会单独定义一个配置类\",\"@Configuration //配置类 (在配置类当中对第三方bean进行集中的配置管理) public class CommonConfig { //声明第三方bean @Bean //将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean //通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名 public SAXReader reader(DeptService deptService){ System.out.println(deptService); return new SAXReader(); } } \",\"注释掉SpringBoot启动类中创建第三方bean对象的代码，重启服务，执行测试方法，查看控制台日志：\",\"Tom : 18 \",\"在方法上加上一个@Bean注解，Spring 容器在启动的时候，它会自动的调用这个方法，并将方法的返回值声明为Spring容器当中的Bean对象。\",\"注意事项 ：\",\"通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名。\",\"如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。\",\"关于Bean保持一个原则：\",\"如果是在项目当中自己定义的类，想将这些类交给IOC容器管理，直接使用@Component以及它的衍生注解来声明就可以。\",\"如果这个类它不是自己定义的，而是引入的第三方依赖当中提供的类，而且还想将这个类交给IOC容器管理。在配置类中定义一个方法，在方法上加上一个@Bean注解，通过这种方式来声明第三方的bean对象。\"]},{\"header\":\"3. SpringBoot原理\",\"slug\":\"_3-springboot原理\",\"contents\":[\"繁琐主要体现在两个地方：\",\"在pom.xml中依赖配置比较繁琐，在项目开发时，需要自己去找到对应的依赖，还需要找到依赖它所配套的依赖以及对应版本，否则就会出现版本冲突问题。\",\"在使用Spring框架进行项目开发时，需要在Spring的配置文件中做大量的配置，这就造成Spring框架入门难度较大，学习成本较高。\",\"基于Spring存在的问题，官方在Spring框架4.0版本之后，又推出了一个全新的框架：SpringBoot。\",\"通过 SpringBoot来简化Spring框架的开发(是简化不是替代)\",\"SpringBoot框架之所以使用起来更简单更快捷，是因为SpringBoot框架底层提供了两个非常重要的功能：一个是起步依赖，一个是自动配置。\",\"通过SpringBoot所提供的起步依赖，就可以大大的简化pom文件当中依赖的配置，从而解决了Spring框架当中依赖配置繁琐的问题。\",\"通过自动配置的功能就可以大大的简化框架在使用时bean的声明以及bean的配置。只需要引入程序开发时所需要的起步依赖，项目开发时所用到常见的配置都已经有了，直接使用就可以了。\"]},{\"header\":\"3.1 起步依赖\",\"slug\":\"_3-1-起步依赖\",\"contents\":[\"假如用的是Spring框架进行web程序的开发，引入web程序开发所需要的一些依赖。\",\"spring-webmvc依赖：这是Spring框架进行web程序开发所需要的依赖\",\"servlet-api依赖：Servlet基础依赖\",\"jackson-databind依赖：JSON处理工具包\",\"如果要使用AOP，还需要引入aop依赖、aspect依赖\",\"项目中所引入的这些依赖，还需要保证版本匹配，否则就可能会出现版本冲突问题。\",\"SpringBoo只需要引入一个依赖就可以了，springboot-starter-web。\",\"为什么引入一个web开发的起步依赖，web开发所需要的所有的依赖都有了呢？\",\"因为Maven的依赖传递。\",\"在SpringBoot提供的这些起步依赖当中，已提供了当前程序开发所需要的所有的常见依赖(官网地址：[https://docs.spring.io/spring-boot/docs/2.7.7/reference/htmlsingle/#using.build-systems.starters])\",\"比如：springboot-starter-web，这是web开发的起步依赖，在web开发的起步依赖当中，就集成了web开发中常见的依赖：json、web、webmvc、tomcat等。只需要引入这一个起步依赖，其他的依赖都会自动的通过Maven的依赖传递进来。\",\"结论：起步依赖的原理就是Maven的依赖传递。\"]},{\"header\":\"3.2 自动配置\",\"slug\":\"_3-2-自动配置\",\"contents\":[]},{\"header\":\"3.2.1 概述\",\"slug\":\"_3-2-1-概述\",\"contents\":[\"SpringBoot的自动配置就是当Spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要手动去声明，从而简化了开发，省去了繁琐的配置操作。\",\"比如：要进行事务管理、要进行AOP程序的开发，此时就不需要再去手动的声明这些bean对象了\",\"运行SpringBoot启动类\",\"有两个CommonConfig，在第一个CommonConfig类中定义了一个bean对象，bean对象的名字叫reader。\",\"在第二个CommonConfig中它的bean名字叫commonConfig，为什么还会有这样一个bean对象呢？原因是在CommonConfig配置类上添加了一个注解@Configuration，而@Configuration底层就是@Component\",\"所以配置类最终也是SpringIOC容器当中的一个bean对象\",\"在IOC容器中除了自己定义的bean以外，还有很多SpringBoot在启动的时候加载进来的配置类。这些配置类加载进来之后，也会生成很多的bean对象。\",\"比如：配置类GsonAutoConfiguration里面有一个bean，bean的名字叫gson，它的类型是Gson。\",\"com.google.gson.Gson是谷歌包中提供的用来处理JSON格式数据的。\",\"使用这些配置类中生成的bean对象时，使用@Autowired就自动注入了：\",\"import com.google.gson.Gson; import com.itheima.pojo.Result; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class AutoConfigurationTests { @Autowired private Gson gson; @Test public void testJson(){ String json = gson.toJson(Result.success()); System.out.println(json); } } \",\"添加断点，使用debug模式运行测试类程序：\",\"问题：项目中并没有声明谷歌提供的Gson这么一个bean对象，却可以通过@Autowired从Spring容器中注入bean对象，那么这个bean对象怎么来的？\",\"答案：SpringBoot项目在启动时通过自动配置完成了bean对象的创建。\"]},{\"header\":\"3.2.2 常见方案\",\"slug\":\"_3-2-2-常见方案\",\"contents\":[\"引入对应的依赖之后，是如何将依赖jar包当中所提供的bean以及配置类直接加载到当前项目的SpringIOC容器当中的。\",\"准备工作：在Idea中导入\\\"资料\\\\03. 自动配置原理\\\"下的itheima-utils工程\",\"1、在SpringBoot项目 spring-boot-web-config2 工程中，通过坐标引入itheima-utils依赖\",\"@Component public class TokenParser { public void parse(){ System.out.println(\\\"TokenParser ... parse ...\\\"); } } \",\"2、在测试类中，添加测试方法\",\"@SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testTokenParse(){ System.out.println(applicationContext.getBean(TokenParser.class)); } //省略其他代码... } \",\"3、执行测试方法\",\"异常信息描述： 没有com.example.TokenParse类型的bean\",\"说明：在Spring容器中没有找到com.example.TokenParse类型的bean对象\",\"思考：引入进来的第三方依赖当中的bean以及配置类为什么没有生效？\",\"在类上添加@Component注解来声明bean对象时，还需要保证@Component注解能被Spring的组件扫描到。\",\"SpringBoot项目中的@SpringBootApplication注解，具有包扫描的作用，但是它只会扫描启动类所在的当前包以及子包。\",\"当前包：com.itheima， 第三方依赖中提供的包：com.example（扫描不到）\",\"那么如何解决以上问题的呢？\",\"方案1：@ComponentScan 组件扫描\",\"方案2：@Import 导入（使用@Import导入的类会被Spring加载到IOC容器中）\"]},{\"header\":\"3.2.2.2 方案一\",\"slug\":\"_3-2-2-2-方案一\",\"contents\":[\"@ComponentScan组件扫描\",\"@SpringBootApplication @ComponentScan({\\\"com.itheima\\\",\\\"com.example\\\"}) //指定要扫描的包 public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } \",\"重新执行测试方法，控制台日志输出：\",\"缺点：\",\"使用繁琐\",\"性能低\",\"方案二：\",\"@Import导入\",\"导入形式主要有以下几种： \",\"导入普通类\",\"导入配置类\",\"导入ImportSelector接口实现类\",\"1). 使用@Import导入普通类：\",\"@Import(TokenParser.class) //导入的类会被Spring加载到IOC容器中 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } \",\"重新执行测试方法，控制台日志输出：\",\"2). 使用@Import导入配置类：\",\"配置类\",\"@Configuration public class HeaderConfig { @Bean public HeaderParser headerParser(){ return new HeaderParser(); } @Bean public HeaderGenerator headerGenerator(){ return new HeaderGenerator(); } } \",\"启动类\",\"@Import(HeaderConfig.class) //导入配置类 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } \",\"测试类\",\"@SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } @Test public void testHeaderGenerator(){ System.out.println(applicationContext.getBean(HeaderGenerator.class)); } //省略其他代码... } \",\"执行测试方法：\",\"3). 使用@Import导入ImportSelector接口实现类：\",\"ImportSelector接口实现类\",\"public class MyImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { //返回值字符串数组（数组中封装了全限定名称的类） return new String[]{\\\"com.example.HeaderConfig\\\"}; } } \",\"启动类\",\"@Import(MyImportSelector.class) //导入ImportSelector接口实现类 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } \",\"执行测试方法：\",\"使用@Import注解通过这三种方式都可以导入第三方依赖中所提供的bean或者是配置类。\",\"思考：如果基于以上方式完成自动配置，当要引入一个第三方依赖时，是不是还要知道第三方依赖中有哪些配置类和哪些Bean对象？\",\"答案：是的。 （对程序员来讲，很不友好，而且比较繁琐）\",\"思考：当我们要使用第三方依赖，依赖中到底有哪些bean和配置类，谁最清楚？\",\"答案：第三方依赖自身最清楚。\",\"结论：我们不用自己指定要导入哪些bean对象和配置类了，让第三方依赖它自己来指定。\",\"怎么让第三方依赖自己指定bean对象和配置类？\",\"比较常见的方案就是第三方依赖给我们提供一个注解，这个注解一般都以@EnableXxxx开头的注解，注解中封装的就是@Import注解\",\"4). 使用第三方依赖提供的 @EnableXxxxx注解\",\"第三方依赖中提供的注解\",\"@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) @Import(MyImportSelector.class)//指定要导入哪些bean对象或配置类 public @interface EnableHeaderConfig { } \",\"在使用时只需在启动类上加上@EnableXxxxx注解即可\",\"@EnableHeaderConfig //使用第三方依赖提供的Enable开头的注解 @SpringBootApplication public class SpringbootWebConfig2Application { public static void main(String[] args) { SpringApplication.run(SpringbootWebConfig2Application.class, args); } } \",\"执行测试方法：\",\"以上四种方式都可以完成导入操作，但是第4种方式会更方便更优雅，而这种方式也是SpringBoot当中所采用的方式。\"]},{\"header\":\"3.2.3 原理分析\",\"slug\":\"_3-2-3-原理分析\",\"contents\":[]},{\"header\":\"3.2.3.1 源码跟踪\",\"slug\":\"_3-2-3-1-源码跟踪\",\"contents\":[\"前面我们讲解了在项目当中引入第三方依赖之后，如何加载第三方依赖中定义好的bean对象以及配置类，从而完成自动配置操作。那下面我们通过源码跟踪的形式来剖析下SpringBoot底层到底是如何完成自动配置的。\",\"源码跟踪技巧：\",\"在跟踪框架源码的时候，一定要抓住关键点，找到核心流程。一定不要从头到尾一行代码去看，一个方法的去研究，一定要找到关键流程，抓住关键点，先在宏观上对整个流程或者整个原理有一个认识，有精力再去研究其中的细节。\",\"要搞清楚SpringBoot的自动配置原理，要从SpringBoot启动类上使用的核心注解@SpringBootApplication开始分析：\",\"在@SpringBootApplication注解中包含了：\",\"元注解（不再解释）\",\"@SpringBootConfiguration\",\"@EnableAutoConfiguration\",\"@ComponentScan\",\"我们先来看第一个注解：@SpringBootConfiguration\",\"@SpringBootConfiguration注解上使用了@Configuration，表明SpringBoot启动类就是一个配置类。\",\"@Indexed注解，是用来加速应用启动的（不用关心）。\",\"接下来再先看@ComponentScan注解：\",\"@ComponentScan注解是用来进行组件扫描的，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。\",\"SpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解。\",\"最后我们来看看@EnableAutoConfiguration注解（自动配置核心注解）：\",\"使用@Import注解，导入了实现ImportSelector接口的实现类。\",\"AutoConfigurationImportSelector类是ImportSelector接口的实现类。\",\"AutoConfigurationImportSelector类中重写了ImportSelector接口的selectImports()方法：\",\"selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合\",\"getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合\",\"getCandidateConfigurations方法的功能：\",\"获取所有基于META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件、META-INF/spring.factories文件中配置类的集合\",\"META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件和META-INF/spring.factories文件这两个文件在哪里呢？\",\"通常在引入的起步依赖中，都有包含以上两个文件\",\"在前面在给大家演示自动配置的时候，我们直接在测试类当中注入了一个叫gson的bean对象，进行JSON格式转换。虽然我们没有配置bean对象，但是我们是可以直接注入使用的。原因就是因为在自动配置类当中做了自动配置。到底是在哪个自动配置类当中做的自动配置呢？我们通过搜索来查询一下。\",\"在META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports配置文件中指定了第三方依赖Gson的配置类：GsonAutoConfiguration\",\"第三方依赖中提供的GsonAutoConfiguration类：\",\"在GsonAutoConfiguration类上，添加了注解@AutoConfiguration，通过查看源码，可以明确：GsonAutoConfiguration类是一个配置。\",\"看到这里，大家就应该明白为什么可以完成自动配置了，原理就是在配置类中定义一个@Bean标识的方法，而Spring会自动调用配置类中使用@Bean标识的方法，并把方法的返回值注册到IOC容器中。\",\"自动配置源码小结:\",\"自动配置原理源码入口就是@SpringBootApplication注解，在这个注解中封装了3个注解，分别是：\",\"@SpringBootConfiguration \",\"声明当前类是一个配置类\",\"@ComponentScan \",\"进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包）\",\"@EnableAutoConfiguration \",\"封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类） \",\"在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中META-INF/spring.factories、META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。\",\"当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。\",\"最后呢给大家抛出一个问题：在META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，那这些bean都会注册到Spring的IOC容器中吗？\",\"答案：并不是。 在声明bean对象时，上面有加一个以@Conditional开头的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）\"]},{\"header\":\"3.2.3.2 @Conditional\",\"slug\":\"_3-2-3-2-conditional\",\"contents\":[\"我们在跟踪SpringBoot自动配置的源码的时候，在自动配置类声明bean的时候，除了在方法上加了一个@Bean注解以外，还会经常用到一个注解，就是以Conditional开头的这一类的注解。以Conditional开头的这些注解都是条件装配的注解。下面我们就来介绍下条件装配注解。\",\"@Conditional注解：\",\"作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring的IOC容器中。\",\"位置：方法、类\",\"@Conditional本身是一个父注解，派生出大量的子注解： \",\"@ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器。\",\"@ConditionalOnMissingBean：判断环境中没有对应的bean(类型或名称)，才注册bean到IOC容器。\",\"@ConditionalOnProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器。\",\"下面我们通过代码来演示下Conditional注解的使用：\",\"@ConditionalOnClass注解\",\"@Configuration public class HeaderConfig { @Bean @ConditionalOnClass(name=\\\"io.jsonwebtoken.Jwts\\\")//环境中存在指定的这个类，才会将该bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } //省略其他代码... } \",\"pom.xml\",\"<!--JWT令牌--> <dependency> <groupId>io.jsonwebtoken</groupId> <artifactId>jjwt</artifactId> <version>0.9.1</version> </dependency> \",\"测试类\",\"@SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } //省略其他代码... } \",\"执行testHeaderParser()测试方法：\",\"因为io.jsonwebtoken.Jwts字节码文件在启动SpringBoot程序时已存在，所以创建HeaderParser对象并注册到IOC容器中。\",\"@ConditionalOnMissingBean注解\",\"@Configuration public class HeaderConfig { @Bean @ConditionalOnMissingBean //不存在该类型的bean，才会将该bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } //省略其他代码... } \",\"执行testHeaderParser()测试方法：\",\"SpringBoot在调用@Bean标识的headerParser()前，IOC容器中是没有HeaderParser类型的bean，所以HeaderParser对象正常创建，并注册到IOC容器中。\",\"再次修改@ConditionalOnMissingBean注解：\",\"@Configuration public class HeaderConfig { @Bean @ConditionalOnMissingBean(name=\\\"deptController2\\\")//不存在指定名称的bean，才会将该bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } //省略其他代码... } \",\"执行testHeaderParser()测试方法：\",\"因为在SpringBoot环境中不存在名字叫deptController2的bean对象，所以创建HeaderParser对象并注册到IOC容器中。\",\"再次修改@ConditionalOnMissingBean注解：\",\"@Configuration public class HeaderConfig { @Bean @ConditionalOnMissingBean(HeaderConfig.class)//不存在指定类型的bean，才会将bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } //省略其他代码... } \",\"@SpringBootTest public class AutoConfigurationTests { @Autowired private ApplicationContext applicationContext; @Test public void testHeaderParser(){ System.out.println(applicationContext.getBean(HeaderParser.class)); } //省略其他代码... } \",\"执行testHeaderParser()测试方法：\",\"因为HeaderConfig类中添加@Configuration注解，而@Configuration注解中包含了@Component，所以SpringBoot启动时会创建HeaderConfig类对象，并注册到IOC容器中。\",\"当IOC容器中有HeaderConfig类型的bean存在时，不会把创建HeaderParser对象注册到IOC容器中。而IOC容器中没有HeaderParser类型的对象时，通过getBean(HeaderParser.class)方法获取bean对象时，引发异常：NoSuchBeanDefinitionException\",\"@ConditionalOnProperty注解（这个注解和配置文件当中配置的属性有关系）\",\"先在application.yml配置文件中添加如下的键值对：\",\"name: itheima \",\"在声明bean的时候就可以指定一个条件@ConditionalOnProperty\",\"@Configuration public class HeaderConfig { @Bean @ConditionalOnProperty(name =\\\"name\\\",havingValue = \\\"itheima\\\")//配置文件中存在指定属性名与值，才会将bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } @Bean public HeaderGenerator headerGenerator(){ return new HeaderGenerator(); } } \",\"执行testHeaderParser()测试方法：\",\"修改@ConditionalOnProperty注解： havingValue的值修改为\\\"itheima2\\\"\",\"@Bean @ConditionalOnProperty(name =\\\"name\\\",havingValue = \\\"itheima2\\\")//配置文件中存在指定属性名与值，才会将bean加入IOC容器 public HeaderParser headerParser(){ return new HeaderParser(); } \",\"再次执行testHeaderParser()测试方法：\",\"因为application.yml配置文件中，不存在： name: itheima2，所以HeaderParser对象在IOC容器中不存在\",\"我们再回头看看之前讲解SpringBoot源码时提到的一个配置类：GsonAutoConfiguration\",\"最后再给大家梳理一下自动配置原理：\",\"自动配置的核心就在@SpringBootApplication注解上，SpringBootApplication这个注解底层包含了3个注解，分别是：\",\"@SpringBootConfiguration\",\"@ComponentScan\",\"@EnableAutoConfiguration\",\"@EnableAutoConfiguration这个注解才是自动配置的核心。\",\"它封装了一个@Import注解，Import注解里面指定了一个ImportSelector接口的实现类。\",\"在这个实现类中，重写了ImportSelector接口中的selectImports()方法。\",\"而selectImports()方法中会去读取两份配置文件，并将配置文件中定义的配置类做为selectImports()方法的返回值返回，返回值代表的就是需要将哪些类交给Spring的IOC容器进行管理。\",\"那么所有自动配置类的中声明的bean都会加载到Spring的IOC容器中吗? 其实并不会，因为这些配置类中在声明bean时，通常都会添加@Conditional开头的注解，这个注解就是进行条件装配。而Spring会根据Conditional注解有选择性的进行bean的创建。\",\"@Enable 开头的注解底层，它就封装了一个注解 import 注解，它里面指定了一个类，是 ImportSelector 接口的实现类。在实现类当中，我们需要去实现 ImportSelector 接口当中的一个方法 selectImports 这个方法。这个方法的返回值代表的就是我需要将哪些类交给 spring 的 IOC容器进行管理。\",\"此时它会去读取两份配置文件，一份儿是 spring.factories，另外一份儿是 autoConfiguration.imports。而在 autoConfiguration.imports 这份儿文件当中，它就会去配置大量的自动配置的类。\",\"而前面我们也提到过这些所有的自动配置类当中，所有的 bean都会加载到 spring 的 IOC 容器当中吗？其实并不会，因为这些配置类当中，在声明 bean 的时候，通常会加上这么一类@Conditional 开头的注解。这个注解就是进行条件装配。所以SpringBoot非常的智能，它会根据 @Conditional 注解来进行条件装配。只有条件成立，它才会声明这个bean，才会将这个 bean 交给 IOC 容器管理。\"]},{\"header\":\"3.2.4 案例\",\"slug\":\"_3-2-4-案例\",\"contents\":[]},{\"header\":\"3.2.4.1 自定义starter分析\",\"slug\":\"_3-2-4-1-自定义starter分析\",\"contents\":[\"前面我们解析了SpringBoot中自动配置的原理，下面我们就通过一个自定义starter案例来加深大家对于自动配置原理的理解。首先介绍一下自定义starter的业务场景，再来分析一下具体的操作步骤。\",\"所谓starter指的就是SpringBoot当中的起步依赖。在SpringBoot当中已经给我们提供了很多的起步依赖了，我们为什么还需要自定义 starter 起步依赖？这是因为在实际的项目开发当中，我们可能会用到很多第三方的技术，并不是所有的第三方的技术官方都给我们提供了与SpringBoot整合的starter起步依赖，但是这些技术又非常的通用，在很多项目组当中都在使用。\",\"业务场景：\",\"我们前面案例当中所使用的阿里云OSS对象存储服务，现在阿里云的官方是没有给我们提供对应的起步依赖的，这个时候使用起来就会比较繁琐，我们需要引入对应的依赖。我们还需要在配置文件当中进行配置，还需要基于官方SDK示例来改造对应的工具类，我们在项目当中才可以进行使用。\",\"大家想在我们当前项目当中使用了阿里云OSS，我们需要进行这么多步的操作。在别的项目组当中要想使用阿里云OSS，是不是也需要进行这么多步的操作，所以这个时候我们就可以自定义一些公共组件，在这些公共组件当中，我就可以提前把需要配置的bean都提前配置好。将来在项目当中，我要想使用这个技术，我直接将组件对应的坐标直接引入进来，就已经自动配置好了，就可以直接使用了。我们也可以把公共组件提供给别的项目组进行使用，这样就可以大大的简化我们的开发。\",\"在SpringBoot项目中，一般都会将这些公共组件封装为SpringBoot当中的starter，也就是我们所说的起步依赖。\",\"SpringBoot官方starter命名： spring-boot-starter-xxxx\",\"第三组织提供的starter命名： xxxx-spring-boot-starter\",\"Mybatis提供了配置类，并且也提供了springboot会自动读取的配置文件。当SpringBoot项目启动时，会读取到spring.factories配置文件中的配置类并加载配置类，生成相关bean对象注册到IOC容器中。\",\"结果：我们可以直接在SpringBoot程序中使用Mybatis自动配置的bean对象。\",\"在自定义一个起步依赖starter的时候，按照规范需要定义两个模块：\",\"starter模块（进行依赖管理[把程序开发所需要的依赖都定义在starter起步依赖中]）\",\"autoconfigure模块（自动配置）\",\"将来在项目当中进行相关功能开发时，只需要引入一个起步依赖就可以了，因为它会将autoconfigure自动配置的依赖给传递下来。\",\"上面我们简单介绍了自定义starter的场景，以及自定义starter时涉及到的模块之后，接下来我们就来完成一个自定义starter的案例。\",\"需求：自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类AliyunOSSUtils的自动配置。\",\"目标：引入起步依赖引入之后，要想使用阿里云OSS，注入AliyunOSSUtils直接使用即可。\",\"之前阿里云OSS的使用：\",\"配置文件\",\"#配置阿里云OSS参数 aliyun: oss: endpoint: https://oss-cn-shanghai.aliyuncs.com accessKeyId: LTAI5t9MZK8iq5T2Av5GLDxX accessKeySecret: C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc bucketName: web-framework01 \",\"AliOSSProperties类\",\"@Data @Component @ConfigurationProperties(prefix = \\\"aliyun.oss\\\") public class AliOSSProperties { //区域 private String endpoint; //身份ID private String accessKeyId ; //身份密钥 private String accessKeySecret ; //存储空间 private String bucketName; } \",\"AliOSSUtils工具类\",\"@Component //当前类对象由Spring创建和管理 public class AliOSSUtils { @Autowired private AliOSSProperties aliOSSProperties; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\\\".\\\")); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //文件访问路径 String url =aliOSSProperties.getEndpoint().split(\\\"//\\\")[0] + \\\"//\\\" + aliOSSProperties.getBucketName() + \\\".\\\" + aliOSSProperties.getEndpoint().split(\\\"//\\\")[1] + \\\"/\\\" + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } \",\"当我们在项目当中要使用阿里云OSS，就可以注入AliOSSUtils工具类来进行文件上传。但这种方式其实是比较繁琐的。\",\"大家再思考，现在我们使用阿里云OSS，需要做这么几步，将来大家在开发其他的项目的时候，你使用阿里云OSS，这几步你要不要做？当团队中其他小伙伴也在使用阿里云OSS的时候，步骤 不也是一样的。\",\"所以这个时候我们就可以制作一个公共组件(自定义starter)。starter定义好之后，将来要使用阿里云OSS进行文件上传，只需要将起步依赖引入进来之后，就可以直接注入AliOSSUtils使用了。\",\"需求明确了，接下来我们再来分析一下具体的实现步骤：\",\"第1步：创建自定义starter模块（进行依赖管理） \",\"把阿里云OSS所有的依赖统一管理起来\",\"第2步：创建autoconfigure模块 \",\"在starter中引入autoconfigure （我们使用时只需要引入starter起步依赖即可）\",\"第3步：在autoconfigure中完成自动配置 \",\"定义一个自动配置类，在自动配置类中将所要配置的bean都提前配置好\",\"定义配置文件，把自动配置类的全类名定义在配置文件中\",\"我们分析完自定义阿里云OSS自动配置的操作步骤了，下面我们就按照分析的步骤来实现自定义starter。\"]},{\"header\":\"3.2.4.2 自定义starter实现\",\"slug\":\"_3-2-4-2-自定义starter实现\",\"contents\":[\"自定义starter的步骤我们刚才已经分析了，接下来我们就按照分析的步骤来完成自定义starter的开发。\",\"首先我们先来创建两个Maven模块：\",\"1). aliyun-oss-spring-boot-starter模块\",\"创建完starter模块后，删除多余的文件，最终保留内容如下：\",\"删除pom.xml文件中多余的内容后：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven. apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.7.5</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-oss-spring-boot-starter</artifactId> <version>0.0.1-SNAPSHOT</version> <properties> <java.version>11</java.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> </dependencies> </project> \",\"2). aliyun-oss-spring-boot-autoconfigure模块\",\"创建完starter模块后，删除多余的文件，最终保留内容如下：\",\"删除pom.xml文件中多余的内容后：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven. apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.7.5</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-oss-spring-boot-autoconfigure</artifactId> <version>0.0.1-SNAPSHOT</version> <properties> <java.version>11</java.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> </dependencies> </project> \",\"按照我们之前的分析，是需要在starter模块中来引入autoconfigure这个模块的。打开starter模块中的pom文件：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven. apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.7.5</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-oss-spring-boot-starter</artifactId> <version>0.0.1-SNAPSHOT</version> <properties> <java.version>11</java.version> </properties> <dependencies> <!--引入autoconfigure模块--> <dependency> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-oss-spring-boot-autoconfigure</artifactId> <version>0.0.1-SNAPSHOT</version> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> </dependencies> </project> \",\"前两步已经完成了，接下来是最关键的就是第三步：\",\"在autoconfigure模块当中来完成自动配置操作。\",\"我们将之前案例中所使用的阿里云OSS部分的代码直接拷贝到autoconfigure模块下，然后进行改造就行了。\",\"拷贝过来后，还缺失一些相关的依赖，需要把相关依赖也拷贝过来：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven. apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.7.5</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-oss-spring-boot-autoconfigure</artifactId> <version>0.0.1-SNAPSHOT</version> <properties> <java.version>11</java.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <!--引入web起步依赖--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!--Lombok--> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> <!--阿里云OSS--> <dependency> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-sdk-oss</artifactId> <version>3.15.1</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> <dependency> <groupId>javax.activation</groupId> <artifactId>activation</artifactId> <version>1.1.1</version> </dependency> <!-- no more than 2.3.3--> <dependency> <groupId>org.glassfish.jaxb</groupId> <artifactId>jaxb-runtime</artifactId> <version>2.3.3</version> </dependency> </dependencies> </project> \",\"现在大家思考下，在类上添加的@Component注解还有用吗？\",\"答案：没用了。 在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。\",\"@Component注解不需要使用了，可以从类上删除了。\",\"删除后报红色错误，暂时不理会，后面再来处理。\",\"删除AliOSSUtils类中的@Component注解、@Autowired注解\",\"下面我们就要定义一个自动配置类了，在自动配置类当中来声明AliOSSUtils的bean对象。\",\"AliOSSAutoConfiguration类：\",\"@Configuration//当前类为Spring配置类 @EnableConfigurationProperties(AliOSSProperties.class)//导入AliOSSProperties类，并交给SpringIOC管理 public class AliOSSAutoConfiguration { //创建AliOSSUtils对象，并交给SpringIOC容器 @Bean public AliOSSUtils aliOSSUtils(AliOSSProperties aliOSSProperties){ AliOSSUtils aliOSSUtils = new AliOSSUtils(); aliOSSUtils.setAliOSSProperties(aliOSSProperties); return aliOSSUtils; } } \",\"AliOSSProperties类：\",\"/*阿里云OSS相关配置*/ @Data @ConfigurationProperties(prefix = \\\"aliyun.oss\\\") public class AliOSSProperties { //区域 private String endpoint; //身份ID private String accessKeyId ; //身份密钥 private String accessKeySecret ; //存储空间 private String bucketName; } \",\"AliOSSUtils类：\",\"@Data public class AliOSSUtils { private AliOSSProperties aliOSSProperties; /** * 实现上传图片到OSS */ public String upload(MultipartFile multipartFile) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = multipartFile.getInputStream(); // 避免文件覆盖 String originalFilename = multipartFile.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\\\".\\\")); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(aliOSSProperties.getEndpoint(), aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret()); ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream); //文件访问路径 String url =aliOSSProperties.getEndpoint().split(\\\"//\\\")[0] + \\\"//\\\" + aliOSSProperties.getBucketName() + \\\".\\\" + aliOSSProperties.getEndpoint().split(\\\"//\\\")[1] + \\\"/\\\" + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } \",\"在aliyun-oss-spring-boot-autoconfigure模块中的resources下，新建自动配置文件：\",\"META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\",\"com.aliyun.oss.AliOSSAutoConfiguration \"]},{\"header\":\"3.2.4.3 自定义starter测试\",\"slug\":\"_3-2-4-3-自定义starter测试\",\"contents\":[\"阿里云OSS的starter我们刚才已经定义好了，接下来我们就来做一个测试。\",\"今天的课程资料当中，提供了一个自定义starter的测试工程。我们直接打开文件夹，里面有一个测试工程。测试工程就是springboot-autoconfiguration-test，我们只需要将测试工程直接导入到Idea当中即可。\",\"测试前准备：\",\"在test工程中引入阿里云starter依赖\",\"通过依赖传递，会把autoconfigure依赖也引入了\",\"<!--引入阿里云OSS起步依赖--> <dependency> <groupId>com.aliyun.oss</groupId> <artifactId>aliyun-oss-spring-boot-starter</artifactId> <version>0.0.1-SNAPSHOT</version> </dependency> \",\"在test工程中的application.yml文件中，配置阿里云OSS配置参数信息（从以前的工程中拷贝即可）\",\"#配置阿里云OSS参数 aliyun: oss: endpoint: https://oss-cn-shanghai.aliyuncs.com accessKeyId: LTAI5t9MZK8iq5T2Av5GLDxX accessKeySecret: C0IrHzKZGKqU8S7YQcevcotD3Zd5Tc bucketName: web-framework01 \",\"在test工程中的UploadController类编写代码\",\"@RestController public class UploadController { @Autowired private AliOSSUtils aliOSSUtils; @PostMapping(\\\"/upload\\\") public String upload(MultipartFile image) throws Exception { //上传文件到阿里云 OSS String url = aliOSSUtils.upload(image); return url; } } \",\"编写完代码后，我们启动当前的SpringBoot测试工程：\",\"随着SpringBoot项目启动，自动配置会把AliOSSUtils的bean对象装配到IOC容器中\",\"用postman工具进行文件上传：\",\"通过断点可以看到自动注入AliOSSUtils的bean对象：\"]},{\"header\":\"4. Web后端开发总结\",\"slug\":\"_4-web后端开发总结\",\"contents\":[\"web后端开发现在基本上都是基于标准的三层架构进行开发的\",\"三层架构\",\"Controller控制器层 负责接收请求响应数据\",\"Service业务层 负责具体的业务逻辑处理\",\"Dao数据访问层 也叫持久层，就是用来处理数据访问操作的，来完成数据库当中数据的增删改查操作。\",\"在三层架构当中，前端发起请求首先会到达Controller(不进行逻辑处理)，然后Controller会直接调用Service 进行逻辑处理， Service再调用Dao完成数据访问操作。\",\"在执行具体的业务处理之前，需要去做一些通用的业务处理 比如：进行统一的登录校验，进行统一的字符编码等这些操作时，就可以借助于Javaweb当中三大组件之一的过滤器Filter或者是Spring当中提供的拦截器Interceptor来实现。\",\"为了实现三层架构层与层之间的解耦，Spring框架当中的第一大核心：IOC控制反转与DI依赖注入。\",\"控制反转，指的是将对象创建的控制权由应用程序自身交给外部容器，这个容器就是常说的IOC容器或Spring容器。\",\"DI依赖注入指的是容器为程序提供运行时所需要的资源。\",\"AOP面向切面编程，还有Spring中的事务管理、全局异常处理器，以及传递会话技术Cookie、Session以及新的会话跟踪解决方案JWT令牌，阿里云OSS对象存储服务，以及通过Mybatis持久层架构操作数据库等技术。\",\"Filter过滤器、Cookie、 Session这些都是传统的JavaWeb提供的技术。\",\"JWT令牌、阿里云OSS对象存储服务，是现在企业项目中常见的一些解决方案。\",\"IOC控制反转、DI依赖注入、AOP面向切面编程、事务管理、全局异常处理、拦截器等，这些技术都是 Spring Framework框架当中提供的核心功能。\",\"Mybatis就是一个持久层的框架，是用来操作数据库的。\",\"在Spring框架的生态中，对web程序开发提供了很好的支持，如：全局异常处理器、拦截器这些都是Spring框架中web开发模块所提供的功能，而Spring框架的web开发模块，我们也称为：SpringMVC\",\"SpringMVC不是一个单独的框架，它是Spring框架的一部分，是Spring框架中的web开发模块，是用来简化原始的Servlet程序开发的。\",\"外界俗称的SSM，就是由：SpringMVC、Spring Framework、Mybatis三块组成。\",\"基于传统的SSM框架进行整合开发项目会比较繁琐，而且效率也比较低，所以在现在的企业项目开发当中，基本上都是直接基于SpringBoot整合SSM进行项目开发的。\"]}]},\"/BackEnd/SpringBoot/springboot08.html\":{\"title\":\"SpringBoot整合\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"掌握基于SpringBoot框架的程序开发步骤\",\"熟练使用SpringBoot配置信息修改服务器配置\",\"基于SpringBoot的完成SSM整合项目开发\"]},{\"header\":\"1 SpringBoot简介\",\"slug\":\"_1-springboot简介\",\"contents\":[\"SpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化 Spring 应用的初始搭建以及开发过程\",\"回顾一下 SpringMVC 开发\",\"创建工程，并在 pom.xml 配置文件中配置所依赖的坐标\",\"编写 web3.0 的配置类\",\"作为 web 程序，web3.0 的配置类不能缺少，而这个配置类还是比较麻烦的\",\"编写 SpringMVC 的配置类\",\"​做到这只是将工程的架子搭起来，要想被外界访问，最起码还需要提供一个 Controller 类，在该类中提供一个方法\",\"编写 Controller 类\",\"从上面的 SpringMVC 程序开发可以看到，前三步都是在搭建环境，而且这三步基本都是固定的 SpringBoot 就是对这三步进行简化了\"]},{\"header\":\"1.1 SpringBoot快速入门\",\"slug\":\"_1-1-springboot快速入门\",\"contents\":[]},{\"header\":\"1.1.1 开发步骤\",\"slug\":\"_1-1-1-开发步骤\",\"contents\":[\"SpringBoot 开发步骤\",\"创建新模块，选择Spring初始化，并配置模块相关基础信息\",\"选择当前模块需要使用的技术集\",\"开发控制器类\",\"运行自动生成的Application类\"]},{\"header\":\"1.1.1.1 创建新模块\",\"slug\":\"_1-1-1-1-创建新模块\",\"contents\":[\"点击 + 选择 New Module 创建新模块\",\"选择 Spring Initializr ，用来创建 SpringBoot 工程\",\"对 SpringBoot 工程进行相关的设置\",\"这种方式构建的 SpringBoot 工程其实也是 Maven 工程，而该方式只是一种快速构建的方式而已\",\"注意：打包方式这里需要设置为 Jar\",\"选中 Web，然后勾选 Spring Web\",\"直接点击 Finish 完成 SpringBoot 工程的构建\",\"经过以上步骤后就创建了如下结构的模块，它会帮我们自动生成一个 Application 类，而该类一会再启动服务器时会用到\",\"注意\",\"在创建好的工程中不需要创建配置类\",\"创建好的项目会自动生成其他的一些文件，而这些文件目前对我们来说没有任何作用，所以可以将这些文件删除\",\"可以删除的目录和文件如下：\",\".mvn\",\".gitignore\",\"HELP. md\",\"mvnw\",\"mvnw.cmd\"]},{\"header\":\"1.1.1.2 创建 Controller\",\"slug\":\"_1-1-1-2-创建-controller\",\"contents\":[\"在 com.itheima.controller 包下创建 BookController\",\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @GetMapping(\\\"/{id}\\\") public String getById(@PathVariable Integer id){ System.out.println(\\\"id --> \\\"+id); return \\\"hello , spring boot!\\\"; } } \"]},{\"header\":\"1.1.1.3 启动服务器\",\"slug\":\"_1-1-1-3-启动服务器\",\"contents\":[\"运行 SpringBoot 工程不需要使用本地的 Tomcat 和 插件，只运行项目 com.itheima 包下的 Application 类，就可以在控制台看出如下信息\"]},{\"header\":\"1.1.1.4 进行测试\",\"slug\":\"_1-1-1-4-进行测试\",\"contents\":[\"使用 Postman 工具来测试我们的程序\",\"通过上面的入门案例我们可以看到使用 SpringBoot 进行开发，使整个开发变得很简单，那它是如何做到的呢？\",\"先看看 Application 类和 pom.xml 都书写了什么\",\"@SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } \",\"类上添加了一个 @SpringBootApplication 注解，而在主方法中就一行代码 在启动服务器时就是执行的该类中的主方法\",\"再看看 pom.xml 配置文件中的内容\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <!--指定了一个父工程，父工程中的东西在该工程中可以继承过来使用--> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.5.0</version> </parent> <groupId>com.itheima</groupId> <artifactId>springboot_01_quickstart</artifactId> <version>0.0.1-SNAPSHOT</version> <!--JDK 的版本--> <properties> <java.version>8</java.version> </properties> <dependencies> <!--该依赖就是我们在创建 SpringBoot 工程勾选的那个 Spring Web 产生的--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!--这个是单元测试的依赖，我们现在没有进行单元测试，所以这个依赖现在可以没有--> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <!--这个插件是在打包时需要的，而这里暂时还没有用到--> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> </project> \",\"代码之所以能简化，是因为指定的父工程和 Spring Web 依赖实现的\"]},{\"header\":\"1.1.2 对比\",\"slug\":\"_1-1-2-对比\",\"contents\":[\"Spring 程序和 SpringBoot 程序对比图\",\"坐标\",\"Spring 程序中的坐标需要自己编写，而且坐标非常多\",\"SpringBoot 程序中的坐标是在创建工程时进行勾选自动生成的\",\"web3.0配置类\",\"Spring 程序需要自己编写这个配置类 \",\"SpringBoot 程序不需要自己书写\",\"配置类\",\"Spring / SpringMVC 程序的配置类需要自己书写，而 SpringBoot 程序则不需要书写。\",\"注意：基于Idea的 Spring Initializr 快速构建 SpringBoot 工程时需要联网\"]},{\"header\":\"1.1.3 官网构建工程\",\"slug\":\"_1-1-3-官网构建工程\",\"contents\":[\"在入门案例中之所以能快速构建 SpringBoot 工程，是因为 Idea 使用了官网提供了快速构建 SpringBoot 工程的组件实现的。那如何在官网进行工程构建呢？\"]},{\"header\":\"1.1.3.1 进入SpringBoot官网\",\"slug\":\"_1-1-3-1-进入springboot官网\",\"contents\":[\"官网地址如下：\",\"https://spring.io/projects/spring-boot \",\"进入到 SpringBoot 官网后拖到最下方就可以看到如下内容\"]},{\"header\":\"1.1.3.2 选择依赖\",\"slug\":\"_1-1-3-2-选择依赖\",\"contents\":[\"选择 Spring Web 可以点击上图右上角的 ADD DEPENDENCIES... CTRL + B 按钮\"]},{\"header\":\"1.1.3.3 生成工程\",\"slug\":\"_1-1-3-3-生成工程\",\"contents\":[\"在页面的最下方点击 GENERATE CTRL + 回车 按钮生成工程并下载到本地\",\"打开下载好的压缩包可以看到工程结构和使用 Idea 生成的一模一样\",\"而打开 pom.xml 文件，里面也包含了父工程和 Spring Web 的依赖\"]},{\"header\":\"1.1.4 SpringBoot工程快速启动\",\"slug\":\"_1-1-4-springboot工程快速启动\",\"contents\":[]},{\"header\":\"1.1.4.1 问题导入\",\"slug\":\"_1-1-4-1-问题导入\",\"contents\":[\"后端可以将 SpringBoot 工程打成 jar 包，该 jar 包运行不依赖于 Tomcat 和 Idea 这些工具也可以正常运行，只是这个 jar 包在运行过程中连接和自己程序相同的 Mysql 数据库即可\",\"这样就可以解决这个问题，如下图\"]},{\"header\":\"1.1.4.2 打包\",\"slug\":\"_1-1-4-2-打包\",\"contents\":[\"在构建 SpringBoot 工程时已经在 pom.xml 中配置了如下插件\",\"<plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> \",\"所以只需要使用 Maven 的 package 指令打包就会在 target 目录下生成对应的 Jar 包\",\"注意：该插件必须配置，不然打好的 jar 包也是有问题的\"]},{\"header\":\"1.1.4.3 启动\",\"slug\":\"_1-1-4-3-启动\",\"contents\":[\"进入 jar 包所在位置，在命令提示符中输入如下命令\",\"jar -jar springboot_01_quickstart-0.0.1-SNAPSHOT.jar \"]},{\"header\":\"1.2 SpringBoot概述\",\"slug\":\"_1-2-springboot概述\",\"contents\":[\"原始 Spring 环境搭建和开发存在以下问题\",\"配置繁琐\",\"依赖设置繁琐\",\"SpringBoot 程序优点恰巧就是针对 Spring 的缺点\",\"自动配置 用来解决 Spring 程序配置繁琐的问题\",\"起步依赖 用来解决 Spring 程序依赖设置繁琐的问题\",\"辅助功能（内置服务器...） 启动 SpringBoot 程序时既没有使用本地的 tomcat 也没有使用 tomcat 插件，而是使用 SpringBoot 内置的服务器\"]},{\"header\":\"1.2.1 起步依赖\",\"slug\":\"_1-2-1-起步依赖\",\"contents\":[\"使用 Spring Initializr 方式创建的 Maven 工程的的 pom.xml 配置文件中自动生成了很多包含 starter 的依赖\"]},{\"header\":\"1.2.1.1 探索父工程\",\"slug\":\"_1-2-1-1-探索父工程\",\"contents\":[\"从上面的文件中可以看到指定了一个父工程，进入到父工程，发现父工程中又指定了一个父工程\",\"再进入到该父工程中，在该工程中可以看到配置内容结构\",\"上图中的 properties 标签中定义了各个技术软件依赖的版本，避免了在使用不同软件技术时考虑版本的兼容问题。在 properties 中找到 servlet 和 mysql 的版本如下图\",\"dependencyManagement 标签是进行依赖版本锁定，但是并没有导入对应的依赖；如果我们工程需要那个依赖只需要引入依赖的 groupid 和 artifactId 不需要定义 version。\",\"而 build 标签中也对插件的版本进行了锁定，如下图\"]},{\"header\":\"1.2.1.2 探索依赖\",\"slug\":\"_1-2-1-2-探索依赖\",\"contents\":[\"在创建的工程中的 pom.xml 中配置了如下依赖\",\"进入到该依赖，查看 pom.xml 的依赖会发现它引入了如下的依赖\",\"里面的引入了 spring-web 和 spring-webmvc 的依赖，这就是为什么工程中没有依赖这两个包还能正常使用 springMVC 中的注解的原因。\",\"而依赖 spring-boot-starter-tomcat ，从名字基本能确认内部依赖了 tomcat\",\"小结\",\"starter:\",\"SpringBoot 中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的\",\"parent:\",\"所有 SpringBoot 项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的\",\"spring-boot-starter-parent（2.5.0）与 spring-boot-starter-parent（2.4.6）共计57处坐标版本不同\",\"实际开发:\",\"使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供\",\"G：groupid\",\"A：artifactId\",\"V：version\",\"如发生坐标错误，再指定version（要小心版本冲突）\"]},{\"header\":\"1.2.2 程序启动\",\"slug\":\"_1-2-2-程序启动\",\"contents\":[\"创建的每一个 SpringBoot 程序时都包含一个类似于下面的类，将这个类称作引导类\",\"@SpringBootApplication public class Springboot01QuickstartApplication { public static void main(String[] args) { SpringApplication.run(Springboot01QuickstartApplication.class, args); } } \",\"注意：\",\"SpringBoot 在创建项目时，采用jar的打包方式\",\"SpringBoot 的引导类是项目的入口，运行 main 方法就可以启动项目\"]},{\"header\":\"1.2.3 切换web服务器\",\"slug\":\"_1-2-3-切换web服务器\",\"contents\":[\"现在启动工程使用的是 tomcat 服务器，那能不能不使用 tomcat 而使用 jetty 服务器，而要切换 web 服务器就需要将默认的 tomcat 服务器给排除掉，怎么排除呢？使用 exclusion 标签\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> <exclusions> <exclusion> <artifactId>spring-boot-starter-tomcat</artifactId> <groupId>org.springframework.boot</groupId> </exclusion> </exclusions> </dependency> \",\"运行引导类，打印日志信息如下\",\"程序直接停止了，为什么呢？那是因为排除了 tomcat 服务器，程序中就没有服务器了。所以此时不光要排除 tomcat 服务器，还要引入 jetty 服务器。在 pom.xml 中因为 jetty 的起步依赖\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-jetty</artifactId> </dependency> \",\"小结： 通过切换服务器，不难发现在使用 SpringBoot 换技术时只需要导入该技术的起步依赖即可\"]},{\"header\":\"2 配置文件\",\"slug\":\"_2-配置文件\",\"contents\":[]},{\"header\":\"2.1 配置文件格式\",\"slug\":\"_2-1-配置文件格式\",\"contents\":[\"现在启动服务器默认的端口号是 8080，访问路径可以书写为\",\"http://localhost:8080/books/1 \",\"在线上环境还是希望将端口号改为 80，这样在访问的时候就可以不写端口号了\",\"http://localhost/books/1 \",\"而 SpringBoot 程序如何修改呢？SpringBoot 提供了多种属性配置方式\",\"application.properties\",\"server.port=80 \",\"application.yml\",\"server: port: 81 \",\"application.yaml\",\"server: port: 82 \",\"注意：SpringBoot 程序的配置文件名必须是 application ，只是后缀名不同而已。\"]},{\"header\":\"2.1.1 环境准备\",\"slug\":\"_2-1-1-环境准备\",\"contents\":[\"创建一个新工程 springboot_02_base_config 用来演示不同的配置文件，工程环境和入门案例一模一样，结构如下：\",\"在该工程中的 com.itheima.controller 包下创建一个名为 BookController 的控制器。内容如下：\",\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @GetMapping(\\\"/{id}\\\") public String getById(@PathVariable Integer id){ System.out.println(\\\"id --> \\\"+id); return \\\"hello , spring boot!\\\"; } } \"]},{\"header\":\"2.1.2 不同配置文件演示\",\"slug\":\"_2-1-2-不同配置文件演示\",\"contents\":[\"application.properties配置文件\",\"配合文件必须放在 resources 目录下，而该目录下有一个名为 application.properties 的配置文件\",\"application.properties 配置文件内容如下：\",\"server.port=80 \",\"application.yml配置文件\",\"删除 application.properties 配置文件中的内容。在 resources 下创建一个名为 application.yml 的配置文件，在该文件中书写端口号的配置项，格式如下：\",\"server: port: 81 \",\"注意： 在:后，数据前一定要加空格。\",\"而在 yml 配置文件中也是有提示功能的，也可以在该文件中书写 port ，然后 idea 就会提示并书写成上面的格式\",\"启动服务，可以在控制台看到绑定的端口号是 81\",\"application.yaml配置文件\",\"删除 application.yml 配置文件和 application.properties 配置文件内容，然后在 resources 下创建名为 application.yaml 的配置文件，配置内容和后缀名为 yml 的配置文件中的内容相同，只是使用了不同的后缀名而已\",\"application.yaml 配置文件内容如下：\",\"server: port: 83 \",\"启动服务，在控制台可以看到绑定的端口号\",\"注意：在配合文件中如果没有提示，可以使用一下方式解决：\",\"点击 File 选中 Project Structure\",\"弹出如下窗口，按图中标记红框进行选择\",\"通过上述操作，会弹出如下窗口\",\"点击上图的 + 号，弹出选择该模块的配置文件\",\"通过上述几步后，就可以看到如下界面。properties 类型的配合文件有一个，ymal 类型的配置文件有两个\"]},{\"header\":\"2.1.3 三种配合文件的优先级\",\"slug\":\"_2-1-3-三种配合文件的优先级\",\"contents\":[\"在三种配合文件中分别配置不同的端口号，启动服务查看绑定的端口号。用这种方式就可以看到哪个配置文件的优先级更高一些\",\"application.properties 文件内容如下：\",\"server.port=80 \",\"application.yml 文件内容如下：\",\"server: port: 81 \",\"application.yaml 文件内容如下：\",\"server: port: 82 \",\"启动服务，在控制台可以看到使用的端口号是 80。说明 application.properties 的优先级最高\",\"注释掉 application.properties 配置文件内容。再次启动服务，在控制台可以看到使用的端口号是 81，说明 application.yml 配置文件为第二优先级。\",\"三种配置文件的优先级是：\",\"application.properties > application.yml > application.yaml\",\"注意：\",\"SpringBoot 核心配置文件名为 application\",\"SpringBoot 内置属性过多，且所有属性集中在一起修改，在使用时，通过提示键+关键字修改属性\",\"例如要设置日志的级别时，可以在配置文件中书写 logging，就会提示出来。配置内容如下\",\"logging: level: root: info \"]},{\"header\":\"2.2 yaml格式\",\"slug\":\"_2-2-yaml格式\",\"contents\":[\"YAML（YAML Ain't Markup Language），一种数据序列化格式。\",\"最开始我们使用的是 xml ，格式如下：\",\"<enterprise> <name>itcast</name> <age>16</age> <tel>4006184000</tel> </enterprise> \",\"而 properties 类型的配置文件如下\",\"enterprise.name=itcast enterprise.age=16 enterprise.tel=4006184000 \",\"yaml 类型的配置文件内容如下\",\"enterprise: name: itcast age: 16 tel: 4006184000 \",\"优点\",\"容易阅读\",\"yaml 类型的配置文件比 xml 类型的配置文件更容易阅读，结构更加清晰\",\"容易与脚本语言交互\",\"以数据为核心，重数据轻格式\",\"yaml 更注重数据，而 xml 更注重格式\",\"YAML 文件扩展名：\",\".yml (主流)\",\".yaml\"]},{\"header\":\"2.2.1 语法规则\",\"slug\":\"_2-2-1-语法规则\",\"contents\":[\"大小写敏感\",\"属性层级关系使用多行描述，每行结尾使用冒号结束\",\"使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\",\"空格的个数并不重要，只要保证同层级的左侧对齐即可。\",\"属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\",\"# 表示注释\",\"核心规则 ：数据前面要加空格与冒号隔开\",\"数组数据在数据书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔，例如\",\"enterprise: name: itcast age: 16 tel: 4006184000 subject: - Java - 前端 - 大数据 \"]},{\"header\":\"2.3 yaml配置文件数据读取\",\"slug\":\"_2-3-yaml配置文件数据读取\",\"contents\":[]},{\"header\":\"2.3.1 环境准备\",\"slug\":\"_2-3-1-环境准备\",\"contents\":[\"新创建一个名为 springboot_03_read_data 的 SpringBoot 工程，目录结构如下\",\"在 com.itheima.controller 包写创建名为 BookController 的控制器，内容如下\",\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @GetMapping(\\\"/{id}\\\") public String getById(@PathVariable Integer id){ System.out.println(\\\"id --> \\\"+id); return \\\"hello , spring boot!\\\"; } } \",\"在 com.itheima.domain 包下创建一个名为 Enterprise 的实体类等会用来封装数据，内容如下\",\"public class Enterprise { private String name; private int age; private String tel; private String[] subject; //setter and getter //toString } \",\"在 resources 下创建一个名为 application.yml 的配置文件，里面配置了不同的数据，内容如下\",\"lesson: SpringBoot server: port: 80 enterprise: name: itcast age: 16 tel: 4006184000 subject: - Java - 前端 - 大数据 \"]},{\"header\":\"2.3.2 读取配置数据\",\"slug\":\"_2-3-2-读取配置数据\",\"contents\":[]},{\"header\":\"2.3.2.1 使用 @Value注解\",\"slug\":\"_2-3-2-1-使用-value注解\",\"contents\":[\"使用 @Value(\\\"表达式\\\") 注解可以从配合文件中读取数据，注解中用于读取属性名引用方式是：${一级属性名.二级属性名……}\",\"在 BookController 中使用 @Value 注解读取配合文件数据，如下\",\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @Value(\\\"${lesson}\\\") private String lesson; @Value(\\\"${server.port}\\\") private Integer port; @Value(\\\"${enterprise.subject[ ]}\\\") private String subject_00; @GetMapping(\\\"/{id}\\\") public String getById(@PathVariable Integer id){ System.out.println(lesson); System.out.println(port); System.out.println(subject_00); return \\\"hello , spring boot!\\\"; } } \"]},{\"header\":\"2.3.2.2 Environment对象\",\"slug\":\"_2-3-2-2-environment对象\",\"contents\":[\"上面方式读取到的数据特别零散，SpringBoot 还可以使用 @Autowired 注解注入 Environment 对象的方式读取数据。这种方式 SpringBoot 会将配置文件中所有的数据封装到 Environment 对象中，如果需要使用哪个数据只需要通过调用 Environment 对象的 getProperty(String name) 方法获取。具体代码如下：\",\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @Autowired private Environment env; @GetMapping(\\\"/{id}\\\") public String getById(@PathVariable Integer id){ System.out.println(env.getProperty(\\\"lesson\\\")); System.out.println(env.getProperty(\\\"enterprise.name\\\")); System.out.println(env.getProperty(\\\"enterprise.subject[ ]\\\")); return \\\"hello , spring boot!\\\"; } } \",\"注意：这种方式，框架内容大量数据，而在开发中很少使用\"]},{\"header\":\"2.3.2.3 自定义对象\",\"slug\":\"_2-3-2-3-自定义对象\",\"contents\":[\"SpringBoot 还提供了将配置文件中的数据封装到自定义的实体类对象中的方式\",\"将实体类 bean 的创建交给 Spring 管理\",\"在类上添加 @Component 注解\",\"使用 @ConfigurationProperties 注解表示加载配置文件\",\"在该注解中也可以使用 prefix 属性指定只加载指定前缀的数据\",\"在 BookController 中进行注入\",\"具体代码如下：\",\"Enterprise 实体类内容如下：\",\"@Component @ConfigurationProperties(prefix = \\\"enterprise\\\") public class Enterprise { private String name; private int age; private String tel; private String[] subject; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getTel() { return tel; } public void setTel(String tel) { this.tel = tel; } public String[] getSubject() { return subject; } public void setSubject(String[] subject) { this.subject = subject; } @Override public String toString() { return \\\"Enterprise{\\\" + \\\"name='\\\" + name + '\\\\'' + \\\", age=\\\" + age + \\\", tel='\\\" + tel + '\\\\'' + \\\", subject=\\\" + Arrays.toString(subject) + '}'; } } \",\"BookController 内容如下：\",\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @Autowired private Enterprise enterprise; @GetMapping(\\\"/{id}\\\") public String getById(@PathVariable Integer id){ System.out.println(enterprise.getName()); System.out.println(enterprise.getAge()); System.out.println(enterprise.getSubject()); System.out.println(enterprise.getTel()); System.out.println(enterprise.getSubject()[ ]); return \\\"hello , spring boot!\\\"; } } \",\"注意：\",\"使用第三种方式，在实体类上有如下警告提示\",\"这个警告提示解决是在 pom.xml 中添加如下依赖即可\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-configuration-processor</artifactId> <optional>true</optional> </dependency> \"]},{\"header\":\"2.4 多环境配置\",\"slug\":\"_2-4-多环境配置\",\"contents\":[\"以后在工作中，对于开发环境、测试环境、生产环境的配置肯定都不相同，比如我们开发阶段会在自己的电脑上安装 mysql ，连接自己电脑上的 mysql 即可，但是项目开发完毕后要上线就需要该配置，将环境的配置改为线上环境的\",\"来回的修改配置会很麻烦，而 SpringBoot 给开发者提供了多环境的快捷配置，需要切换环境时只需要改一个配置即可。不同类型的配置文件多环境开发的配置都不相同，接下来对不同类型的配置文件进行说明\"]},{\"header\":\"2.4.1 yaml文件\",\"slug\":\"_2-4-1-yaml文件\",\"contents\":[\"在 application.yml 中使用 --- 来分割不同的配置，内容如下\",\"#开发 spring: profiles: dev #给开发环境起的名字 server: port: 80 --- #生产 spring: profiles: pro #给生产环境起的名字 server: port: 81 --- #测试 spring: profiles: test #给测试环境起的名字 server: port: 82 --- \",\"上面配置中 spring.profiles 是用来给不同的配置起名字的。而如何告知 SpringBoot 使用哪段配置呢？可以使用如下配置来启用都一段配置\",\"#设置启用的环境 spring: profiles: active: dev #表示使用的是开发环境的配置 \",\"application.yml 配置文件内容如下\",\"#设置启用的环境 spring: profiles: active: dev --- #开发 spring: profiles: dev server: port: 80 --- #生产 spring: profiles: pro server: port: 81 --- #测试 spring: profiles: test server: port: 82 --- \",\"注意： 在上面配置中给不同配置起名字的 spring.profiles 配置项已经过时。最新用来起名字的配置项是\",\"#开发 spring: config: activate: on-profile: dev \"]},{\"header\":\"2.4.2 properties文件\",\"slug\":\"_2-4-2-properties文件\",\"contents\":[\"properties 类型的配置文件配置多环境需要定义不同的配置文件\",\"application-dev.properties 是开发环境的配置文件\",\"server.port=80 \",\"application-test.properties 是测试环境的配置文件\",\"server.port=81 \",\"application-pro.properties 是生产环境的配置文件\",\"server.port=82 \",\"SpringBoot 只会默认加载名为 application.properties 的配置文件，所以需要在 application.properties 配置文件中设置启用哪个配置文件，配置如下:\",\"spring.profiles.active=pro \"]},{\"header\":\"2.4.3 命令行启动参数设置\",\"slug\":\"_2-4-3-命令行启动参数设置\",\"contents\":[\"使用 SpringBoot 开发的程序以后都是打成 jar 包，通过 java -jar xxx.jar 的方式启动服务的。那么就存在一个问题，如何切换环境呢？因为配置文件打到的jar包中了。\",\"jar 包其实就是一个压缩包，可以解压缩，然后修改配置，最后再打成jar包就可以了。这种方式显然有点麻烦，而 SpringBoot 提供了在运行 jar 时设置开启指定的环境的方式，如下\",\"java –jar xxx.jar –-spring.profiles.active=test \",\"那么这种方式能不能临时修改端口号呢？\",\"java –jar xxx.jar –-server.port=88 \",\"也可以同时设置多个配置，比如即指定启用哪个环境配置，又临时指定端口，如下\",\"java –jar springboot.jar –-server.port=88 –-spring.profiles.active=test \",\"大家进行测试后就会发现命令行设置的端口号优先级高（也就是使用的是命令行设置的端口号），配置的优先级其实 SpringBoot 官网已经进行了说明，参见 :\",\"https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config \",\"进入上面网站后会看到如下页面\"]},{\"header\":\"2.5 配置文件分类\",\"slug\":\"_2-5-配置文件分类\",\"contents\":[\"开发完毕后需要测试人员进行测试，由于测试环境和开发环境的很多配置都不相同，所以测试人员在运行我们的工程时需要临时修改很多配置，如下\",\"java –jar springboot.jar –-spring.profiles.active=test --server.port=85 --server.servlet.context-path=/heima --server.tomcat.connection-timeout=-1 …… …… …… …… …… \",\"针对这种情况，SpringBoot 定义了配置文件不同的放置的位置；而放在不同位置的优先级时不同的\",\"SpringBoot 中4级配置文件放置位置：\",\"1级：classpath：application.yml\",\"2级：classpath：config/application.yml\",\"3级：file ：application.yml\",\"4级：file ：config/application.yml\",\"说明： 级别越高优先级越高\"]},{\"header\":\"2.5.1 代码演示\",\"slug\":\"_2-5-1-代码演示\",\"contents\":[]},{\"header\":\"2.5.1.1 环境准备\",\"slug\":\"_2-5-1-1-环境准备\",\"contents\":[\"创建一个名为 springboot_06_config_file 的 SpringBoot 工程，目录结构如下\",\"在 resources 下创建一个名为 config 的目录，在该目录中创建 application.yml 配置文件，而在该配置文件中将端口号设置为 81，内容如下\",\"server: port: 81 \",\"而在 resources 下创建的 application.yml 配置文件中并将端口号设置为 80，内容如下\",\"server: port: 80 \"]},{\"header\":\"2.5.1.2 验证1级和2级的优先级\",\"slug\":\"_2-5-1-2-验证1级和2级的优先级\",\"contents\":[\"运行启动引导类，可以在控制台看到如下日志信息\",\"通过这个结果可以得出类路径下的 config 下的配置文件优先于类路径下的配置文件。\"]},{\"header\":\"2.5.1.3 验证2级和4级的优先级\",\"slug\":\"_2-5-1-3-验证2级和4级的优先级\",\"contents\":[\"要验证4级，按照以下步骤完成\",\"将工程打成 jar 包\",\"点击工程的 package 来打 jar 包\",\"在硬盘上找到 jar 包所在位置\",\"在 jar 包所在位置创建 config 文件夹，在该文件夹下创建 application.yml 配置文件，而在该配合文件中将端口号设置为 82\",\"在命令行使用以下命令运行程序\",\"java -jar springboot_06_config_file-0.0.1-SNAPSHOT.jar \",\"运行后日志信息如下\",\"通过这个结果可以得出file： config 下的配置文件优先于类路径下的配置文件。\",\"注意：\",\"SpringBoot 2.5.0版本存在一个bug，我们在使用这个版本时，需要在 jar 所在位置的 config 目录下创建一个任意名称的文件夹\"]},{\"header\":\"3 SpringBoot整合junit\",\"slug\":\"_3-springboot整合junit\",\"contents\":[\"回顾 Spring 整合 junit\",\"@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class UserServiceTest { @Autowired private BookService bookService; @Test public void testSave(){ bookService.save(); } } \",\"使用 @RunWith 注解指定运行器，使用 @ContextConfiguration 注解来指定配置类或者配置文件\",\"SpringBoot 整合 junit\",\"在测试类上添加 SpringBootTest 注解\",\"使用 @Autowired 注入要测试的资源\",\"定义测试方法进行测试\"]},{\"header\":\"3.1 环境准备\",\"slug\":\"_3-1-环境准备\",\"contents\":[\"创建一个名为 springboot_07_test 的 SpringBoot 工程，工程目录结构如下\",\"在 com.itheima.service 下创建 BookService 接口，内容如下\",\"public interface BookService { public void save(); } \",\"在 com.itheima.service.impl 包写创建一个 BookServiceImpl 类，使其实现 BookService 接口，内容如下\",\"@Service public class BookServiceImpl implements BookService { @Override public void save() { System.out.println(\\\"book service is running ...\\\"); } } \"]},{\"header\":\"3.2 编写测试类\",\"slug\":\"_3-2-编写测试类\",\"contents\":[\"在 test / java 下创建 com.itheima 包，在该包下创建测试类，将 BookService 注入到该测试类中\",\"@SpringBootTest class Springboot07TestApplicationTests { @Autowired private BookService bookService; @Test public void save() { bookService.save(); } } \",\"注意： 这里的引导类所在包必须是测试类所在包及其子包\",\"例如：\",\"引导类所在包是 com.itheima\",\"测试类所在包是 com.itheima\",\"如果不满足这个要求的话，就需要在使用 @SpringBootTest 注解时，使用 classes 属性指定引导类的字节码对象。如 @SpringBootTest(classes = Springboot07TestApplication.class)\"]},{\"header\":\"4 SpringBoot整合mybatis\",\"slug\":\"_4-springboot整合mybatis\",\"contents\":[]},{\"header\":\"4.1 回顾Spring整合Mybatis\",\"slug\":\"_4-1-回顾spring整合mybatis\",\"contents\":[\"Spring 整合 Mybatis 需要定义很多配置类\",\"SpringConfig 配置类\",\"导入 JdbcConfig 配置类\",\"导入 MybatisConfig 配置类\",\"@Configuration @ComponentScan(\\\"com.itheima\\\") @PropertySource(\\\"classpath:jdbc.properties\\\") @Import({JdbcConfig.class,MyBatisConfig.class}) public class SpringConfig { } \",\"JdbcConfig 配置类\",\"定义数据源（加载properties配置项：driver、url、username、password）\",\"public class JdbcConfig { @Value(\\\"${jdbc.driver}\\\") private String driver; @Value(\\\"${jdbc.url}\\\") private String url; @Value(\\\"${jdbc.username}\\\") private String userName; @Value(\\\"${jdbc.password}\\\") private String password; @Bean public DataSource getDataSource(){ DruidDataSource ds = new DruidDataSource(); ds.setDriverClassName(driver); ds.setUrl(url); ds.setUsername(userName); ds.setPassword(password); return ds; } } \",\"MybatisConfig 配置类\",\"定义 SqlSessionFactoryBean\",\"定义映射配置\",\"@Bean public MapperScannerConfigurer getMapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\\\"com.itheima.dao\\\"); return msc; } @Bean public SqlSessionFactoryBean getSqlSessionFactoryBean(DataSource dataSource){ SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean(); ssfb.setTypeAliasesPackage(\\\"com.itheima.domain\\\"); ssfb.setDataSource(dataSource); return ssfb; } \"]},{\"header\":\"4.2 SpringBoot整合mybatis\",\"slug\":\"_4-2-springboot整合mybatis\",\"contents\":[]},{\"header\":\"4.2.1 创建模块\",\"slug\":\"_4-2-1-创建模块\",\"contents\":[\"创建新模块，选择 Spring Initializr，并配置模块相关基础信息\",\"选择当前模块需要使用的技术集（MyBatis、MySQL）\"]},{\"header\":\"4.2.2 定义实体类\",\"slug\":\"_4-2-2-定义实体类\",\"contents\":[\"在 com.itheima.domain 包下定义实体类 Book，内容如下\",\"public class Book { private Integer id; private String name; private String type; private String description; //setter and getter //toString } \"]},{\"header\":\"4.2.3 定义dao接口\",\"slug\":\"_4-2-3-定义dao接口\",\"contents\":[\"在 com.itheima.dao 包下定义 BookDao 接口，内容如下\",\"public interface BookDao { @Select(\\\"select * from tbl_book where id = #{id}\\\") public Book getById(Integer id); } \"]},{\"header\":\"4.2.4 定义测试类\",\"slug\":\"_4-2-4-定义测试类\",\"contents\":[\"在 test/java 下定义包 com.itheima ，在该包下测试类，内容如下\",\"@SpringBootTest class Springboot08MybatisApplicationTests { @Autowired private BookDao bookDao; @Test void testGetById() { Book book = bookDao.getById(1); System.out.println(book); } } \"]},{\"header\":\"4.2.5 编写配置\",\"slug\":\"_4-2-5-编写配置\",\"contents\":[\"数据库需要在 SpringBoot 的配置文件中进行配合\",\"在 application.yml 配置文件中配置如下内容\",\"spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_db username: root password: root \"]},{\"header\":\"4.2.6 测试\",\"slug\":\"_4-2-6-测试\",\"contents\":[\"运行测试方法\",\"错误信息显示在 Spring 容器中没有 BookDao 类型的 bean。为什么会出现这种情况呢？\",\"原因是 Mybatis 会扫描接口并创建接口的代码对象交给 Spring 管理，但是现在并没有告诉 Mybatis 哪个是 dao 接口。而解决这个问题需要在BookDao 接口上使用 @Mapper ，BookDao 接口改进为\",\"@Mapper public interface BookDao { @Select(\\\"select * from tbl_book where id = #{id}\\\") public Book getById(Integer id); } \",\"注意：\",\"SpringBoot 版本低于2.4.3(不含)，Mysql驱动版本大于8.0时，需要在url连接串中配置时区 jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC，或在MySQL数据库端配置时区解决此问题\"]},{\"header\":\"4.2.7 使用Druid数据源\",\"slug\":\"_4-2-7-使用druid数据源\",\"contents\":[\"现在并没有指定数据源，SpringBoot 有默认的数据源，可以指定使用 Druid 数据源\",\"导入 Druid 依赖\",\"<dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> \",\"在 application.yml 配置文件配置\",\"可以通过 spring.datasource.type 来配置使用什么数据源\",\"spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC username: root password: root type: com.alibaba.druid.pool.DruidDataSource \"]},{\"header\":\"5 案例\",\"slug\":\"_5-案例\",\"contents\":[\"SSM 三大框架整合用 SpringBoot 来实现\",\"pom.xml\",\"配置起步依赖，必要的资源坐标(druid)\",\"application.yml\",\"设置数据源、端口等\",\"配置类\",\"全部删除\",\"dao\",\"设置@Mapper\",\"测试类\",\"页面\",\"放置在resources目录下的static目录中\"]},{\"header\":\"5.1 创建工程\",\"slug\":\"_5-1-创建工程\",\"contents\":[\"创建 SpringBoot 工程，在创建工程时需要勾选 web、mysql、mybatis，工程目录结构如下\",\"导入 Druid 的坐标\",\"<dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> \"]},{\"header\":\"5.2 代码拷贝\",\"slug\":\"_5-2-代码拷贝\",\"contents\":[\"将 springmvc_11_page 工程中的 java 代码及测试代码连同包拷贝到 springboot_09_ssm 工程，按照下图进行拷贝\",\"需要修改的内容如下：\",\"Springmvc_11_page 中 config 包下的是配置类，而 SpringBoot 工程不需要这些配置类，所以这些可以直接删除\",\"dao 包下的接口上在拷贝到 springboot_09-ssm 工程中需要在接口中添加 @Mapper 注解\",\"BookServiceTest 测试需要改成 SpringBoot 整合 junit 的\",\"@SpringBootTest public class BookServiceTest { @Autowired private BookService bookService; @Test public void testGetById(){ Book book = bookService.getById(2); System.out.println(book); } @Test public void testGetAll(){ List<Book> all = bookService.getAll(); System.out.println(all); } } \"]},{\"header\":\"5.3 配置文件\",\"slug\":\"_5-3-配置文件\",\"contents\":[\"在 application.yml 配置文件中需要配置如下内容\",\"服务的端口号\",\"连接数据库的信息\",\"数据源\",\"server: port: 80 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_db #?servierTimezone=UTC username: root password: root \"]},{\"header\":\"5.4 静态资源\",\"slug\":\"_5-4-静态资源\",\"contents\":[\"在 SpringBoot 程序中是没有 webapp 目录的，那么在 SpringBoot 程序中静态资源需要放在什么位置呢？\",\"静态资源需要放在 resources 下的 static 下，如下图所示\"]}]},\"/BackEnd/SpringMVC/\":{\"title\":\"SpringMVC\",\"contents\":[{\"header\":\"1 SpringMVC简介\",\"slug\":\"_1-springmvc简介\",\"contents\":[\"SpringMVC 隶属于 Spring ，是 Spring 技术中的一部分\",\"SpringMVC 与 Servlet 技术功能等同，均属于web层或者说是表现层开发技术\",\"SpringMVC 与 Servlet相比\",\"开发起来更简单快捷，用更少的代码完成表现层代码的开发\"]},{\"header\":\"1.1 Servlet例子\",\"slug\":\"_1-1-servlet例子\",\"contents\":[\"UserSaveServlet：使用Servlet开发的用户新增模块\",\"@WebServlet(\\\"/user/save\\\") public class UserSaveServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.接收请求参数 String name = req.getParameter(\\\"name\\\"); System.out.println(\\\"servlet save name ==> \\\" + name); //2.生产响应 resp.setContentType(\\\"text/json;charset=utf-8\\\"); PrintWriter pw = resp.getWriter(); pw.write(\\\"{'module':'servlet save'}\\\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } \",\"UserUpdateServlet：使用Servlet开发的用户修改模块\",\"@WebServlet(\\\"/user/update\\\") public class UserUpdateServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.接收请求参数 String name = req.getParameter(\\\"name\\\"); System.out.println(\\\"servlet update name ==> \\\" + name); //2.生产响应 resp.setContentType(\\\"text/json;charset=utf-8\\\"); PrintWriter pw = resp.getWriter(); pw.write(\\\"{'module':'servlet update'}\\\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } \",\"UserDeleteServlet：使用Servlet开发的用户删除模块\",\"@WebServlet(\\\"/user/delete\\\") public class UserDeleteServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.接收请求参数 String name = req.getParameter(\\\"name\\\"); System.out.println(\\\"servlet delete name ==> \\\" + name); //2.生产响应 resp.setContentType(\\\"text/json;charset=utf-8\\\"); PrintWriter pw = resp.getWriter(); pw.write(\\\"{'module':'servlet delete'}\\\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } \",\"UserDeleteServlet：使用Servlet开发的用户查询模块\",\"@WebServlet(\\\"/user/select\\\") public class UserSelectServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1.接收请求参数 String name = req.getParameter(\\\"name\\\"); System.out.println(\\\"servlet select name ==> \\\" + name); //2.生产响应 resp.setContentType(\\\"text/json;charset=utf-8\\\"); PrintWriter pw = resp.getWriter(); pw.write(\\\"{'module':'servlet select'}\\\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doGet(req,resp); } } \",\"启动项目，测试结果如下:\",\"上面就是通过Servlet的方式来实现的用户模块的增删改查功能\"]},{\"header\":\"1.2 springMVC例子\",\"slug\":\"_1-2-springmvc例子\",\"contents\":[\"springmvc下的UserController类\",\"@Controller public class UserController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(String name){ System.out.println(\\\"springmvc save name ==> \\\" + name); return \\\"{'module':'springmvc save'}\\\"; } @RequestMapping(\\\"/delete\\\") @ResponseBody public String delete(String name){ System.out.println(\\\"springmvc delete name ==> \\\" + name); return \\\"{'module':'springmvc delete'}\\\"; } @RequestMapping(\\\"/update\\\") @ResponseBody public String update(String name){ System.out.println(\\\"springmvc update name ==> \\\" + name); return \\\"{'module':'springmvc update'}\\\"; } @RequestMapping(\\\"/select\\\") @ResponseBody public String select(String name){ System.out.println(\\\"springmvc select name ==> \\\" + name); return \\\"{'module':'springmvc select'}\\\"; } } \",\"启动项目，测试结果如下:\",\"注\",\"请求与响应：SpringMVC 主要的作用就是用来接收前端发过来的请求和数据然后经过处理并将处理的结果响应给前端，所以如何处理请求和响应是SpringMVC中非常重要的一块内容\",\"REST风格：是一种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，在以后开发中非常重要和常用\"]},{\"header\":\"2 SpringMVC概述\",\"slug\":\"_2-springmvc概述\",\"contents\":[\"当前WEB程序的工作流程:\"]},{\"header\":\"2.1 三层架构\",\"slug\":\"_2-1-三层架构\",\"contents\":[\"web程序通过浏览器访问前端页面，发送异步请求到后端服务器\",\"后台服务器采用三层架构进行功能开发\",\"表现层 负责接收请求和数据然后将数据转交给业务层\",\"业务层 负责调用数据层完成数据库表的增删改查，并将结果返给表现层\",\"表现层 将数据转换成json格式返回给前端\",\"前端页面将数据进行解析最终展示给用户\"]},{\"header\":\"2.2 表现层与数据层的技术选型\",\"slug\":\"_2-2-表现层与数据层的技术选型\",\"contents\":[\"数据层采用Mybatis框架\",\"表现层采用SpringMVC框架，SpringMVC主要负责的内容有: \",\"controller如何接收请求和数据\",\"如何将请求和数据转发给业务层\",\"如何将响应数据转换成json发回到前端\",\"总结\",\"SpringMVC是一种基于Java实现MVC模型的轻量级Web框架\",\"优点\",\"使用简单、开发便捷(相比于Servlet)\",\"灵活性强\"]}]},\"/BackEnd/SpringMVC/springmvc01.html\":{\"title\":\"SpringMVC 入门\",\"contents\":[{\"header\":\"1 SpringMVC入门案例\",\"slug\":\"_1-springmvc入门案例\",\"contents\":[\"先回顾Servlet是如何进行开发的?\",\"浏览器发送请求到Tomcat服务器\",\"Tomcat服务器接收到请求后，会根据请求路径来匹配对应的Servlet，并将请求交给对应的Servlet来处理\",\"对于Servlet来说，主要完成的是Servlet类的开发以及对应路径的配置\",\"那么对于SpringMVC程序的流程会是什么样的呢?\",\"浏览器发送请求到Tomcat服务器\",\"Tomcat服务器接收到请求后，会将请求交给SpringMVC中的DispatcherServlet（前端控制器）来处理请求\",\"DispatcherServlet不真正处理请求，只是按照对应的规则将请求分发到对应的Bean对象\",\"Bean对象是由我们自己编写来处理不同的请求，每个Bean中可以处理一个或多个不同的请求url\",\"DispatcherServlet和Bean对象都需要交给Spring容器来进行管理\",\"综上所述，需要编写的内容\",\"Bean对象的编写\",\"请求url和Bean对象对应关系的配置\",\"构建Spring容器，将DispatcherServlet和Bean对象交给容器管理\",\"配置Tomcat服务器，使其能够识别Spring容器，并将请求交给容器中的DispatcherServlet来分发请求\"]},{\"header\":\"1.1 需求分析\",\"slug\":\"_1-1-需求分析\",\"contents\":[\"具体的实现步骤如下:\",\"创建web工程(Maven结构)并在工程的pom.xml添加SpringMVC和Servlet坐标\",\"创建SpringMVC控制器类(等同于Servlet功能)\",\"初始化SpringMVC环境(同Spring环境)，设定SpringMVC加载对应的bean\",\"初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求\"]},{\"header\":\"1.2 案例制作\",\"slug\":\"_1-2-案例制作\",\"contents\":[]},{\"header\":\"步骤1:创建Maven项目，并导入对应的jar包\",\"slug\":\"步骤1-创建maven项目-并导入对应的jar包\",\"contents\":[\"因为使用骨架创建的项目结构不完整，需要手动补全\",\"将pom.xml中多余的内容删除掉，再添加SpringMVC需要的依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_01_quickstart</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <maven.compiler.source>1.8</maven.compiler.source> <maven.compiler.target>1.8</maven.compiler.target> </properties> <!--1. 导入SpringMVC与servlet的坐标--> <dependencies> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> </plugins> </build> </project> \",\"说明\",\"servlet的坐标为什么需要添加<scope>provided</scope>?\",\"scope是maven中jar包依赖作用范围的描述，\",\"如果不设置默认是compile在在编译、运行、测试时均有效\",\"如果运行有效的话就会和tomcat中的servlet-api包发生冲突，导致启动报错\",\"provided代表的是该包只在编译和测试的时候用，运行的时候无效直接使用tomcat中的，就避免冲突\"]},{\"header\":\"步骤2:创建控制器类\",\"slug\":\"步骤2-创建控制器类\",\"contents\":[\"//2.制作控制器类，等同于Servlet //2.1必须是一个spring管理的bean //2.2定义具体处理请求的方法 //2.3设置当前方法的访问路径 //2.4设置响应结果为json数据 @Controller public class UserController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(){ System.out.println(\\\"user save ...\\\"); return \\\"{'module':'springmvc'}\\\"; } } \"]},{\"header\":\"步骤3:创建配置类\",\"slug\":\"步骤3-创建配置类\",\"contents\":[\"//3.定义配置类加载Controller对应的bean @Configuration @ComponentScan(\\\"com.itheima.controller\\\") public class SpringMvcConfig { } \"]},{\"header\":\"步骤4:创建Tomcat的Servlet容器配置类\",\"slug\":\"步骤4-创建tomcat的servlet容器配置类\",\"contents\":[\"//4.定义servlet容器的配置类 public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer { //加载springMVC配置 protected WebApplicationContext createServletApplicationContext() { //初始化WebApplicationContext对象 AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext(); //加载指定配置类 ctx.register(SpringMvcConfig.class); return ctx; } //设置Tomcat接收的请求哪些归SpringMVC处理 protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } //设置spring相关配置 protected WebApplicationContext createRootApplicationContext() { return null; } } \"]},{\"header\":\"步骤5:配置Tomcat环境\",\"slug\":\"步骤5-配置tomcat环境\",\"contents\":[]},{\"header\":\"步骤6:启动运行项目\",\"slug\":\"步骤6-启动运行项目\",\"contents\":[]},{\"header\":\"步骤7:浏览器访问\",\"slug\":\"步骤7-浏览器访问\",\"contents\":[\"浏览器输入http://localhost/save进行访问\"]},{\"header\":\"知识点1：@Controller\",\"slug\":\"知识点1-controller\",\"contents\":[\"名称\",\"@Controller\",\"类型\",\"类注解\",\"位置\",\"SpringMVC控制器类定义上方\",\"作用\",\"设定SpringMVC的核心控制器bean\"]},{\"header\":\"知识点2：@RequestMapping\",\"slug\":\"知识点2-requestmapping\",\"contents\":[\"名称\",\"@RequestMapping\",\"类型\",\"类注解或方法注解\",\"位置\",\"SpringMVC控制器类或方法定义上方\",\"作用\",\"设置当前控制器方法请求访问路径\",\"相关属性\",\"value(默认)，请求访问路径\"]},{\"header\":\"知识点3：@ResponseBody\",\"slug\":\"知识点3-responsebody\",\"contents\":[\"名称\",\"@ResponseBody\",\"类型\",\"类注解或方法注解\",\"位置\",\"SpringMVC控制器类或方法定义上方\",\"作用\",\"设置当前控制器方法响应内容为当前返回值，无需解析\"]},{\"header\":\"1.3 入门案例总结\",\"slug\":\"_1-3-入门案例总结\",\"contents\":[\"SpringMVC入门程序开发总结(1+N)\",\"一次性工作\",\"创建工程，设置服务器，加载工程\",\"导入坐标\",\"创建web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径\",\"SpringMVC核心配置类（设置配置类，扫描controller包，加载Controller控制器bean）\",\"多次工作\",\"定义处理请求的控制器类\",\"定义处理请求的控制器方法，并配置映射路径（@RequestMapping）与返回json数据（@ResponseBody）\",\"多次工作通过实现一个用户的删除功能来体验一把\",\"controller类中编写删除方法\",\"//2.制作控制器类，等同于Servlet //2.1必须是一个spring管理的bean //2.2定义具体处理请求的方法 //2.3设置当前方法的访问路径 //2.4设置响应结果为json数据 @Controller public class UserController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(){ System.out.println(\\\"user save ...\\\"); return \\\"{'module':'springmvc'}\\\"; } @RequestMapping(\\\"/delete\\\") @ResponseBody public String delete(){ System.out.println(\\\"user delete ...\\\"); return \\\"{'module':'springmvc delete '}\\\"; } } \",\"重启服务器，访问http://localhost/delete\",\"针对本案例中出现的Tomcat的Servlet容器配置总结:\",\"AbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类\",\"AbstractDispatcherServletInitializer提供三个接口方法供用户实现\",\"createRootApplicationContext()方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，使用方式同createServletApplicationContext()\",\"createServletApplicationContext()方法，创建Servlet容器时，加载SpringMVC对应的bean并放入WebApplicationContext对象范围中，而WebApplicationContext的作用范围为ServletContext范围，即整个web容器范围\",\"ngetServletMappings()方法，设定SpringMVC对应的请求映射路径，设置为/表示拦截所有请求，任意请求都将转入到SpringMVC进行处理\",\"createServletApplicationContext用来加载SpringMVC环境\",\"createRootApplicationContext用来加载Spring环境\"]},{\"header\":\"1.4 入门案例工作流程分析\",\"slug\":\"_1-4-入门案例工作流程分析\",\"contents\":[\"将SpringMVC的使用过程分两个阶段来分析，分别是启动服务器初始化过程和单次请求过程\"]},{\"header\":\"1.4.1 启动服务器初始化过程\",\"slug\":\"_1-4-1-启动服务器初始化过程\",\"contents\":[\"服务器启动，执行ServletContainersInitConfig类，初始化web容器\",\"执行createServletApplicationContext方法，创建了WebApplicationContext对象\",\"该方法加载SpringMVC的配置类SpringMvcConfig来初始化SpringMVC的容器\",\"加载SpringMvcConfig配置类\",\"执行@ComponentScan加载对应的bean\",\"扫描指定包下所有类上的注解，如Controller类上的@Controller注解\",\"加载UserController，每个@RequestMapping的名称对应一个具体的方法\",\"此时就建立了 /save 和 save方法的对应关系\",\"执行getServletMappings方法，定义所有的请求都通过SpringMVC\",\"/代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求\"]},{\"header\":\"1.4.2 单次请求过程\",\"slug\":\"_1-4-2-单次请求过程\",\"contents\":[\"发送请求localhost/save\",\"web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理 \",\"因为符合上面第六步设置的请求路径，所以该请求会交给SpringMVC来处理\",\"解析请求路径/save\",\"由/save匹配执行对应的方法save() \",\"上面的第五步已经将请求路径和方法建立了对应关系，通过/save就能找到对应的save方法\",\"执行save()\",\"检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方\"]},{\"header\":\"1.5 bean加载控制\",\"slug\":\"_1-5-bean加载控制\",\"contents\":[]},{\"header\":\"1.5.1 问题分析\",\"slug\":\"_1-5-1-问题分析\",\"contents\":[\"在入门案例中创建过一个SpringMvcConfig的配置类\",\"项目目录结构:\",\"config目录存入的是配置类，写过的配置类有:\",\"ServletContainersInitConfig\",\"SpringConfig\",\"SpringMvcConfig\",\"JdbcConfig\",\"MybatisConfig\",\"controller目录存放的是SpringMVC的controller类\",\"service目录存放的是service接口和实现类\",\"dao目录存放的是dao/Mapper接口\",\"controller、service和dao这些类都需要被容器管理成bean对象，那么到底是该让SpringMVC加载还是让Spring加载呢?\",\"SpringMVC加载其相关bean(表现层bean),也就是controller包下的类\",\"Spring控制的bean \",\"业务bean(Service)\",\"功能bean(DataSource,SqlSessionFactoryBean,MapperScannerConfigurer等)\",\"在SpringMVC的配置类SpringMvcConfig中使用注解@ComponentScan\",\"在Spring的配置类SpringConfig中使用注解@ComponentScan，当时扫描的范围中其实是已经包含了controller，如:\",\"从包结构来看，Spring已经把SpringMVC的controller类也给扫描了\",\"现在的问题就是因为功能不同，如何避免Spring错误加载到SpringMVC的bean?\"]},{\"header\":\"1.5.2 思路分析\",\"slug\":\"_1-5-2-思路分析\",\"contents\":[\"加载Spring控制的bean的时候排除掉SpringMVC控制的备案\",\"具体该如何排除:\",\"方式一：Spring加载的bean设定扫描范围为com.itheima，排除掉controller包中的bean\",\"方式二：Spring加载的bean设定扫描范围为精准范围，例如service包、dao包等\",\"方式三：不区分Spring与SpringMVC的环境，加载到同一个环境中\"]},{\"header\":\"1.5.4 环境准备\",\"slug\":\"_1-5-4-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加Spring依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_02_bean_load</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <dependencies> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.6</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.47</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>1.3.0</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> </plugins> </build> </project> \",\"创建对应的配置类\",\"public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer { protected WebApplicationContext createServletApplicationContext() { AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext(); ctx.register(SpringMvcConfig.class); return ctx; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } protected WebApplicationContext createRootApplicationContext() { return null; } } @Configuration @ComponentScan(\\\"com.itheima.controller\\\") public class SpringMvcConfig { } @Configuration @ComponentScan(\\\"com.itheima\\\") public class SpringConfig { } \",\"编写Controller，Service，Dao，Domain类\",\"@Controller public class UserController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(){ System.out.println(\\\"user save ...\\\"); return \\\"{'info':'springmvc'}\\\"; } } public interface UserService { public void save(User user); } @Service public class UserServiceImpl implements UserService { public void save(User user) { System.out.println(\\\"user service ...\\\"); } } public interface UserDao { @Insert(\\\"insert into tbl_user(name,age)values(#{name},#{age})\\\") public void save(User user); } public class User { private Integer id; private String name; private Integer age; //setter..getter..toString略 } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"1.5.5 设置bean加载控制\",\"slug\":\"_1-5-5-设置bean加载控制\",\"contents\":[\"方式一：修改Spring配置类，设定扫描范围为精准范围。\",\"@Configuration @ComponentScan({\\\"com.itheima.service\\\",\\\"comitheima.dao\\\"}) public class SpringConfig { } \",\"说明: 上述只是通过例子说明可以精确指定让Spring扫描对应的包结构，真正在做开发的时候，因为Dao最终是交给MapperScannerConfigurer对象来进行扫描处理的，只需要将其扫描到service包即可\",\"方式二：修改Spring配置类，设定扫描范围为com.itheima，排除掉controller包中的bean\",\"@Configuration @ComponentScan(value=\\\"com.itheima\\\", excludeFilters=@ComponentScan.Filter( type = FilterType.ANNOTATION, classes = Controller.class ) ) public class SpringConfig { } \",\"excludeFilters属性：设置扫描加载bean时，排除的过滤规则\",\"type属性：设置排除规则，当前使用按照bean定义时的注解类型进行排除\",\"ANNOTATION：按照注解排除\",\"ASSIGNABLE_TYPE：按照指定的类型过滤\",\"ASPECTJ：按照Aspectj表达式排除，基本上不会用\",\"REGEX：按照正则表达式排除\",\"CUSTOM：按照自定义规则排除\",\"classes属性：设置排除的具体注解类，当前设置排除@Controller定义的bean\",\"如何测试controller类已经被排除掉了?\",\"public class App{ public static void main (String[] args){ AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class); System.out.println(ctx.getBean(UserController.class)); } } \",\"如果被排除了，该方法执行就会报bean未被定义的错误\",\"注意:测试的时候，需要把SpringMvcConfig配置类上的@ComponentScan注解注释掉，否则不会报错\",\"出现问题的原因是\",\"Spring配置类扫描的包是com.itheima\",\"SpringMVC的配置类，SpringMvcConfig上有一个@Configuration注解，也会被Spring扫描到\",\"SpringMvcConfig上又有一个@ComponentScan，把controller类又给扫描进来了\",\"所以如果不把@ComponentScan注释掉，Spring配置类将Controller排除，但是因为扫描到SpringMVC的配置类，又将其加载回来，演示的效果就出不来\",\"解决方案，把SpringMVC的配置类移出Spring配置类的扫描范围即可。\",\"有了Spring的配置类，要想在tomcat服务器启动将其加载，需要修改ServletContainersInitConfig\",\"public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer { protected WebApplicationContext createServletApplicationContext() { AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext(); ctx.register(SpringMvcConfig.class); return ctx; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } protected WebApplicationContext createRootApplicationContext() { AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext(); ctx.register(SpringConfig.class); return ctx; } } \",\"Spring还提供了一种更简单的配置方式，不用创建AnnotationConfigWebApplicationContext对象，不用手动register对应的配置类\",\"public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class<?>[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } } \"]},{\"header\":\"知识点1：@ComponentScan\",\"slug\":\"知识点1-componentscan\",\"contents\":[\"名称\",\"@ComponentScan\",\"类型\",\"类注解\",\"位置\",\"类定义上方\",\"作用\",\"设置spring配置类扫描路径，用于加载使用注解格式定义的bean\",\"相关属性\",\"excludeFilters:排除扫描路径中加载的bean，需要指定类别(type)和具体项(classes)includeFilters:加载指定的bean，需要指定类别(type)和具体项(classes)\"]},{\"header\":\"2 PostMan工具的使用\",\"slug\":\"_2-postman工具的使用\",\"contents\":[]},{\"header\":\"2.1 PostMan简介\",\"slug\":\"_2-1-postman简介\",\"contents\":[\"PostMan是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。\",\"作用：常用于进行接口测试\"]},{\"header\":\"2.2 PostMan安装\",\"slug\":\"_2-2-postman安装\",\"contents\":[]},{\"header\":\"2.3 PostMan使用\",\"slug\":\"_2-3-postman使用\",\"contents\":[]},{\"header\":\"2.3.1 创建WorkSpace工作空间\",\"slug\":\"_2-3-1-创建workspace工作空间\",\"contents\":[]},{\"header\":\"2.3.2 发送请求\",\"slug\":\"_2-3-2-发送请求\",\"contents\":[]},{\"header\":\"2.3.3 保存当前请求\",\"slug\":\"_2-3-3-保存当前请求\",\"contents\":[]},{\"header\":\"3 请求与响应\",\"slug\":\"_3-请求与响应\",\"contents\":[\"请求映射路径\",\"请求参数\",\"日期类型参数传递\",\"响应json数据\"]},{\"header\":\"3.1 设置请求映射路径\",\"slug\":\"_3-1-设置请求映射路径\",\"contents\":[]},{\"header\":\"3.1.1 环境准备\",\"slug\":\"_3-1-1-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加Spring依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_03_request_mapping</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <dependencies> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> </plugins> </build> </project> \",\"创建对应的配置类\",\"public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } protected Class<?>[] getRootConfigClasses() { return new Class[0]; } } @Configuration @ComponentScan(\\\"com.itheima.controller\\\") public class SpringMvcConfig { } \",\"编写BookController和UserController\",\"@Controller public class UserController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(){ System.out.println(\\\"user save ...\\\"); return \\\"{'module':'user save'}\\\"; } @RequestMapping(\\\"/delete\\\") @ResponseBody public String save(){ System.out.println(\\\"user delete ...\\\"); return \\\"{'module':'user delete'}\\\"; } } @Controller public class BookController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(){ System.out.println(\\\"book save ...\\\"); return \\\"{'module':'book save'}\\\"; } } \",\"最终创建好的项目结构如下:\",\"把环境准备好后，启动Tomcat服务器，后台会报错:\",\"从错误信息可以看出：\",\"UserController有一个save方法，访问路径为http://localhost/save\",\"BookController也有一个save方法，访问路径为http://localhost/save\",\"当访问http://localhost/saved的时候，到底是访问UserController还是BookController?\"]},{\"header\":\"3.1.2 问题分析\",\"slug\":\"_3-1-2-问题分析\",\"contents\":[\"团队多人开发，每人设置不同的请求路径，冲突问题该如何解决?\",\"解决思路：为不同模块设置模块名作为请求路径前置\",\"对于Book模块的save，将其访问路径设置http://localhost/book/save\",\"对于User模块的save，将其访问路径设置http://localhost/user/save\"]},{\"header\":\"3.1.3 设置映射路径\",\"slug\":\"_3-1-3-设置映射路径\",\"contents\":[]},{\"header\":\"步骤1:修改Controller\",\"slug\":\"步骤1-修改controller\",\"contents\":[\"@Controller public class UserController { @RequestMapping(\\\"/user/save\\\") @ResponseBody public String save(){ System.out.println(\\\"user save ...\\\"); return \\\"{'module':'user save'}\\\"; } @RequestMapping(\\\"/user/delete\\\") @ResponseBody public String save(){ System.out.println(\\\"user delete ...\\\"); return \\\"{'module':'user delete'}\\\"; } } @Controller public class BookController { @RequestMapping(\\\"/book/save\\\") @ResponseBody public String save(){ System.out.println(\\\"book save ...\\\"); return \\\"{'module':'book save'}\\\"; } } \",\"写起来比较麻烦而且还有很多重复代码，如果/user后期发生变化，所有的方法都需要改，耦合度太高\"]},{\"header\":\"步骤2:优化路径配置\",\"slug\":\"步骤2-优化路径配置\",\"contents\":[\"优化方案:\",\"@Controller @RequestMapping(\\\"/user\\\") public class UserController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(){ System.out.println(\\\"user save ...\\\"); return \\\"{'module':'user save'}\\\"; } @RequestMapping(\\\"/delete\\\") @ResponseBody public String save(){ System.out.println(\\\"user delete ...\\\"); return \\\"{'module':'user delete'}\\\"; } } @Controller @RequestMapping(\\\"/book\\\") public class BookController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(){ System.out.println(\\\"book save ...\\\"); return \\\"{'module':'book save'}\\\"; } } \",\"注意\",\"当类上和方法上都添加了@RequestMapping注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到\",\"@RequestMapping注解value属性前面加不加/都可以\"]},{\"header\":\"3.2 请求参数\",\"slug\":\"_3-2-请求参数\",\"contents\":[\"请求路径设置好后，只要确保页面发送请求地址和后台Controller类中配置的路径一致，就可以接收到前端的请求，接收到请求后，如何接收页面传递的参数?\",\"关于请求参数的传递与接收是和请求方式有关系的，目前比较常见的两种请求方式为：\",\"GET\",\"POST\"]},{\"header\":\"3.2.1 环境准备\",\"slug\":\"_3-2-1-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加Spring依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_03_request_mapping</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <dependencies> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> </plugins> </build> </project> \",\"创建对应的配置类\",\"public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } protected Class<?>[] getRootConfigClasses() { return new Class[0]; } } @Configuration @ComponentScan(\\\"com.itheima.controller\\\") public class SpringMvcConfig { } \",\"编写UserController\",\"@Controller public class UserController { @RequestMapping(\\\"/commonParam\\\") @ResponseBody public String commonParam(){ return \\\"{'module':'commonParam'}\\\"; } } \",\"编写模型类，User和Address\",\"public class Address { private String province; private String city; //setter...getter...略 } public class User { private String name; private int age; //setter...getter...略 } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"3.2.2 参数传递\",\"slug\":\"_3-2-2-参数传递\",\"contents\":[]},{\"header\":\"GET发送单个参数\",\"slug\":\"get发送单个参数\",\"contents\":[\"发送请求与参数:\",\"http://localhost/commonParam?name=itcast \",\"接收参数：\",\"@Controller public class UserController { @RequestMapping(\\\"/commonParam\\\") @ResponseBody public String commonParam(String name){ System.out.println(\\\"普通参数传递 name ==> \\\"+name); return \\\"{'module':'commonParam'}\\\"; } } \"]},{\"header\":\"GET发送多个参数\",\"slug\":\"get发送多个参数\",\"contents\":[\"发送请求与参数:\",\"http://localhost/commonParam?name=itcast&age=15 \",\"接收参数：\",\"@Controller public class UserController { @RequestMapping(\\\"/commonParam\\\") @ResponseBody public String commonParam(String name,int age){ System.out.println(\\\"普通参数传递 name ==> \\\"+name); System.out.println(\\\"普通参数传递 age ==> \\\"+age); return \\\"{'module':'commonParam'}\\\"; } } \"]},{\"header\":\"GET请求中文乱码\",\"slug\":\"get请求中文乱码\",\"contents\":[\"发送请求:http://localhost/commonParam?name=张三&age=18\",\"Tomcat8.5以后的版本已经处理了中文乱码的问题，但是IDEA中的Tomcat插件目前只到Tomcat7，所以需要修改pom.xml来解决GET请求中文乱码问题\",\"<build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port><!--tomcat端口号--> <path>/</path> <!--虚拟目录--> <uriEncoding>UTF-8</uriEncoding><!--访问路径编解码字符集--> </configuration> </plugin> </plugins> </build> \"]},{\"header\":\"POST发送参数\",\"slug\":\"post发送参数\",\"contents\":[\"发送请求与参数:\",\"接收参数：\",\"和GET一致，不用做任何修改\",\"@Controller public class UserController { @RequestMapping(\\\"/commonParam\\\") @ResponseBody public String commonParam(String name,int age){ System.out.println(\\\"普通参数传递 name ==> \\\"+name); System.out.println(\\\"普通参数传递 age ==> \\\"+age); return \\\"{'module':'commonParam'}\\\"; } } \"]},{\"header\":\"POST请求中文乱码\",\"slug\":\"post请求中文乱码\",\"contents\":[\"发送请求与参数:\",\"接收参数:\",\"控制台打印，会发现有中文乱码问题。\",\"解决方案:配置过滤器\",\"public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class<?>[] getRootConfigClasses() { return new Class[0]; } protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } //乱码处理 @Override protected Filter[] getServletFilters() { CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\\\"UTF-8\\\"); return new Filter[]{filter}; } } \",\"CharacterEncodingFilter是在spring-web包中，所以用之前需要导入对应的jar包\"]},{\"header\":\"3.3 五种类型参数传递\",\"slug\":\"_3-3-五种类型参数传递\",\"contents\":[\"常见的参数种类有\",\"普通参数\",\"POJO类型参数\",\"嵌套POJO类型参数\",\"数组类型参数\",\"集合类型参数\"]},{\"header\":\"3.3.1 普通参数\",\"slug\":\"_3-3-1-普通参数\",\"contents\":[\"普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数\",\"如果形参与地址参数名不一致该如何解决?\",\"发送请求与参数:\",\"http://localhost/commonParamDifferentName?name=张三&age=18 \",\"后台接收参数:\",\"@RequestMapping(\\\"/commonParamDifferentName\\\") @ResponseBody public String commonParamDifferentName(String userName , int age){ System.out.println(\\\"普通参数传递 userName ==> \\\"+userName); System.out.println(\\\"普通参数传递 age ==> \\\"+age); return \\\"{'module':'common param different name'}\\\"; } \",\"因为前端给的是name，后台接收使用的是userName，两个名称对不上，导致接收数据失败:\",\"使用@RequestParam注解\",\"@RequestMapping(\\\"/commonParamDifferentName\\\") @ResponseBody public String commonParamDifferentName(@RequestParam(\\\"name\\\") String userName , int age){ System.out.println(\\\"普通参数传递 userName ==> \\\"+userName); System.out.println(\\\"普通参数传递 age ==> \\\"+age); return \\\"{'module':'common param different name'}\\\"; } \",\"注意: 写上@RequestParam注解框架就不需要自己去解析注入，能提升框架处理性能\"]},{\"header\":\"3.3.2 POJO数据类型\",\"slug\":\"_3-3-2-pojo数据类型\",\"contents\":[\"简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候可以考虑使用POJO数据类型\",\"POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数\",\"此时需要使用前面准备好的POJO类，先来看下User\",\"public class User { private String name; private int age; //setter...getter...略 } \",\"发送请求和参数:\",\"后台接收参数:\",\"//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递 @RequestMapping(\\\"/pojoParam\\\") @ResponseBody public String pojoParam(User user){ System.out.println(\\\"pojo参数传递 user ==> \\\"+user); return \\\"{'module':'pojo param'}\\\"; } \",\"注意:\",\"POJO参数接收，前端GET和POST发送请求数据的方式不变\",\"请求参数key的名称要和POJO中属性的名称一致，否则无法封装\"]},{\"header\":\"3.3.3 嵌套POJO类型参数\",\"slug\":\"_3-3-3-嵌套pojo类型参数\",\"contents\":[\"如果POJO对象中嵌套了其他的POJO类，如\",\"public class Address { private String province; private String city; //setter...getter...略 } public class User { private String name; private int age; private Address address; //setter...getter...略 } \",\"嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数\",\"发送请求和参数:\",\"后台接收参数:\",\"//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递 @RequestMapping(\\\"/pojoParam\\\") @ResponseBody public String pojoParam(User user){ System.out.println(\\\"pojo参数传递 user ==> \\\"+user); return \\\"{'module':'pojo param'}\\\"; } \"]},{\"header\":\"3.3.4 数组类型参数\",\"slug\":\"_3-3-4-数组类型参数\",\"contents\":[\"举个简单的例子，如果前端需要获取用户的爱好，爱好绝大多数情况下都是多个，如何发送请求数据和接收数据呢?\",\"数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型即可接收参数\",\"发送请求和参数:\",\"后台接收参数:\",\" //数组参数：同名请求参数可以直接映射到对应名称的形参数组对象中 @RequestMapping(\\\"/arrayParam\\\") @ResponseBody public String arrayParam(String[] likes){ System.out.println(\\\"数组参数传递 likes ==> \\\"+ Arrays.toString(likes)); return \\\"{'module':'array param'}\\\"; } \"]},{\"header\":\"3.3.5 集合类型参数\",\"slug\":\"_3-3-5-集合类型参数\",\"contents\":[\"数组能接收多个值，那么集合是否也可以实现这个功能呢?\",\"发送请求和参数:\",\"后台接收参数:\",\"//集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据 @RequestMapping(\\\"/listParam\\\") @ResponseBody public String listParam(List<String> likes){ System.out.println(\\\"集合参数传递 likes ==> \\\"+ likes); return \\\"{'module':'list param'}\\\"; } \",\"运行会报错，\",\"错误的原因是：SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错\",\"解决方案是：使用@RequestParam注解\",\"//集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据 @RequestMapping(\\\"/listParam\\\") @ResponseBody public String listParam(@RequestParam List<String> likes){ System.out.println(\\\"集合参数传递 likes ==> \\\"+ likes); return \\\"{'module':'list param'}\\\"; } \",\"集合保存普通参数：请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系\",\"对于简单数据类型使用数组会比集合更简单些\"]},{\"header\":\"知识点1：@RequestParam\",\"slug\":\"知识点1-requestparam\",\"contents\":[\"名称\",\"@RequestParam\",\"类型\",\"形参注解\",\"位置\",\"SpringMVC控制器方法形参定义前面\",\"作用\",\"绑定请求参数与处理器方法形参间的关系\",\"相关参数\",\"required：是否为必传参数 defaultValue：参数默认值\"]},{\"header\":\"3.4 JSON数据传输参数\",\"slug\":\"_3-4-json数据传输参数\",\"contents\":[\"现在比较流行的开发方式为异步调用。前后台以异步方式进行交换，传输的数据使用的是JSON，所以前端如果发送的是JSON数据，后端该如何接收?\",\"对于JSON数据类型:\",\"json普通数组（[\\\"value1\\\",\\\"value2\\\",\\\"value3\\\",...]）\",\"json对象（{key1:value1,key2:value2,...}）\",\"json对象数组（[{key1:value1,...},{key2:value2,...}]）\"]},{\"header\":\"JSON普通数组\",\"slug\":\"json普通数组\",\"contents\":[]},{\"header\":\"步骤1:pom.xml添加依赖\",\"slug\":\"步骤1-pom-xml添加依赖\",\"contents\":[\"SpringMVC默认使用的是jackson来处理json的转换，所以需要在pom.xml添加jackson依赖\",\"<dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.9.0</version> </dependency> \"]},{\"header\":\"步骤2:PostMan发送JSON数据\",\"slug\":\"步骤2-postman发送json数据\",\"contents\":[]},{\"header\":\"步骤3:开启SpringMVC注解支持\",\"slug\":\"步骤3-开启springmvc注解支持\",\"contents\":[\"在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能\",\"@Configuration @ComponentScan(\\\"com.itheima.controller\\\") //开启json数据类型自动转换 @EnableWebMvc public class SpringMvcConfig { } \"]},{\"header\":\"步骤4:参数前添加@RequestBody\",\"slug\":\"步骤4-参数前添加-requestbody\",\"contents\":[\"//使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据 @RequestMapping(\\\"/listParamForJson\\\") @ResponseBody public String listParamForJson(@RequestBody List<String> likes){ System.out.println(\\\"list common(json)参数传递 list ==> \\\"+likes); return \\\"{'module':'list common for json param'}\\\"; } \"]},{\"header\":\"步骤5:启动运行程序\",\"slug\":\"步骤5-启动运行程序\",\"contents\":[]},{\"header\":\"JSON对象数据\",\"slug\":\"json对象数据\",\"contents\":[\"请求和数据的发送:\",\"{ \\\"name\\\":\\\"itcast\\\", \\\"age\\\":15 } \",\"后端接收数据：\",\"@RequestMapping(\\\"/pojoParamForJson\\\") @ResponseBody public String pojoParamForJson(@RequestBody User user){ System.out.println(\\\"pojo(json)参数传递 user ==> \\\"+user); return \\\"{'module':'pojo for json param'}\\\"; } \",\"启动程序访问测试\",\"说明:\",\"address为null的原因是前端没有传递数据给后端\",\"如果想要address也有数据\",\"{ \\\"name\\\":\\\"itcast\\\", \\\"age\\\":15, \\\"address\\\":{ \\\"province\\\":\\\"beijing\\\", \\\"city\\\":\\\"beijing\\\" } } \",\"再次发送请求，就能看到address中的数据\"]},{\"header\":\"JSON对象数组\",\"slug\":\"json对象数组\",\"contents\":[\"如何集合中保存多个POJO该如何实现?\",\"请求和数据的发送:\",\"[ {\\\"name\\\":\\\"itcast\\\",\\\"age\\\":15}, {\\\"name\\\":\\\"itheima\\\",\\\"age\\\":12} ] \",\"后端接收数据:\",\"@RequestMapping(\\\"/listPojoParamForJson\\\") @ResponseBody public String listPojoParamForJson(@RequestBody List<User> list){ System.out.println(\\\"list pojo(json)参数传递 list ==> \\\"+list); return \\\"{'module':'list pojo for json param'}\\\"; } \",\"启动程序访问测试\"]},{\"header\":\"小结\",\"slug\":\"小结\",\"contents\":[\"SpringMVC接收JSON数据的实现步骤为:\",\"导入jackson包\",\"使用PostMan发送JSON数据\",\"开启SpringMVC注解驱动，在配置类上添加@EnableWebMvc注解\",\"Controller方法的参数前添加@RequestBody注解\"]},{\"header\":\"知识点1：@EnableWebMvc\",\"slug\":\"知识点1-enablewebmvc\",\"contents\":[\"名称\",\"@EnableWebMvc\",\"类型\",\"配置类注解\",\"位置\",\"SpringMVC配置类定义上方\",\"作用\",\"开启SpringMVC多项辅助功能\"]},{\"header\":\"知识点2：@RequestBody\",\"slug\":\"知识点2-requestbody\",\"contents\":[\"名称\",\"@RequestBody\",\"类型\",\"形参注解\",\"位置\",\"SpringMVC控制器方法形参定义前面\",\"作用\",\"将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次\"]},{\"header\":\"@RequestBody与@RequestParam区别\",\"slug\":\"requestbody与-requestparam区别\",\"contents\":[\"区别\",\"@RequestParam用于接收url地址传参，表单传参【application/x-www-form-urlencoded】\",\"@RequestBody用于接收json数据【application/json】\",\"应用\",\"后期开发中，发送json格式数据为主，@RequestBody应用较广\",\"如果发送非json格式数据，选用@RequestParam接收请求参数\"]},{\"header\":\"3.5 日期类型参数传递\",\"slug\":\"_3-5-日期类型参数传递\",\"contents\":[\"日期类型比较特殊，因为对于日期的格式有N多中输入方式，比如:\",\"2088-08-18\",\"2088/08/18\",\"08/18/2088\",\"......\"]},{\"header\":\"步骤1:编写方法接收日期数据\",\"slug\":\"步骤1-编写方法接收日期数据\",\"contents\":[\"在UserController类中添加方法，把参数设置为日期类型\",\"@RequestMapping(\\\"/dataParam\\\") @ResponseBody public String dataParam(Date date) System.out.println(\\\"参数传递 date ==> \\\"+date); return \\\"{'module':'data param'}\\\"; } \"]},{\"header\":\"步骤2:启动Tomcat服务器\",\"slug\":\"步骤2-启动tomcat服务器\",\"contents\":[\"查看控制台是否报错，如果有错误，先解决错误。\"]},{\"header\":\"步骤3:使用PostMan发送请求\",\"slug\":\"步骤3-使用postman发送请求\",\"contents\":[\"使用PostMan发送GET请求，并设置date参数\",\"http://localhost/dataParam?date=2088/08/08\"]},{\"header\":\"步骤4:查看控制台\",\"slug\":\"步骤4-查看控制台\",\"contents\":[]},{\"header\":\"步骤5:更换日期格式\",\"slug\":\"步骤5-更换日期格式\",\"contents\":[\"为了能更好的看到程序运行的结果，在方法中多添加一个日期参数\",\"@RequestMapping(\\\"/dataParam\\\") @ResponseBody public String dataParam(Date date,Date date1) System.out.println(\\\"参数传递 date ==> \\\"+date); return \\\"{'module':'data param'}\\\"; } \",\"使用PostMan发送请求，携带两个不同的日期格式，\",\"http://localhost/dataParam?date=2088/08/08&date1=2088-08-08\",\"发送请求和数据后，页面会报400，控制台会报错一个错误\",\"Resolved org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.util.Date'; nested exception is org.springframework.core.convert. ConversionFailedException: Failed to convert from type java.lang.String to type java.util.Date for value '2088-08-08'; nested exception is java.lang.IllegalArgumentException \",\"从错误信息可以看出，错误的原因是在将2088-08-08转换成日期类型的时候失败了，原因是SpringMVC默认支持的字符串转日期的格式为yyyy/MM/dd\",\"解决方案使用@DateTimeFormat\",\"@RequestMapping(\\\"/dataParam\\\") @ResponseBody public String dataParam(Date date, @DateTimeFormat(pattern=\\\"yyyy-MM-dd\\\") Date date1) System.out.println(\\\"参数传递 date ==> \\\"+date); System.out.println(\\\"参数传递 date1(yyyy-MM-dd) ==> \\\"+date1); return \\\"{'module':'data param'}\\\"; \"]},{\"header\":\"步骤6:携带时间的日期\",\"slug\":\"步骤6-携带时间的日期\",\"contents\":[\"@RequestMapping(\\\"/dataParam\\\") @ResponseBody public String dataParam(Date date, @DateTimeFormat(pattern=\\\"yyyy-MM-dd\\\") Date date1, @DateTimeFormat(pattern=\\\"yyyy/MM/dd HH:mm:ss\\\") Date date2) System.out.println(\\\"参数传递 date ==> \\\"+date); System.out.println(\\\"参数传递 date1(yyyy-MM-dd) ==> \\\"+date1); System.out.println(\\\"参数传递 date2(yyyy/MM/dd HH:mm:ss) ==> \\\"+date2); return \\\"{'module':'data param'}\\\"; } \",\"使用PostMan发送请求，携带两个不同的日期格式，\",\"http://localhost/dataParam?date=2088/08/08&date1=2088-08-08&date2=2088/08/08 8:08:08\",\"重新启动服务器，重新发送请求测试，SpringMVC就可以将日期时间的数据进行转换\"]},{\"header\":\"知识点1：@DateTimeFormat\",\"slug\":\"知识点1-datetimeformat\",\"contents\":[\"名称\",\"@DateTimeFormat\",\"类型\",\"形参注解\",\"位置\",\"SpringMVC控制器方法形参前面\",\"作用\",\"设定日期时间型数据格式\",\"相关属性\",\"pattern：指定日期时间格式字符串\"]},{\"header\":\"内部实现原理\",\"slug\":\"内部实现原理\",\"contents\":[\"思考:\",\"前端传递字符串，后端使用日期Date接收\",\"前端传递JSON数据，后端使用对象接收\",\"后台需要的数据类型有很多中\",\"前端传递字符串，后端使用Integer接收\",\"在数据的传递过程中存在很多类型的转换\",\"问: 谁来做这个类型转换?\",\"答: SpringMVC\",\"问：SpringMVC是如何实现类型转换的?\",\"答: Converter接口\",\"Converter接口\",\"/** * S: the source type * T: the target type */ public interface Converter<S, T> { @Nullable //该方法就是将从页面上接收的数据(S)转换成我们想要的数据类型(T)返回 T convert(S source); } \",\"注意:Converter所属的包为org.springframework.core.convert.converter\",\"Converter接口的实现类\",\"框架中有提供很多对应Converter接口的实现类，用来实现不同数据类型之间的转换\",\"请求参数年龄数据（String→Integer）\",\"json数据转对象（json → POJO）\",\"日期格式转换（String → Date）\",\"注意: SpringMVC的配置类把@EnableWebMvc当做标配配置上去，不要省略\"]},{\"header\":\"3.6 响应\",\"slug\":\"_3-6-响应\",\"contents\":[\"SpringMVC接收到请求和数据后，进行一些了的处理，当然这个处理可以是转发给Service，Service层再调用Dao层完成的，不管怎样，处理完以后，都需要将结果告知给用户\",\"比如：根据用户ID查询用户信息、查询用户列表、新增用户等\",\"对于响应，主要就包含两部分内容：\",\"响应页面\",\"响应数据 \",\"文本数据\",\"json数据\"]},{\"header\":\"3.6.1 环境准备\",\"slug\":\"_3-6-1-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加Spring依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_05_response</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <dependencies> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.9.0</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> </plugins> </build> </project> \",\"创建对应的配置类\",\"public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class<?>[] getRootConfigClasses() { return new Class][0; } protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } //乱码处理 @Override protected Filter[] getServletFilters() { CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\\\"UTF-8\\\"); return new Filter[]{filter}; } } @Configuration @ComponentScan(\\\"com.itheima.controller\\\") //开启json数据类型自动转换 @EnableWebMvc public class SpringMvcConfig { } \",\"编写模型类User\",\"public class User { private String name; private int age; //getter...setter...toString省略 } \",\"webapp下创建page.jsp\",\"<html> <body> <h2>Hello Spring MVC!</h2> </body> </html> \",\"编写UserController\",\"@Controller public class UserController { } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"3.6.2 响应页面 了解\",\"slug\":\"_3-6-2-响应页面-了解\",\"contents\":[]},{\"header\":\"步骤1:设置返回页面\",\"slug\":\"步骤1-设置返回页面\",\"contents\":[\"@Controller public class UserController { @RequestMapping(\\\"/toJumpPage\\\") //注意 //1.此处不能添加@ResponseBody,如果加了该注入，会直接将page.jsp当字符串返回前端 //2.方法需要返回String public String toJumpPage(){ System.out.println(\\\"跳转页面\\\"); return \\\"page.jsp\\\"; } } \"]},{\"header\":\"步骤2:启动程序测试\",\"slug\":\"步骤2-启动程序测试\",\"contents\":[\"此处涉及到页面跳转，所以不适合采用PostMan进行测试，直接打开浏览器，输入\",\"http://localhost/toJumpPage\"]},{\"header\":\"3.6.3 返回文本数据（了解）\",\"slug\":\"_3-6-3-返回文本数据-了解\",\"contents\":[]},{\"header\":\"步骤1:设置返回文本内容\",\"slug\":\"步骤1-设置返回文本内容\",\"contents\":[\"@Controller public class UserController { @RequestMapping(\\\"/toText\\\") //注意此处该注解就不能省略，如果省略了,会把response text当前页面名称去查找，如果没有回报404错误 @ResponseBody public String toText(){ System.out.println(\\\"返回纯文本数据\\\"); return \\\"response text\\\"; } } \"]},{\"header\":\"步骤2: 启动程序测试\",\"slug\":\"步骤2-启动程序测试-1\",\"contents\":[\"此处不涉及到页面跳转，现在发送的是post请求，可以使用浏览器也可以使用PostMan进行测试，输入地址http://localhost/toText访问\"]},{\"header\":\"3.6.4 响应JSON数据\",\"slug\":\"_3-6-4-响应json数据\",\"contents\":[]},{\"header\":\"响应POJO对象\",\"slug\":\"响应pojo对象\",\"contents\":[\"@Controller public class UserController { @RequestMapping(\\\"/toJsonPOJO\\\") @ResponseBody public User toJsonPOJO(){ System.out.println(\\\"返回json对象数据\\\"); User user = new User(); user.setName(\\\"itcast\\\"); user.setAge(15); return user; } } \",\"返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖 @ResponseBody 注解和 @EnableWebMvc注解\",\"重新启动服务器，访问http://localhost/toJsonPOJO\"]},{\"header\":\"响应POJO集合对象\",\"slug\":\"响应pojo集合对象\",\"contents\":[\"@Controller public class UserController { @RequestMapping(\\\"/toJsonList\\\") @ResponseBody public List<User> toJsonList(){ System.out.println(\\\"返回json集合数据\\\"); User user1 = new User(); user1.setName(\\\"传智播客\\\"); user1.setAge(15); User user2 = new User(); user2.setName(\\\"黑马程序员\\\"); user2.setAge(12); List<User> userList = new ArrayList<User>(); userList.add(user1); userList.add(user2); return userList; } } \",\"重新启动服务器，访问http://localhost/toJsonList\"]},{\"header\":\"知识点1：@ResponseBody\",\"slug\":\"知识点1-responsebody\",\"contents\":[\"名称\",\"@ResponseBody\",\"类型\",\"方法\\\\类注解\",\"位置\",\"SpringMVC控制器方法定义上方和控制类上\",\"作用\",\"设置当前控制器返回值作为响应体,写在类上，该类的所有方法都有该注解功能\",\"相关属性\",\"pattern：指定日期时间格式字符串\",\"说明:\",\"该注解可以写在类上或者方法上\",\"写在类上就是该类下的所有方法都有@ReponseBody功能\",\"当方法上有@ReponseBody注解后 \",\"方法的返回值为字符串，会将其作为文本内容直接响应给前端\",\"方法的返回值为对象，会将对象转换成JSON响应给前端\"]},{\"header\":\"4 Rest风格\",\"slug\":\"_4-rest风格\",\"contents\":[\"REST简介\",\"REST入门案例\",\"REST快速开发\",\"案例:基于RESTful页面数据交互\"]},{\"header\":\"4.1 REST简介\",\"slug\":\"_4-1-rest简介\",\"contents\":[\"REST（Representational State Transfer），表现形式状态转换，它是一种软件架构风格\",\"传统风格资源描述形式 \",\"http://localhost/user/getById?id=1 查询id为1的用户信息\",\"http://localhost/user/saveUser 保存用户信息\",\"REST风格描述形式 \",\"http://localhost/user/1\",\"http://localhost/user\",\"REST的优点有\",\"隐藏资源的访问行为，无法通过地址得知对资源是何种操作\",\"书写简化\",\"问题： 一个相同的url地址即可以是新增也可以是修改或者查询，那么该如何区分该请求到底是什么操作呢?\",\"按照REST风格访问资源时使用行为动作区分对资源进行了何种操作 \",\"http://localhost/users 查询全部用户信息 GET（查询）\",\"http://localhost/users/1 查询指定用户信息 GET（查询）\",\"http://localhost/users 添加用户信息 POST（新增/保存）\",\"http://localhost/users 修改用户信息 PUT（修改/更新）\",\"http://localhost/users/1 删除用户信息 DELETE（删除）\",\"请求的方式比较多，但是比较常用的就4种，分别是GET,POST,PUT,DELETE\",\"注意:\",\"上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范 \",\"REST提供了对应的架构方式，按照这种架构设计项目可以降低开发的复杂性，提高系统的可伸缩性\",\"REST中规定GET/POST/PUT/DELETE针对的是查询/新增/修改/删除，但是如果非要用GET请求做删除，这点在程序上运行是可以实现的\",\"但是如果绝大多数人都遵循这种风格，你写的代码让别人读起来就有点莫名其妙了。\",\"描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如：users、books、accounts......\",\"清楚了什么是REST风格后，那什么又是RESTful呢?\",\"根据REST风格对资源进行访问称为RESTful\"]},{\"header\":\"4.2 RESTful入门案例\",\"slug\":\"_4-2-restful入门案例\",\"contents\":[]},{\"header\":\"4.2.1 环境准备\",\"slug\":\"_4-2-1-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加Spring依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_06_rest</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <dependencies> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.9.0</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> </plugins> </build> </project> \",\"创建对应的配置类\",\"public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class<?>[] getRootConfigClasses() { return new Class][0; } protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } //乱码处理 @Override protected Filter[] getServletFilters() { CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\\\"UTF-8\\\"); return new Filter[]{filter}; } } @Configuration @ComponentScan(\\\"com.itheima.controller\\\") //开启json数据类型自动转换 @EnableWebMvc public class SpringMvcConfig { } \",\"编写模型类User和Book\",\"public class User { private String name; private int age; //getter...setter...toString省略 } public class Book { private String name; private double price; //getter...setter...toString省略 } \",\"编写UserController和BookController\",\"@Controller public class UserController { @RequestMapping(\\\"/save\\\") @ResponseBody public String save(@RequestBody User user) { System.out.println(\\\"user save...\\\"+user); return \\\"{'module':'user save'}\\\"; } @RequestMapping(\\\"/delete\\\") @ResponseBody public String delete(Integer id) { System.out.println(\\\"user delete...\\\" + id); return \\\"{'module':'user delete'}\\\"; } @RequestMapping(\\\"/update\\\") @ResponseBody public String update(@RequestBody User user) { System.out.println(\\\"user update...\\\" + user); return \\\"{'module':'user update'}\\\"; } @RequestMapping(\\\"/getById\\\") @ResponseBody public String getById(Integer id) { System.out.println(\\\"user getById...\\\" + id); return \\\"{'module':'user getById'}\\\"; } @RequestMapping(\\\"/findAll\\\") @ResponseBody public String getAll() { System.out.println(\\\"user getAll...\\\"); return \\\"{'module':'user getAll'}\\\"; } } @Controller public class BookController { @RequestMapping(value = \\\"/books\\\",method = RequestMethod.POST) @ResponseBody public String save(@RequestBody Book book){ System.out.println(\\\"book save...\\\" + book); return \\\"{'module':'book save'}\\\"; } @RequestMapping(value = \\\"/books/{id}\\\",method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable Integer id){ System.out.println(\\\"book delete...\\\" + id); return \\\"{'module':'book delete'}\\\"; } @RequestMapping(value = \\\"/books\\\",method = RequestMethod.PUT) @ResponseBody public String update(@RequestBody Book book){ System.out.println(\\\"book update...\\\" + book); return \\\"{'module':'book update'}\\\"; } @RequestMapping(value = \\\"/books/{id}\\\",method = RequestMethod.GET) @ResponseBody public String getById(@PathVariable Integer id){ System.out.println(\\\"book getById...\\\" + id); return \\\"{'module':'book getById'}\\\"; } @RequestMapping(value = \\\"/books\\\",method = RequestMethod.GET) @ResponseBody public String getAll(){ System.out.println(\\\"book getAll...\\\"); return \\\"{'module':'book getAll'}\\\"; } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"4.2.2 思路分析\",\"slug\":\"_4-2-2-思路分析\",\"contents\":[\"需求：将之前的增删改查替换成RESTful的开发方式\",\"之前不同的请求有不同的路径,现在要将其修改为统一的请求路径 修改前: 新增: /save ,修改: /update,删除 /delete... 修改后: 增删改查: /users\",\"根据GET查询、POST新增、PUT修改、DELETE删除对方法的请求方式进行限定\",\"发送请求的过程中如何设置请求参数?\"]},{\"header\":\"4.2.3 修改RESTful风格\",\"slug\":\"_4-2-3-修改restful风格\",\"contents\":[]},{\"header\":\"新增\",\"slug\":\"新增\",\"contents\":[\"@Controller public class UserController { //设置当前请求方法为POST，表示REST风格中的添加操作 @RequestMapping(value = \\\"/users\\\",method = RequestMethod.POST) @ResponseBody public String save() { System.out.println(\\\"user save...\\\"); return \\\"{'module':'user save'}\\\"; } } \",\"将请求路径更改为/users\",\"访问该方法使用 POST: http://localhost/users\",\"使用method属性限定该方法的访问方式为POST\",\"如果发送的不是POST请求，比如发送GET请求，则会报错\"]},{\"header\":\"删除\",\"slug\":\"删除\",\"contents\":[\"@Controller public class UserController { //设置当前请求方法为DELETE，表示REST风格中的删除操作 @RequestMapping(value = \\\"/users\\\",method = RequestMethod.DELETE) @ResponseBody public String delete(Integer id) { System.out.println(\\\"user delete...\\\" + id); return \\\"{'module':'user delete'}\\\"; } } \",\"将请求路径更改为/users\",\"访问该方法使用 DELETE: http://localhost/users\",\"访问成功，但是删除方法没有携带所要删除数据的id，所以针对RESTful的开发，如何携带数据参数?\"]},{\"header\":\"传递路径参数\",\"slug\":\"传递路径参数\",\"contents\":[\"前端发送请求的时候使用:http://localhost/users/1,路径中的1就是想要传递的参数。\",\"后端获取参数，需要做如下修改:\",\"修改@RequestMapping的value属性，将其中修改为/users/{id}，目的是和路径匹配\",\"在方法的形参前添加@PathVariable注解\",\"@Controller public class UserController { //设置当前请求方法为DELETE，表示REST风格中的删除操作 @RequestMapping(value = \\\"/users/{id}\\\",method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable Integer id) { System.out.println(\\\"user delete...\\\" + id); return \\\"{'module':'user delete'}\\\"; } } \",\"思考如下两个问题:\",\"(1)如果方法形参的名称和路径{}中的值不一致，该怎么办?\",\"(2)如果有多个参数需要传递该如何编写?\",\"前端发送请求的时候使用:http://localhost/users/1/tom,路径中的1和tom就是我们想要传递的两个参数\",\"后端获取参数，需要做如下修改：\",\"@Controller public class UserController { //设置当前请求方法为DELETE，表示REST风格中的删除操作 @RequestMapping(value = \\\"/users/{id}/{name}\\\",method = RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable Integer id,@PathVariable String name) { System.out.println(\\\"user delete...\\\" + id+\\\",\\\"+name); return \\\"{'module':'user delete'}\\\"; } } \"]},{\"header\":\"修改\",\"slug\":\"修改\",\"contents\":[\"@Controller public class UserController { //设置当前请求方法为PUT，表示REST风格中的修改操作 @RequestMapping(value = \\\"/users\\\",method = RequestMethod.PUT) @ResponseBody public String update(@RequestBody User user) { System.out.println(\\\"user update...\\\" + user); return \\\"{'module':'user update'}\\\"; } } \",\"将请求路径更改为/users\",\"访问该方法使用 PUT: http://localhost/users\",\"访问并携带参数:\"]},{\"header\":\"根据ID查询\",\"slug\":\"根据id查询\",\"contents\":[\"@Controller public class UserController { //设置当前请求方法为GET，表示REST风格中的查询操作 @RequestMapping(value = \\\"/users/{id}\\\" ,method = RequestMethod.GET) @ResponseBody public String getById(@PathVariable Integer id){ System.out.println(\\\"user getById...\\\"+id); return \\\"{'module':'user getById'}\\\"; } } \",\"将请求路径更改为/users\",\"访问该方法使用 GET: http://localhost/users/666\"]},{\"header\":\"查询所有\",\"slug\":\"查询所有\",\"contents\":[\"@Controller public class UserController { //设置当前请求方法为GET，表示REST风格中的查询操作 @RequestMapping(value = \\\"/users\\\" ,method = RequestMethod.GET) @ResponseBody public String getAll() { System.out.println(\\\"user getAll...\\\"); return \\\"{'module':'user getAll'}\\\"; } } \",\"将请求路径更改为/users\",\"访问该方法使用 GET: http://localhost/users\",\"小结\",\"(1)设定Http请求动作(动词)\",\"@RequestMapping(value=\\\"\\\",method = RequestMethod.POST|GET|PUT|DELETE)\",\"(2)设定请求参数(路径变量)\",\"@RequestMapping(value=\\\"/users/{id}\\\",method = RequestMethod.DELETE)\",\"@ReponseBody\",\"public String delete(@PathVariable Integer id){\",\"}\"]},{\"header\":\"知识点1：@PathVariable\",\"slug\":\"知识点1-pathvariable\",\"contents\":[\"名称\",\"@PathVariable\",\"类型\",\"形参注解\",\"位置\",\"SpringMVC控制器方法形参定义前面\",\"作用\",\"绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应\",\"关于接收参数，@RequestBody、@RequestParam、@PathVariable，这三个注解之间的区别和应用分别是什么?\",\"区别 \",\"@RequestParam用于接收url地址传参或表单传参\",\"@RequestBody用于接收json数据\",\"@PathVariable用于接收路径参数，使用{参数名称}描述路径参数\",\"应用 \",\"后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广\",\"如果发送非json格式数据，选用@RequestParam接收请求参数\",\"采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值\"]},{\"header\":\"4.3 RESTful快速开发\",\"slug\":\"_4-3-restful快速开发\",\"contents\":[\"问题1：每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高\",\"问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高\",\"问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高\",\"对于上面所提的这三个问题，具体该如何解决?\",\"@RestController //@Controller + ReponseBody @RequestMapping(\\\"/books\\\") public class BookController { //@RequestMapping(method = RequestMethod.POST) @PostMapping public String save(@RequestBody Book book){ System.out.println(\\\"book save...\\\" + book); return \\\"{'module':'book save'}\\\"; } //@RequestMapping(value = \\\"/{id}\\\",method = RequestMethod.DELETE) @DeleteMapping(\\\"/{id}\\\") public String delete(@PathVariable Integer id){ System.out.println(\\\"book delete...\\\" + id); return \\\"{'module':'book delete'}\\\"; } //@RequestMapping(method = RequestMethod.PUT) @PutMapping public String update(@RequestBody Book book){ System.out.println(\\\"book update...\\\" + book); return \\\"{'module':'book update'}\\\"; } //@RequestMapping(value = \\\"/{id}\\\",method = RequestMethod.GET) @GetMapping(\\\"/{id}\\\") public String getById(@PathVariable Integer id){ System.out.println(\\\"book getById...\\\" + id); return \\\"{'module':'book getById'}\\\"; } //@RequestMapping(method = RequestMethod.GET) @GetMapping public String getAll(){ System.out.println(\\\"book getAll...\\\"); return \\\"{'module':'book getAll'}\\\"; } } \",\"问题1：每个方法的@RequestMapping注解中都定义了访问路径/books，重复性太高\",\"将@RequestMapping提到类上面，用来定义所有方法共同的访问路径。 \",\"问题2：每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高\",\"使用@GetMapping @PostMapping @PutMapping @DeleteMapping代替 \",\"问题3：每个方法响应json都需要加上@ResponseBody注解，重复性太高\",\"1.将ResponseBody提到类上面，让所有的方法都有@ResponseBody的功能 2.使用@RestController注解替换@Controller与@ResponseBody注解，简化书写 \"]},{\"header\":\"知识点1：@RestController\",\"slug\":\"知识点1-restcontroller\",\"contents\":[\"名称\",\"@RestController\",\"类型\",\"类注解\",\"位置\",\"基于SpringMVC的RESTful开发控制器类定义上方\",\"作用\",\"设置当前控制器类为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能\"]},{\"header\":\"知识点2：@GetMapping @PostMapping @PutMapping @DeleteMapping\",\"slug\":\"知识点2-getmapping-postmapping-putmapping-deletemapping\",\"contents\":[\"名称\",\"@GetMapping @PostMapping @PutMapping @DeleteMapping\",\"类型\",\"方法注解\",\"位置\",\"基于SpringMVC的RESTful开发控制器方法定义上方\",\"作用\",\"设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求\",\"相关属性\",\"value（默认）：请求访问路径\"]},{\"header\":\"4.4 RESTful案例\",\"slug\":\"_4-4-restful案例\",\"contents\":[]},{\"header\":\"4.4.1 需求分析\",\"slug\":\"_4-4-1-需求分析\",\"contents\":[\"需求一:图片列表查询，从后台返回数据，将数据展示在页面上\",\"需求二:新增图片，将新增图书的数据传递到后台，并在控制台打印\",\"说明: 此次案例的重点是在SpringMVC中如何使用RESTful实现前后台交互，所以本案例并没有和数据库进行交互，所有数据使用假数据来完成开发。\",\"步骤分析:\",\"1.搭建项目导入jar包\",\"2.编写Controller类，提供两个方法，一个用来做列表查询，一个用来做新增\",\"3.在方法上使用RESTful进行路径设置\",\"4.完成请求、参数的接收和结果的响应\",\"5.使用PostMan进行测试\",\"6.将前端页面拷贝到项目中\",\"7.页面发送ajax请求\",\"8.完成页面数据的展示\"]},{\"header\":\"4.4.2 环境准备\",\"slug\":\"_4-4-2-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加Spring依赖\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_07_rest_case</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <dependencies> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.9.0</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> </plugins> </build> </project> \",\"创建对应的配置类\",\"public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class<?>[] getRootConfigClasses() { return new Class[0]; } protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } //乱码处理 @Override protected Filter[] getServletFilters() { CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\\\"UTF-8\\\"); return new Filter[]{filter}; } } @Configuration @ComponentScan(\\\"com.itheima.controller\\\") //开启json数据类型自动转换 @EnableWebMvc public class SpringMvcConfig { } \",\"编写模型类Book\",\"public class Book { private Integer id; private String type; private String name; private String description; //setter...getter...toString略 } \",\"编写BookController\",\"@Controller public class BookController { } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"4.4.2 后台接口开发\",\"slug\":\"_4-4-2-后台接口开发\",\"contents\":[]},{\"header\":\"步骤1:编写Controller类并使用RESTful进行配置\",\"slug\":\"步骤1-编写controller类并使用restful进行配置\",\"contents\":[\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @PostMapping public String save(@RequestBody Book book){ System.out.println(\\\"book save ==> \\\"+ book); return \\\"{'module':'book save success'}\\\"; } @GetMapping public List<Book> getAll(){ System.out.println(\\\"book getAll is running ...\\\"); List<Book> bookList = new ArrayList<Book>(); Book book1 = new Book(); book1.setType(\\\"计算机\\\"); book1.setName(\\\"SpringMVC入门教程\\\"); book1.setDescription(\\\"小试牛刀\\\"); bookList.add(book1); Book book2 = new Book(); book2.setType(\\\"计算机\\\"); book2.setName(\\\"SpringMVC实战教程\\\"); book2.setDescription(\\\"一代宗师\\\"); bookList.add(book2); Book book3 = new Book(); book3.setType(\\\"计算机丛书\\\"); book3.setName(\\\"SpringMVC实战教程进阶\\\"); book3.setDescription(\\\"一代宗师呕心创作\\\"); bookList.add(book3); return bookList; } } \"]},{\"header\":\"步骤2：使用PostMan进行测试\",\"slug\":\"步骤2-使用postman进行测试\",\"contents\":[\"测试新增\",\"{ \\\"type\\\":\\\"计算机丛书\\\", \\\"name\\\":\\\"SpringMVC终极开发\\\", \\\"description\\\":\\\"这是一本好书\\\" } \",\"测试查询\"]},{\"header\":\"4.4.3 页面访问处理\",\"slug\":\"_4-4-3-页面访问处理\",\"contents\":[]},{\"header\":\"步骤1:拷贝静态页面\",\"slug\":\"步骤1-拷贝静态页面\",\"contents\":[\"将资料\\\\功能页面下的所有内容拷贝到项目的webapp目录下\"]},{\"header\":\"步骤2:访问pages目录下的books.html\",\"slug\":\"步骤2-访问pages目录下的books-html\",\"contents\":[\"打开浏览器输入http://localhost/pages/books.html\",\"(1)出现错误的原因?\",\"SpringMVC拦截了静态资源，根据/pages/books.html去controller找对应的方法，找不到所以会报404的错误\",\"(2)SpringMVC为什么会拦截静态资源呢?\",\"(3)解决方案\",\"SpringMVC需要将静态资源进行放行。\",\"@Configuration public class SpringMvcSupport extends WebMvcConfigurationSupport { //设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载 @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { //当访问/pages/????时候，从/pages目录下查找内容 registry.addResourceHandler(\\\"/pages/**\\\").addResourceLocations(\\\"/pages/\\\"); registry.addResourceHandler(\\\"/js/**\\\").addResourceLocations(\\\"/js/\\\"); registry.addResourceHandler(\\\"/css/**\\\").addResourceLocations(\\\"/css/\\\"); registry.addResourceHandler(\\\"/plugins/**\\\").addResourceLocations(\\\"/plugins/\\\"); } } \",\"该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改\",\"@Configuration @ComponentScan({\\\"com.itheima.controller\\\",\\\"com.itheima.config\\\"}) @EnableWebMvc public class SpringMvcConfig { } 或者 @Configuration @ComponentScan(\\\"com.itheima\\\") @EnableWebMvc public class SpringMvcConfig { } \"]},{\"header\":\"步骤3:修改books.html页面\",\"slug\":\"步骤3-修改books-html页面\",\"contents\":[\"<!DOCTYPE html> <html> <head> <!-- 页面meta --> <meta charset=\\\"utf-8\\\"> <title>SpringMVC案例</title> <!-- 引入样式 --> <link rel=\\\"stylesheet\\\" href=\\\"../plugins/elementui/index.css\\\"> <link rel=\\\"stylesheet\\\" href=\\\"../plugins/font-awesome/css/font-awesome.min.css\\\"> <link rel=\\\"stylesheet\\\" href=\\\"../css/style.css\\\"> </head> <body class=\\\"hold-transition\\\"> <div id=\\\"app\\\"> <div class=\\\"content-header\\\"> <h1>图书管理</h1> </div> <div class=\\\"app-container\\\"> <div class=\\\"box\\\"> <div class=\\\"filter-container\\\"> <el-input placeholder=\\\"图书名称\\\" style=\\\"width: 200px;\\\" class=\\\"filter-item\\\"></el-input> <el-button class=\\\"dalfBut\\\">查询</el-button> <el-button type=\\\"primary\\\" class=\\\"butT\\\" @click=\\\"openSave()\\\">新建</el-button> </div> <el-table size=\\\"small\\\" current-row-key=\\\"id\\\" :data=\\\"dataList\\\" stripe highlight-current-row> <el-table-column type=\\\"index\\\" align=\\\"center\\\" label=\\\"序号\\\"></el-table-column> <el-table-column prop=\\\"type\\\" label=\\\"图书类别\\\" align=\\\"center\\\"></el-table-column> <el-table-column prop=\\\"name\\\" label=\\\"图书名称\\\" align=\\\"center\\\"></el-table-column> <el-table-column prop=\\\"description\\\" label=\\\"描述\\\" align=\\\"center\\\"></el-table-column> <el-table-column label=\\\"操作\\\" align=\\\"center\\\"> <template slot-scope=\\\"scope\\\"> <el-button type=\\\"primary\\\" size=\\\"mini\\\">编辑</el-button> <el-button size=\\\"mini\\\" type=\\\"danger\\\">删除</el-button> </template> </el-table-column> </el-table> <div class=\\\"pagination-container\\\"> <el-pagination class=\\\"pagiantion\\\" @current-change=\\\"handleCurrentChange\\\" :current-page=\\\"pagination.currentPage\\\" :page-size=\\\"pagination.pageSize\\\" layout=\\\"total, prev, pager, next, jumper\\\" :total=\\\"pagination.total\\\"> </el-pagination> </div> <!-- 新增标签弹层 --> <div class=\\\"add-form\\\"> <el-dialog title=\\\"新增图书\\\" :visible.sync=\\\"dialogFormVisible\\\"> <el-form ref=\\\"dataAddForm\\\" :model=\\\"formData\\\" :rules=\\\"rules\\\" label-position=\\\"right\\\" label-width=\\\"100px\\\"> <el-row> <el-col :span=\\\"12\\\"> <el-form-item label=\\\"图书类别\\\" prop=\\\"type\\\"> <el-input v-model=\\\"formData.type\\\"/> </el-form-item> </el-col> <el-col :span=\\\"12\\\"> <el-form-item label=\\\"图书名称\\\" prop=\\\"name\\\"> <el-input v-model=\\\"formData.name\\\"/> </el-form-item> </el-col> </el-row> <el-row> <el-col :span=\\\"24\\\"> <el-form-item label=\\\"描述\\\"> <el-input v-model=\\\"formData.description\\\" type=\\\"textarea\\\"></el-input> </el-form-item> </el-col> </el-row> </el-form> <div slot=\\\"footer\\\" class=\\\"dialog-footer\\\"> <el-button @click=\\\"dialogFormVisible = false\\\">取消</el-button> <el-button type=\\\"primary\\\" @click=\\\"saveBook()\\\">确定</el-button> </div> </el-dialog> </div> </div> </div> </div> </body> <!-- 引入组件库 --> <script src=\\\"../js/vue.js\\\"></script> <script src=\\\"../plugins/elementui/index.js\\\"></script> <script type=\\\"text/javascript\\\" src=\\\"../js/jquery.min.js\\\"></script> <script src=\\\"../js/axios-0.18.0.js\\\"></script> <script> var vue = new Vue({ el: '#app', data:{ dataList: [],//当前页要展示的分页列表数据 formData: {},//表单数据 dialogFormVisible: false,//增加表单是否可见 dialogFormVisible4Edit:false,//编辑表单是否可见 pagination: {},//分页模型数据，暂时弃用 }, //钩子函数，VUE对象初始化完成后自动执行 created() { this.getAll(); }, methods: { // 重置表单 resetForm() { //清空输入框 this.formData = {}; }, // 弹出添加窗口 openSave() { this.dialogFormVisible = true; this.resetForm(); }, //添加 saveBook () { axios.post(\\\"/books\\\",this.formData).then((res)=>{ }); }, //主页列表查询 getAll() { axios.get(\\\"/books\\\").then((res)=>{ this.dataList = res.data; }); }, } }) </script> </html> \"]}]},\"/BackEnd/SpringMVC/springmvc02.html\":{\"title\":\"SpringMVC SSM整合\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"完成SSM的整合开发\",\"能够理解并实现统一结果封装与统一异常处理\",\"能够完成前后台功能整合开发\",\"掌握拦截器的编写\"]},{\"header\":\"1 SSM整合\",\"slug\":\"_1-ssm整合\",\"contents\":[\"Mybatis、Spring 和 SpringMVC 三个框架\"]},{\"header\":\"1.1 流程分析\",\"slug\":\"_1-1-流程分析\",\"contents\":[\"(1) 创建工程\",\"创建一个Maven的web工程\",\"pom.xml添加SSM需要的依赖jar包\",\"编写Web项目的入口配置类，实现AbstractAnnotationConfigDispatcherServletInitializer重写以下方法 \",\"getRootConfigClasses() ：返回Spring的配置类->需要SpringConfig配置类\",\"getServletConfigClasses() ：返回SpringMVC的配置类->需要SpringMvcConfig配置类\",\"getServletMappings() : 设置SpringMVC请求拦截路径规则\",\"getServletFilters() ：设置过滤器，解决POST请求中文乱码问题\",\"(2) SSM整合（重点是各个配置的编写）\",\"SpringConfig \",\"标识该类为配置类 @Configuration\",\"扫描Service所在的包 @ComponentScan\",\"在Service层要管理事务 @EnableTransactionManagement\",\"读取外部的properties配置文件 @PropertySource\",\"整合Mybatis需要引入Mybatis相关配置类 @Import \",\"第三方数据源配置类 JdbcConfig \",\"构建DataSource数据源，DruidDataSouroce，需要注入数据库连接四要素， @Bean @Value\",\"构建平台事务管理器，DataSourceTransactionManager，@Bean\",\"Mybatis配置类 MybatisConfig \",\"构建SqlSessionFactoryBean并设置别名扫描与数据源，@Bean\",\"构建MapperScannerConfigurer并设置DAO层的包扫描\",\"SpringMvcConfig \",\"标识该类为配置类 @Configuration\",\"扫描Controller所在的包 @ComponentScan\",\"开启SpringMVC注解支持 @EnableWebMvc\",\"(3) 功能模块与具体的业务模块有关\",\"创建数据库表\",\"根据数据库表创建对应的模型类\",\"通过Dao层完成数据库表的增删改查（接口+自动代理）\",\"编写Service层 Service接口+实现类 \",\"@Service\",\"@Transactional\",\"整合Junit对业务层进行单元测试 \",\"@RunWith\",\"@ContextConfiguration\",\"@Test\",\"编写Controller层 \",\"接收请求 @RequestMapping @GetMapping @PostMapping @PutMapping @DeleteMapping\",\"接收数据 简单、POJO、嵌套POJO、集合、数组、JSON数据类型 \",\"@RequestParam\",\"@PathVariable\",\"@RequestBody\",\"转发业务层 \",\"@Autowired\",\"响应结果 \",\"@ResponseBody\"]},{\"header\":\"1.2 整合配置\",\"slug\":\"_1-2-整合配置\",\"contents\":[]},{\"header\":\"步骤1：创建Maven的web项目\",\"slug\":\"步骤1-创建maven的web项目\",\"contents\":[]},{\"header\":\"步骤2:添加依赖\",\"slug\":\"步骤2-添加依赖\",\"contents\":[\"pom.xml添加SSM所需要的依赖jar包\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_08_ssm</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <dependencies> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-jdbc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-test</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis</artifactId> <version>3.5.6</version> </dependency> <dependency> <groupId>org.mybatis</groupId> <artifactId>mybatis-spring</artifactId> <version>1.3.0</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.47</version> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid</artifactId> <version>1.1.16</version> </dependency> <dependency> <groupId>junit</groupId> <artifactId>junit</artifactId> <version>4.12</version> <scope>test</scope> </dependency> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.9.0</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> </plugins> </build> </project> \"]},{\"header\":\"步骤3:创建项目包结构\",\"slug\":\"步骤3-创建项目包结构\",\"contents\":[\"config 目录存放的是相关的配置类\",\"controller 编写的是Controller类\",\"dao 存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包\",\"service 存的是Service接口，impl存放的是Service实现类\",\"resources 存入的是配置文件，如Jdbc.properties\",\"webapp 目录可以存放静态资源\",\"test/java 存放的是测试类\"]},{\"header\":\"步骤4:创建SpringConfig配置类\",\"slug\":\"步骤4-创建springconfig配置类\",\"contents\":[\"@Configuration @ComponentScan({\\\"com.itheima.service\\\"}) @PropertySource(\\\"classpath:jdbc.properties\\\") @Import({JdbcConfig.class,MyBatisConfig.class}) @EnableTransactionManagement public class SpringConfig { } \"]},{\"header\":\"步骤5:创建JdbcConfig配置类\",\"slug\":\"步骤5-创建jdbcconfig配置类\",\"contents\":[\"public class JdbcConfig { @Value(\\\"${jdbc.driver}\\\") private String driver; @Value(\\\"${jdbc.url}\\\") private String url; @Value(\\\"${jdbc.username}\\\") private String username; @Value(\\\"${jdbc.password}\\\") private String password; @Bean public DataSource dataSource(){ DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driver); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; } @Bean public PlatformTransactionManager transactionManager(DataSource dataSource){ DataSourceTransactionManager ds = new DataSourceTransactionManager(); ds.setDataSource(dataSource); return ds; } } \"]},{\"header\":\"步骤6:创建MybatisConfig配置类\",\"slug\":\"步骤6-创建mybatisconfig配置类\",\"contents\":[\"public class MyBatisConfig { @Bean public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource){ SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); factoryBean.setTypeAliasesPackage(\\\"com.itheima.domain\\\"); return factoryBean; } @Bean public MapperScannerConfigurer mapperScannerConfigurer(){ MapperScannerConfigurer msc = new MapperScannerConfigurer(); msc.setBasePackage(\\\"com.itheima.dao\\\"); return msc; } } \"]},{\"header\":\"步骤7:创建jdbc.properties\",\"slug\":\"步骤7-创建jdbc-properties\",\"contents\":[\"在resources下提供jdbc.properties,设置数据库连接四要素\",\"jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssm_db jdbc.username=root jdbc.password=root \"]},{\"header\":\"步骤8:创建SpringMVC配置类\",\"slug\":\"步骤8-创建springmvc配置类\",\"contents\":[\"@Configuration @ComponentScan(\\\"com.itheima.controller\\\") @EnableWebMvc public class SpringMvcConfig { } \"]},{\"header\":\"步骤9:创建Web项目入口配置类\",\"slug\":\"步骤9-创建web项目入口配置类\",\"contents\":[\"public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer { //加载Spring配置类 protected Class<?>[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } //加载SpringMVC配置类 protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } //设置SpringMVC请求地址拦截规则 protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } //设置post请求中文乱码过滤器 @Override protected Filter[] getServletFilters() { CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\\\"utf-8\\\"); return new Filter[]{filter}; } } \",\"至此SSM整合的环境就已经搭建好了\"]},{\"header\":\"1.3 功能模块开发\",\"slug\":\"_1-3-功能模块开发\",\"contents\":[\"需求:对表tbl_book进行新增、修改、删除、根据ID查询和查询所有\"]},{\"header\":\"步骤1:创建数据库及表\",\"slug\":\"步骤1-创建数据库及表\",\"contents\":[\"create database ssm_db character set utf8; use ssm_db; create table tbl_book( id int primary key auto_increment, type varchar(20), name varchar(50), description varchar(255) ) insert into `tbl_book`(`id`,`type`,`name`,`description`) values (1,'计算机理论','Spring实战 第五版','Spring入门经典教程，深入理解Spring原理技术内幕'),(2,'计算机理论','Spring 5核心原理与30个类手写实践','十年沉淀之作，手写Spring精华思想'),(3,'计算机理论','Spring 5设计模式','深入Spring源码刨析Spring源码中蕴含的10大设计模式'),(4,'计算机理论','Spring MVC+Mybatis开发从入门到项目实战','全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手'),(5,'计算机理论','轻量级Java Web企业应用实战','源码级刨析Spring框架，适合已掌握Java基础的读者'),(6,'计算机理论','Java核心技术 卷Ⅰ 基础知识(原书第11版)','Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新'),(7,'计算机理论','深入理解Java虚拟机','5个纬度全面刨析JVM,大厂面试知识点全覆盖'),(8,'计算机理论','Java编程思想(第4版)','Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉'),(9,'计算机理论','零基础学Java(全彩版)','零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术'),(10,'市场营销','直播就这么做:主播高效沟通实战指南','李子柒、李佳奇、薇娅成长为网红的秘密都在书中'),(11,'市场营销','直播销讲实战一本通','和秋叶一起学系列网络营销书籍'),(12,'市场营销','直播带货:淘宝、天猫直播从新手到高手','一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+'); \"]},{\"header\":\"步骤2:编写模型类\",\"slug\":\"步骤2-编写模型类\",\"contents\":[\"public class Book { private Integer id; private String type; private String name; private String description; //getter...setter...toString省略 } \"]},{\"header\":\"步骤3:编写Dao接口\",\"slug\":\"步骤3-编写dao接口\",\"contents\":[\"public interface BookDao { // @Insert(\\\"insert into tbl_book values(null,#{type},#{name},#{description})\\\") @Insert(\\\"insert into tbl_book (type,name,description) values(#{type},#{name},#{description})\\\") public void save(Book book); @Update(\\\"update tbl_book set type = #{type}, name = #{name}, description = #{description} where id = #{id}\\\") public void update(Book book); @Delete(\\\"delete from tbl_book where id = #{id}\\\") public void delete(Integer id); @Select(\\\"select * from tbl_book where id = #{id}\\\") public Book getById(Integer id); @Select(\\\"select * from tbl_book\\\") public List<Book> getAll(); } \"]},{\"header\":\"步骤4:编写Service接口和实现类\",\"slug\":\"步骤4-编写service接口和实现类\",\"contents\":[\"@Transactional public interface BookService { /** * 保存 * @param book * @return */ public boolean save(Book book); /** * 修改 * @param book * @return */ public boolean update(Book book); /** * 按id删除 * @param id * @return */ public boolean delete(Integer id); /** * 按id查询 * @param id * @return */ public Book getById(Integer id); /** * 查询全部 * @return */ public List<Book> getAll(); } \",\"@Service public class BookServiceImpl implements BookService { @Autowired private BookDao bookDao; public boolean save(Book book) { bookDao.save(book); return true; } public boolean update(Book book) { bookDao.update(book); return true; } public boolean delete(Integer id) { bookDao.delete(id); return true; } public Book getById(Integer id) { return bookDao.getById(id); } public List<Book> getAll() { return bookDao.getAll(); } } \",\"说明:\",\"bookDao在Service中注入的会提示一个红线提示，为什么呢?\",\"BookDao是一个接口，没有实现类，接口是不能创建对象的，所以最终注入的应该是代理对象\",\"代理对象是由Spring的IOC容器来创建管理的\",\"IOC容器又是在Web服务器启动的时候 才会创建\",\"IDEA在检测依赖关系的时候，没有找到适合的类注入，所以会提示错误提示\",\"但是程序运行的时候，代理对象就会被创建，框架会使用DI进行注入，所以程序运行无影响。\",\"如何解决上述问题?\",\"可以不用理会，因为运行是正常的\",\"设置错误提示级别\"]},{\"header\":\"步骤5:编写Contorller类\",\"slug\":\"步骤5-编写contorller类\",\"contents\":[\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @Autowired private BookService bookService; @PostMapping public boolean save(@RequestBody Book book) { return bookService.save(book); } @PutMapping public boolean update(@RequestBody Book book) { return bookService.update(book); } @DeleteMapping(\\\"/{id}\\\") public boolean delete(@PathVariable Integer id) { return bookService.delete(id); } @GetMapping(\\\"/{id}\\\") public Book getById(@PathVariable Integer id) { return bookService.getById(id); } @GetMapping public List<Book> getAll() { return bookService.getAll(); } } \",\"对象图书模块的增删改查模块就已经完成了编写，我们可以从后往前写也可以从前往后写，最终只需要能把功能实现即可 如果有人问这个问题，正确的回答应该是先写Service然后再写Dao，写完要经过单元测试后再写Controller\",\"接下来就先把业务层的代码使用Spring整合Junit的知识点进行单元测试\"]},{\"header\":\"1.4 单元测试\",\"slug\":\"_1-4-单元测试\",\"contents\":[]},{\"header\":\"步骤1:新建测试类\",\"slug\":\"步骤1-新建测试类\",\"contents\":[\"@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class BookServiceTest { } \"]},{\"header\":\"步骤2:注入Service类\",\"slug\":\"步骤2-注入service类\",\"contents\":[\"@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class BookServiceTest { @Autowired private BookService bookService; } \"]},{\"header\":\"步骤3:编写测试方法\",\"slug\":\"步骤3-编写测试方法\",\"contents\":[\"我们先来对查询进行单元测试。\",\"@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = SpringConfig.class) public class BookServiceTest { @Autowired private BookService bookService; @Test public void testGetById(){ Book book = bookService.getById(1); System.out.println(book); } @Test public void testGetAll(){ List<Book> all = bookService.getAll(); System.out.println(all); } } \",\"根据ID查询，测试的结果为:\",\"查询所有，测试的结果为:\"]},{\"header\":\"1.5 PostMan测试\",\"slug\":\"_1-5-postman测试\",\"contents\":[]},{\"header\":\"新增\",\"slug\":\"新增\",\"contents\":[\"http://localhost/books\",\"{ \\\"type\\\":\\\"类别测试数据\\\", \\\"name\\\":\\\"书名测试数据\\\", \\\"description\\\":\\\"描述测试数据\\\" } \"]},{\"header\":\"修改\",\"slug\":\"修改\",\"contents\":[\"http://localhost/books\",\"{ \\\"id\\\":13, \\\"type\\\":\\\"类别测试数据\\\", \\\"name\\\":\\\"书名测试数据\\\", \\\"description\\\":\\\"描述测试数据\\\" } \"]},{\"header\":\"删除\",\"slug\":\"删除\",\"contents\":[\"http://localhost/books/14\"]},{\"header\":\"查询单个\",\"slug\":\"查询单个\",\"contents\":[\"http://localhost/books/1\"]},{\"header\":\"查询所有\",\"slug\":\"查询所有\",\"contents\":[\"http://localhost/books\"]},{\"header\":\"2 统一结果封装\",\"slug\":\"_2-统一结果封装\",\"contents\":[]},{\"header\":\"2.1 表现层与前端数据传输协议定义\",\"slug\":\"_2-1-表现层与前端数据传输协议定义\",\"contents\":[\"SSM整合以及功能模块开发完成后，接下来，在上述案例的基础上分析下有哪些问题需要解决 首先第一个问题是\",\"在Controller层增删改返回给前端的是boolean类型数据\",\"在Controller层查询单个返回给前端的是对象\",\"在Controller层查询所有返回给前端的是集合对象对象\",\"能不能将返回结果的数据进行统一：\",\"为了封装返回的结果数据: 创建结果模型类，封装数据到data属性中\",\"为了封装返回的数据是何种操作及是否操作成功: 封装操作结果到code属性中\",\"操作失败后为了封装返回的错误信息: 封装特殊消息到message(msg)属性中\",\"根据分析，可以设置统一数据返回结果类\",\"public class Result{ private Object data; private Integer code; private String msg; } \"]},{\"header\":\"2.2 表现层与前端数据传输协议实现\",\"slug\":\"_2-2-表现层与前端数据传输协议实现\",\"contents\":[]},{\"header\":\"2.2.1 环境准备\",\"slug\":\"_2-2-1-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加SSM整合所需jar包\",\"创建对应的配置类\",\"编写Controller、Service接口、Service实现类、Dao接口和模型类\",\"resources下提供jdbc.properties配置文件\",\"最终创建好的项目结构如下:\"]},{\"header\":\"2.2.2 结果封装\",\"slug\":\"_2-2-2-结果封装\",\"contents\":[\"对于结果封装，应该是在表现层进行处理，把结果类放在controller包下，当然你也可以放在domain包，这个都是可以的，具体如何实现结果封装，具体的步骤为:\"]},{\"header\":\"步骤1:创建Result类\",\"slug\":\"步骤1-创建result类\",\"contents\":[\"public class Result { //描述统一格式中的数据 private Object data; //描述统一格式中的编码，用于区分操作，可以简化配置0或1表示成功失败 private Integer code; //描述统一格式中的消息，可选属性 private String msg; public Result() { } //构造方法是方便对象的创建 public Result(Integer code,Object data) { this.data = data; this.code = code; } //构造方法是方便对象的创建 public Result(Integer code, Object data, String msg) { this.data = data; this.code = code; this.msg = msg; } //setter...getter...省略 } \"]},{\"header\":\"步骤2:定义返回码Code类\",\"slug\":\"步骤2-定义返回码code类\",\"contents\":[\"//状态码 public class Code { public static final Integer SAVE_OK = 20011; public static final Integer DELETE_OK = 20021; public static final Integer UPDATE_OK = 20031; public static final Integer GET_OK = 20041; public static final Integer SAVE_ERR = 20010; public static final Integer DELETE_ERR = 20020; public static final Integer UPDATE_ERR = 20030; public static final Integer GET_ERR = 20040; } \",\"注意: code类中的常量设计也不是固定的，可以根据需要自行增减，例如将查询再进行细分为 GET_OK, GET_ALL_OK, GET_PAGE_OK 等\"]},{\"header\":\"步骤3:修改Controller类的返回值\",\"slug\":\"步骤3-修改controller类的返回值\",\"contents\":[\"//统一每一个控制器方法返回值 @RestController @RequestMapping(\\\"/books\\\") public class BookController { @Autowired private BookService bookService; @PostMapping public Result save(@RequestBody Book book) { boolean flag = bookService.save(book); return new Result(flag ? Code.SAVE_OK:Code.SAVE_ERR,flag); } @PutMapping public Result update(@RequestBody Book book) { boolean flag = bookService.update(book); return new Result(flag ? Code.UPDATE_OK:Code.UPDATE_ERR,flag); } @DeleteMapping(\\\"/{id}\\\") public Result delete(@PathVariable Integer id) { boolean flag = bookService.delete(id); return new Result(flag ? Code.DELETE_OK:Code.DELETE_ERR,flag); } @GetMapping(\\\"/{id}\\\") public Result getById(@PathVariable Integer id) { Book book = bookService.getById(id); Integer code = book != null ? Code.GET_OK : Code.GET_ERR; String msg = book != null ? \\\"\\\" : \\\"数据查询失败，请重试！\\\"; return new Result(code,book,msg); } @GetMapping public Result getAll() { List<Book> bookList = bookService.getAll(); Integer code = bookList != null ? Code.GET_OK : Code.GET_ERR; String msg = bookList != null ? \\\"\\\" : \\\"数据查询失败，请重试！\\\"; return new Result(code,bookList,msg); } } \"]},{\"header\":\"步骤4:启动服务测试\",\"slug\":\"步骤4-启动服务测试\",\"contents\":[]},{\"header\":\"3 统一异常处理\",\"slug\":\"_3-统一异常处理\",\"contents\":[]},{\"header\":\"3.1 问题描述\",\"slug\":\"_3-1-问题描述\",\"contents\":[\"修改BookController类的getById方法\",\"@GetMapping(\\\"/{id}\\\") public Result getById(@PathVariable Integer id) { //手动添加一个错误信息 if(id==1){ int i = 1/0; } Book book = bookService.getById(id); Integer code = book != null ? Code.GET_OK : Code.GET_ERR; String msg = book != null ? \\\"\\\" : \\\"数据查询失败，请重试！\\\"; return new Result(code,book,msg); } \",\"重新启动运行项目，使用PostMan发送请求，当传入的id为1，则会出现如下效果：\",\"前端接收到这个信息后和之前约定的格式不一致，这个问题该如何解决?\",\"异常的种类及出现异常的原因:\",\"框架内部抛出的异常：因使用不合规导致\",\"数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）\",\"业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）\",\"表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）\",\"工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）\",\"思考\",\"各个层级均出现异常，异常处理代码书写在哪一层?\",\"所有的异常均抛出到表现层进行处理\",\"异常的种类很多，表现层如何将所有的异常都处理到呢?\",\"异常分类\",\"表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决?\",\"AOP\",\"对于上面这些问题及解决方案，SpringMVC已经提供了一套解决方案:\",\"异常处理器\",\"集中的、统一的处理项目中出现的异常\"]},{\"header\":\"3.2 异常处理器的使用\",\"slug\":\"_3-2-异常处理器的使用\",\"contents\":[]},{\"header\":\"3.2.1 环境准备\",\"slug\":\"_3-2-1-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加SSM整合所需jar包\",\"创建对应的配置类\",\"编写Controller、Service接口、Service实现类、Dao接口和模型类\",\"resources下提供jdbc.properties配置文件\",\"最终创建好的项目结构如下:\"]},{\"header\":\"3.2.2 使用步骤\",\"slug\":\"_3-2-2-使用步骤\",\"contents\":[]},{\"header\":\"步骤1:创建异常处理器类\",\"slug\":\"步骤1-创建异常处理器类\",\"contents\":[\"//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器 @RestControllerAdvice public class ProjectExceptionAdvice { //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常 @ExceptionHandler(Exception.class) public void doException(Exception ex){ System.out.println(\\\"嘿嘿,异常你哪里跑！\\\") } } \",\"确保SpringMvcConfig能够扫描到异常处理器类\"]},{\"header\":\"步骤2:让程序抛出异常\",\"slug\":\"步骤2-让程序抛出异常\",\"contents\":[\"修改BookController的getById方法，添加int i = 1/0.\",\"@GetMapping(\\\"/{id}\\\") public Result getById(@PathVariable Integer id) { int i = 1/0; Book book = bookService.getById(id); Integer code = book != null ? Code.GET_OK : Code.GET_ERR; String msg = book != null ? \\\"\\\" : \\\"数据查询失败，请重试！\\\"; return new Result(code,book,msg); } \"]},{\"header\":\"步骤3:运行程序，测试\",\"slug\":\"步骤3-运行程序-测试\",\"contents\":[\"说明异常已经被拦截并执行了doException方法。\"]},{\"header\":\"异常处理器类返回结果给前端\",\"slug\":\"异常处理器类返回结果给前端\",\"contents\":[\"//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器 @RestControllerAdvice public class ProjectExceptionAdvice { //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常 @ExceptionHandler(Exception.class) public Result doException(Exception ex){ System.out.println(\\\"嘿嘿,异常你哪里跑！\\\") return new Result(666,null,\\\"嘿嘿,异常你哪里跑！\\\"); } } \",\"启动运行程序，测试\"]},{\"header\":\"知识点1：@RestControllerAdvice\",\"slug\":\"知识点1-restcontrolleradvice\",\"contents\":[\"名称\",\"@RestControllerAdvice\",\"类型\",\"类注解\",\"位置\",\"Rest风格开发的控制器增强类定义上方\",\"作用\",\"为Rest风格开发的控制器类做增强\",\"说明: 此注解自带@ResponseBody注解与@Component注解，具备对应的功能\"]},{\"header\":\"知识点2：@ExceptionHandler\",\"slug\":\"知识点2-exceptionhandler\",\"contents\":[\"名称\",\"@ExceptionHandler\",\"类型\",\"方法注解\",\"位置\",\"专用于异常处理的控制器方法上方\",\"作用\",\"设置指定异常的处理方案，功能等同于控制器方法 出现异常后终止原始控制器执行，并转入当前方法执行\",\"说明： 此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常\"]},{\"header\":\"3.3 项目异常处理方案\",\"slug\":\"_3-3-项目异常处理方案\",\"contents\":[]},{\"header\":\"3.3.1 异常分类\",\"slug\":\"_3-3-1-异常分类\",\"contents\":[\"因为异常的种类有很多，如果每一个异常都对应一个@ExceptionHandler，那得写多少个方法来处理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类:\",\"业务异常（BusinessException）\",\"规范的用户行为产生的异常\",\"如用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串\",\"不规范的用户行为操作产生的异常\",\"如用户故意传递错误数据\",\"系统异常（SystemException）\",\"项目运行过程中可预计且无法避免的异常 \",\"比如数据库或服务器宕机\",\"其他异常（Exception）\",\"编程人员未预期到的异常，如:用到的文件不存在\",\"将异常分类以后，针对不同类型的异常，要提供具体的解决方案:\"]},{\"header\":\"3.3.2 异常解决方案\",\"slug\":\"_3-3-2-异常解决方案\",\"contents\":[\"业务异常（BusinessException） \",\"发送对应消息传递给用户，提醒规范操作 \",\"大家常见的就是提示用户名已存在或密码格式不正确等\",\"系统异常（SystemException） \",\"发送固定消息传递给用户，安抚用户 \",\"系统繁忙，请稍后再试\",\"系统正在维护升级，请稍后再试\",\"系统出问题，请联系系统管理员等\",\"发送特定消息给运维人员，提醒维护 \",\"可以发送短信、邮箱或者是公司内部通信软件\",\"记录日志 \",\"发消息和记录日志对用户来说是不可见的，属于后台程序\",\"其他异常（Exception） \",\"发送固定消息传递给用户，安抚用户\",\"发送特定消息给编程人员，提醒维护（纳入预期范围内） \",\"一般是程序没有考虑全，比如未做非空校验等\",\"记录日志\"]},{\"header\":\"3.3.3 异常解决方案的具体实现\",\"slug\":\"_3-3-3-异常解决方案的具体实现\",\"contents\":[\"思路：\",\"先通过自定义异常，完成BusinessException和SystemException的定义\",\"将其他异常包装成自定义异常类型\",\"在异常处理器类中对不同的异常进行处理\"]},{\"header\":\"步骤1:自定义异常类\",\"slug\":\"步骤1-自定义异常类\",\"contents\":[\"//自定义异常处理器，用于封装异常信息，对异常进行分类 public class SystemException extends RuntimeException{ private Integer code; public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public SystemException(Integer code, String message) { super(message); this.code = code; } public SystemException(Integer code, String message, Throwable cause) { super(message, cause); this.code = code; } } //自定义异常处理器，用于封装异常信息，对异常进行分类 public class BusinessException extends RuntimeException{ private Integer code; public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public BusinessException(Integer code, String message) { super(message); this.code = code; } public BusinessException(Integer code, String message, Throwable cause) { super(message, cause); this.code = code; } } \",\"说明:\",\"让自定义异常类继承RuntimeException的好处是，后期在抛出这两个异常的时候，就不用在 try...catch... 和 throws 了\",\"自定义异常类中添加code属性的原因是为了更好的区分异常是来自哪个业务的\"]},{\"header\":\"步骤2:将其他异常包成自定义异常\",\"slug\":\"步骤2-将其他异常包成自定义异常\",\"contents\":[\"假如在BookServiceImpl的getById方法抛异常了，该如何来包装呢?\",\"public Book getById(Integer id) { //模拟业务异常，包装成自定义异常 if(id == 1){ throw new BusinessException(Code.BUSINESS_ERR,\\\"请不要使用你的技术挑战我的耐性!\\\"); } //模拟系统异常，将可能出现的异常进行包装，转换成自定义异常 try{ int i = 1/0; }catch (Exception e){ throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,\\\"服务器访问超时，请重试!\\\",e); } return bookDao.getById(id); } \",\"具体的包装方式有：\",\"try{}catch(){}在catch中重新throw我们自定义异常即可。\",\"直接throw自定义异常即可\",\"上面为了使code看着更专业写，在Code类中再新增需要的属性\",\"//状态码 public class Code { public static final Integer SAVE_OK = 20011; public static final Integer DELETE_OK = 20021; public static final Integer UPDATE_OK = 20031; public static final Integer GET_OK = 20041; public static final Integer SAVE_ERR = 20010; public static final Integer DELETE_ERR = 20020; public static final Integer UPDATE_ERR = 20030; public static final Integer GET_ERR = 20040; public static final Integer SYSTEM_ERR = 50001; public static final Integer SYSTEM_TIMEOUT_ERR = 50002; public static final Integer SYSTEM_UNKNOW_ERR = 59999; public static final Integer BUSINESS_ERR = 60002; } \"]},{\"header\":\"步骤3:处理器类中处理自定义异常\",\"slug\":\"步骤3-处理器类中处理自定义异常\",\"contents\":[\"//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器 @RestControllerAdvice public class ProjectExceptionAdvice { //@ExceptionHandler用于设置当前处理器类对应的异常类型 @ExceptionHandler(SystemException.class) public Result doSystemException(SystemException ex){ //记录日志 //发送消息给运维 //发送邮件给开发人员,ex对象发送给开发人员 return new Result(ex.getCode(),null,ex.getMessage()); } @ExceptionHandler(BusinessException.class) public Result doBusinessException(BusinessException ex){ return new Result(ex.getCode(),null,ex.getMessage()); } //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常 @ExceptionHandler(Exception.class) public Result doOtherException(Exception ex){ //记录日志 //发送消息给运维 //发送邮件给开发人员,ex对象发送给开发人员 return new Result(Code.SYSTEM_UNKNOW_ERR,null,\\\"系统繁忙，请稍后再试！\\\"); } } \"]},{\"header\":\"步骤4:运行程序\",\"slug\":\"步骤4-运行程序\",\"contents\":[\"根据ID查询，\",\"如果传入的参数为1，会报BusinessException\",\"如果传入的是其他参数，会报SystemException\",\"对于异常我们就已经处理完成了，不管后台哪一层抛出异常，都会以我们与前端约定好的方式进行返回，前端只需要把信息获取到，根据返回的正确与否来展示不同的内容即可\",\"小结：\",\"以后项目中的异常处理方式为:\"]},{\"header\":\"4 前后台协议联调\",\"slug\":\"_4-前后台协议联调\",\"contents\":[]},{\"header\":\"4.1 环境准备\",\"slug\":\"_4-1-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加SSM整合所需jar包\",\"创建对应的配置类\",\"编写Controller、Service接口、Service实现类、Dao接口和模型类\",\"resources下提供jdbc.properties配置文件\",\"最终创建好的项目结构如下:\",\"将资料\\\\SSM功能页面下面的静态资源拷贝到webapp下。\",\"因为添加了静态资源，SpringMVC会拦截，所有需要在SpringConfig的配置类中将静态资源进行放行\",\"新建SpringMvcSupport\",\"@Configuration public class SpringMvcSupport extends WebMvcConfigurationSupport { @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\\\"/pages/**\\\").addResourceLocations(\\\"/pages/\\\"); registry.addResourceHandler(\\\"/css/**\\\").addResourceLocations(\\\"/css/\\\"); registry.addResourceHandler(\\\"/js/**\\\").addResourceLocations(\\\"/js/\\\"); registry.addResourceHandler(\\\"/plugins/**\\\").addResourceLocations(\\\"/plugins/\\\"); } } \",\"在SpringMvcConfig中扫描SpringMvcSupport\",\"@Configuration @ComponentScan({\\\"com.itheima.controller\\\",\\\"com.itheima.config\\\"}) @EnableWebMvc public class SpringMvcConfig { } \"]},{\"header\":\"4.2 列表功能\",\"slug\":\"_4-2-列表功能\",\"contents\":[\"需求:页面加载完后发送异步请求到后台获取列表数据进行展示。\",\"找到页面的钩子函数，created()\",\"created()方法中调用了this.getAll()方法\",\"在getAll()方法中使用axios发送异步请求从后台获取数据\",\"访问的路径为http://localhost/books\",\"返回的数据res.data\",\"返回数据res.data的内容如下:\",\"{ \\\"data\\\": [ { \\\"id\\\": 1, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"Spring实战 第五版\\\", \\\"description\\\": \\\"Spring入门经典教程，深入理解Spring原理技术内幕\\\" }, { \\\"id\\\": 2, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"Spring 5核心原理与30个类手写实践\\\", \\\"description\\\": \\\"十年沉淀之作，手写Spring精华思想\\\" }, { \\\"id\\\": 3, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"Spring 5设计模式\\\", \\\"description\\\": \\\"深入Spring源码刨析Spring源码中蕴含的10大设计模式\\\" }, { \\\"id\\\": 4, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"Spring MVC+Mybatis开发从入门到项目实战\\\", \\\"description\\\": \\\"全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手\\\" }, { \\\"id\\\": 5, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"轻量级Java Web企业应用实战\\\", \\\"description\\\": \\\"源码级刨析Spring框架，适合已掌握Java基础的读者\\\" }, { \\\"id\\\": 6, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"Java核心技术 卷Ⅰ 基础知识(原书第11版)\\\", \\\"description\\\": \\\"Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新\\\" }, { \\\"id\\\": 7, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"深入理解Java虚拟机\\\", \\\"description\\\": \\\"5个纬度全面刨析JVM,大厂面试知识点全覆盖\\\" }, { \\\"id\\\": 8, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"Java编程思想(第4版)\\\", \\\"description\\\": \\\"Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉\\\" }, { \\\"id\\\": 9, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"零基础学Java(全彩版)\\\", \\\"description\\\": \\\"零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术\\\" }, { \\\"id\\\": 10, \\\"type\\\": \\\"市场营销\\\", \\\"name\\\": \\\"直播就这么做:主播高效沟通实战指南\\\", \\\"description\\\": \\\"李子柒、李佳奇、薇娅成长为网红的秘密都在书中\\\" }, { \\\"id\\\": 11, \\\"type\\\": \\\"市场营销\\\", \\\"name\\\": \\\"直播销讲实战一本通\\\", \\\"description\\\": \\\"和秋叶一起学系列网络营销书籍\\\" }, { \\\"id\\\": 12, \\\"type\\\": \\\"市场营销\\\", \\\"name\\\": \\\"直播带货:淘宝、天猫直播从新手到高手\\\", \\\"description\\\": \\\"一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+\\\" } ], \\\"code\\\": 20041, \\\"msg\\\": \\\"\\\" } \",\"发送方式:\",\"getAll() { //发送ajax请求 axios.get(\\\"/books\\\").then((res)=>{ this.dataList = res.data.data; }); } \"]},{\"header\":\"4.3 添加功能\",\"slug\":\"_4-3-添加功能\",\"contents\":[\"需求: 完成图片的新增功能模块\",\"找到页面上的新建按钮，按钮上绑定了@click=\\\"handleCreate()\\\"方法\",\"在method中找到handleCreate方法，方法中打开新增面板\",\"新增面板中找到确定按钮\",\"在method中找到handleAdd方法\",\"在方法中发送请求和数据，响应成功后将新增面板关闭并重新查询数据\",\"handleCreate打开新增面板\",\"handleCreate() { this.dialogFormVisible = true; }, \",\"handleAdd方法发送异步请求并携带数据\",\"handleAdd () { //发送ajax请求 //this.formData是表单中的数据，最后是一个json数据 axios.post(\\\"/books\\\",this.formData).then((res)=>{ this.dialogFormVisible = false; this.getAll(); }); } \"]},{\"header\":\"4.4 添加功能状态处理\",\"slug\":\"_4-4-添加功能状态处理\",\"contents\":[\"基础的新增功能已经完成，但是还有一些问题需要解决下:\",\"需求：新增成功是关闭面板，重新查询数据，那么新增失败以后该如何处理?\",\"在handlerAdd方法中根据后台返回的数据来进行不同的处理\",\"如果后台返回的是成功，则提示成功信息，并关闭面板\",\"如果后台返回的是失败，则提示错误信息\",\"(1) 修改前端页面\",\"handleAdd () { //发送ajax请求 axios.post(\\\"/books\\\",this.formData).then((res)=>{ //如果操作成功，关闭弹层，显示数据 if(res.data.code == 20011){ this.dialogFormVisible = false; this.$message.success(\\\"添加成功\\\"); }else if(res.data.code == 20010){ this.$message.error(\\\"添加失败\\\"); }else{ this.$message.error(res.data.msg); } }).finally(()=>{ this.getAll(); }); } \",\"(2) 后台返回操作结果，将Dao层的增删改方法返回值从void改成int\",\"public interface BookDao { // @Insert(\\\"insert into tbl_book values(null,#{type},#{name},#{description})\\\") @Insert(\\\"insert into tbl_book (type,name,description) values(#{type},#{name},#{description})\\\") public int save(Book book); @Update(\\\"update tbl_book set type = #{type}, name = #{name}, description = #{description} where id = #{id}\\\") public int update(Book book); @Delete(\\\"delete from tbl_book where id = #{id}\\\") public int delete(Integer id); @Select(\\\"select * from tbl_book where id = #{id}\\\") public Book getById(Integer id); @Select(\\\"select * from tbl_book\\\") public List<Book> getAll(); } \",\"(3) 在BookServiceImpl中，增删改方法根据DAO的返回值来决定返回true/false\",\"@Service public class BookServiceImpl implements BookService { @Autowired private BookDao bookDao; public boolean save(Book book) { return bookDao.save(book) > 0; } public boolean update(Book book) { return bookDao.update(book) > 0; } public boolean delete(Integer id) { return bookDao.delete(id) > 0; } public Book getById(Integer id) { if(id == 1){ throw new BusinessException(Code.BUSINESS_ERR,\\\"请不要使用你的技术挑战我的耐性!\\\"); } // //将可能出现的异常进行包装，转换成自定义异常 // try{ // int i = 1/0; // }catch (Exception e){ // throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,\\\"服务器访问超时，请重试!\\\",e); // } return bookDao.getById(id); } public List<Book> getAll() { return bookDao.getAll(); } } \",\"(4) 测试错误情况，将图书类别长度设置超出范围即可\",\"处理完新增后，会发现新增还存在一个问题 新增成功后，再次点击新增按钮会发现之前的数据还存在，这个时候就需要在新增的时候将表单内容清空。\",\"resetForm(){ this.formData = {}; } handleCreate() { this.dialogFormVisible = true; this.resetForm(); } \"]},{\"header\":\"4.5 修改功能\",\"slug\":\"_4-5-修改功能\",\"contents\":[\"需求：完成图片信息的修改功能\",\"找到页面中的编辑按钮，该按钮绑定了@click=\\\"handleUpdate(scope.row)\\\"\",\"在method的handleUpdate方法中发送异步请求根据ID查询图书信息\",\"根据后台返回的结果，判断是否查询成功 如果查询成功打开修改面板回显数据，如果失败提示错误信息\",\"修改完成后找到修改面板的确定按钮，该按钮绑定了@click=\\\"handleEdit()\\\"\",\"在method的handleEdit方法中发送异步请求提交修改数据\",\"根据后台返回的结果，判断是否查询成功\",\"如果成功提示错误信息，关闭修改面板，重新查询数据，如果失败提示错误信息\",\"scope.row代表的是当前行的行数据，scope.row就是选中行对应的json数据，如下:\",\"{ \\\"id\\\": 1, \\\"type\\\": \\\"计算机理论\\\", \\\"name\\\": \\\"Spring实战 第五版\\\", \\\"description\\\": \\\"Spring入门经典教程，深入理解Spring原理技术内幕\\\" } \",\"修改handleUpdate方法\",\"//弹出编辑窗口 handleUpdate(row) { // console.log(row); //row.id 查询条件 //查询数据，根据id查询 axios.get(\\\"/books/\\\"+row.id).then((res)=>{ if(res.data.code == 20041){ //展示弹层，加载数据 this.formData = res.data.data; this.dialogFormVisible4Edit = true; }else{ this.$message.error(res.data.msg); } }); } \",\"修改handleEdit方法\",\"handleEdit() { //发送ajax请求 axios.put(\\\"/books\\\",this.formData).then((res)=>{ //如果操作成功，关闭弹层，显示数据 if(res.data.code == 20031){ this.dialogFormVisible4Edit = false; this.$message.success(\\\"修改成功\\\"); }else if(res.data.code == 20030){ this.$message.error(\\\"修改失败\\\"); }else{ this.$message.error(res.data.msg); } }).finally(()=>{ this.getAll(); }); } \"]},{\"header\":\"4.6 删除功能\",\"slug\":\"_4-6-删除功能\",\"contents\":[\"需求：完成页面的删除功能。\",\"找到页面的删除按钮，按钮上绑定了@click=\\\"handleDelete(scope.row)\\\"\",\"method的handleDelete方法弹出提示框\",\"用户点击取消,提示操作已经被取消。\",\"用户点击确定，发送异步请求并携带需要删除数据的主键ID\",\"根据后台返回结果\",\"如果返回成功，提示错误信息，并重新查询数据\",\"如果返回失败，提示错误信息，并重新查询数据\",\"修改handleDelete方法\",\"handleDelete(row) { //1.弹出提示框 this.$confirm(\\\"此操作永久删除当前数据，是否继续？\\\",\\\"提示\\\",{ type:'info' }).then(()=>{ //2.做删除业务 axios.delete(\\\"/books/\\\"+row.id).then((res)=>{ if(res.data.code == 20021){ this.$message.success(\\\"删除成功\\\"); }else{ this.$message.error(\\\"删除失败\\\"); } }).finally(()=>{ this.getAll(); }); }).catch(()=>{ //3.取消删除 this.$message.info(\\\"取消删除操作\\\"); }); } \",\"<!DOCTYPE html> <html> <head> <!-- 页面meta --> <meta charset=\\\"utf-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <title>SpringMVC案例</title> <meta content=\\\"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no\\\" name=\\\"viewport\\\"> <!-- 引入样式 --> <link rel=\\\"stylesheet\\\" href=\\\"../plugins/elementui/index.css\\\"> <link rel=\\\"stylesheet\\\" href=\\\"../plugins/font-awesome/css/font-awesome.min.css\\\"> <link rel=\\\"stylesheet\\\" href=\\\"../css/style.css\\\"> </head> <body class=\\\"hold-transition\\\"> <div id=\\\"app\\\"> <div class=\\\"content-header\\\"> <h1>图书管理</h1> </div> <div class=\\\"app-container\\\"> <div class=\\\"box\\\"> <div class=\\\"filter-container\\\"> <el-input placeholder=\\\"图书名称\\\" v-model=\\\"pagination.queryString\\\" style=\\\"width: 200px;\\\" class=\\\"filter-item\\\"></el-input> <el-button @click=\\\"getAll()\\\" class=\\\"dalfBut\\\">查询</el-button> <el-button type=\\\"primary\\\" class=\\\"butT\\\" @click=\\\"handleCreate()\\\">新建</el-button> </div> <el-table size=\\\"small\\\" current-row-key=\\\"id\\\" :data=\\\"dataList\\\" stripe highlight-current-row> <el-table-column type=\\\"index\\\" align=\\\"center\\\" label=\\\"序号\\\"></el-table-column> <el-table-column prop=\\\"type\\\" label=\\\"图书类别\\\" align=\\\"center\\\"></el-table-column> <el-table-column prop=\\\"name\\\" label=\\\"图书名称\\\" align=\\\"center\\\"></el-table-column> <el-table-column prop=\\\"description\\\" label=\\\"描述\\\" align=\\\"center\\\"></el-table-column> <el-table-column label=\\\"操作\\\" align=\\\"center\\\"> <template slot-scope=\\\"scope\\\"> <el-button type=\\\"primary\\\" size=\\\"mini\\\" @click=\\\"handleUpdate(scope.row)\\\">编辑</el-button> <el-button type=\\\"danger\\\" size=\\\"mini\\\" @click=\\\"handleDelete(scope.row)\\\">删除</el-button> </template> </el-table-column> </el-table> <!-- 新增标签弹层 --> <div class=\\\"add-form\\\"> <el-dialog title=\\\"新增图书\\\" :visible.sync=\\\"dialogFormVisible\\\"> <el-form ref=\\\"dataAddForm\\\" :model=\\\"formData\\\" :rules=\\\"rules\\\" label-position=\\\"right\\\" label-width=\\\"100px\\\"> <el-row> <el-col :span=\\\"12\\\"> <el-form-item label=\\\"图书类别\\\" prop=\\\"type\\\"> <el-input v-model=\\\"formData.type\\\"/> </el-form-item> </el-col> <el-col :span=\\\"12\\\"> <el-form-item label=\\\"图书名称\\\" prop=\\\"name\\\"> <el-input v-model=\\\"formData.name\\\"/> </el-form-item> </el-col> </el-row> <el-row> <el-col :span=\\\"24\\\"> <el-form-item label=\\\"描述\\\"> <el-input v-model=\\\"formData.description\\\" type=\\\"textarea\\\"></el-input> </el-form-item> </el-col> </el-row> </el-form> <div slot=\\\"footer\\\" class=\\\"dialog-footer\\\"> <el-button @click=\\\"dialogFormVisible = false\\\">取消</el-button> <el-button type=\\\"primary\\\" @click=\\\"handleAdd()\\\">确定</el-button> </div> </el-dialog> </div> <!-- 编辑标签弹层 --> <div class=\\\"add-form\\\"> <el-dialog title=\\\"编辑检查项\\\" :visible.sync=\\\"dialogFormVisible4Edit\\\"> <el-form ref=\\\"dataEditForm\\\" :model=\\\"formData\\\" :rules=\\\"rules\\\" label-position=\\\"right\\\" label-width=\\\"100px\\\"> <el-row> <el-col :span=\\\"12\\\"> <el-form-item label=\\\"图书类别\\\" prop=\\\"type\\\"> <el-input v-model=\\\"formData.type\\\"/> </el-form-item> </el-col> <el-col :span=\\\"12\\\"> <el-form-item label=\\\"图书名称\\\" prop=\\\"name\\\"> <el-input v-model=\\\"formData.name\\\"/> </el-form-item> </el-col> </el-row> <el-row> <el-col :span=\\\"24\\\"> <el-form-item label=\\\"描述\\\"> <el-input v-model=\\\"formData.description\\\" type=\\\"textarea\\\"></el-input> </el-form-item> </el-col> </el-row> </el-form> <div slot=\\\"footer\\\" class=\\\"dialog-footer\\\"> <el-button @click=\\\"dialogFormVisible4Edit = false\\\">取消</el-button> <el-button type=\\\"primary\\\" @click=\\\"handleEdit()\\\">确定</el-button> </div> </el-dialog> </div> </div> </div> </div> </body> <!-- 引入组件库 --> <script src=\\\"../js/vue.js\\\"></script> <script src=\\\"../plugins/elementui/index.js\\\"></script> <script type=\\\"text/javascript\\\" src=\\\"../js/jquery.min.js\\\"></script> <script src=\\\"../js/axios-0.18.0.js\\\"></script> <script> var vue = new Vue({ el: '#app', data:{ pagination: {}, dataList: [],//当前页要展示的列表数据 formData: {},//表单数据 dialogFormVisible: false,//控制表单是否可见 dialogFormVisible4Edit:false,//编辑表单是否可见 rules: {//校验规则 type: ]{ required: true, message: '图书类别为必填项', trigger: 'blur' }[, name: ]{ required: true, message: '图书名称为必填项', trigger: 'blur' }[ } }, //钩子函数，VUE对象初始化完成后自动执行 created() { this.getAll(); }, methods: { //列表 getAll() { //发送ajax请求 axios.get(\\\"/books\\\").then((res)=>{ this.dataList = res.data.data; }); }, //弹出添加窗口 handleCreate() { this.dialogFormVisible = true; this.resetForm(); }, //重置表单 resetForm() { this.formData = {}; }, //添加 handleAdd () { //发送ajax请求 axios.post(\\\"/books\\\",this.formData).then((res)=>{ console.log(res.data); //如果操作成功，关闭弹层，显示数据 if(res.data.code == 20011){ this.dialogFormVisible = false; this.$message.success(\\\"添加成功\\\"); }else if(res.data.code == 20010){ this.$message.error(\\\"添加失败\\\"); }else{ this.$message.error(res.data.msg); } }).finally(()=>{ this.getAll(); }); }, //弹出编辑窗口 handleUpdate(row) { // console.log(row); //row.id 查询条件 //查询数据，根据id查询 axios.get(\\\"/books/\\\"+row.id).then((res)=>{ // console.log(res.data.data); if(res.data.code == 20041){ //展示弹层，加载数据 this.formData = res.data.data; this.dialogFormVisible4Edit = true; }else{ this.$message.error(res.data.msg); } }); }, //编辑 handleEdit() { //发送ajax请求 axios.put(\\\"/books\\\",this.formData).then((res)=>{ //如果操作成功，关闭弹层，显示数据 if(res.data.code == 20031){ this.dialogFormVisible4Edit = false; this.$message.success(\\\"修改成功\\\"); }else if(res.data.code == 20030){ this.$message.error(\\\"修改失败\\\"); }else{ this.$message.error(res.data.msg); } }).finally(()=>{ this.getAll(); }); }, // 删除 handleDelete(row) { //1.弹出提示框 this.$confirm(\\\"此操作永久删除当前数据，是否继续？\\\",\\\"提示\\\",{ type:'info' }).then(()=>{ //2.做删除业务 axios.delete(\\\"/books/\\\"+row.id).then((res)=>{ if(res.data.code == 20021){ this.$message.success(\\\"删除成功\\\"); }else{ this.$message.error(\\\"删除失败\\\"); } }).finally(()=>{ this.getAll(); }); }).catch(()=>{ //3.取消删除 this.$message.info(\\\"取消删除操作\\\"); }); } } }) </script> </html> \"]},{\"header\":\"5 拦截器\",\"slug\":\"_5-拦截器\",\"contents\":[\"拦截器概念\",\"入门案例\",\"拦截器参数\",\"拦截器工作流程分析\"]},{\"header\":\"5.1 拦截器概念\",\"slug\":\"_5-1-拦截器概念\",\"contents\":[\"浏览器发送一个请求会先到Tomcat的web服务器\",\"Tomcat服务器接收到请求以后，会去判断请求的是静态资源还是动态资源\",\"如果是静态资源，会直接到Tomcat的项目部署目录下去直接访问\",\"如果是动态资源，就需要交给项目的后台代码进行处理\",\"在找到具体的方法之前，我们可以去配置过滤器(可以配置多个)，按照顺序进行执行\",\"然后进入到到中央处理器(SpringMVC中的内容)，SpringMVC会根据配置的规则进行拦截\",\"如果满足规则，则进行处理，找到其对应的controller类中的方法进行执行,完成后返回结果\",\"如果不满足规则，则不进行处理\",\"这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现?\",\"这个就是拦截器要做的事。所以拦截器即:\",\"拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行\",\"作用: \",\"在指定的方法调用前后执行预先设定的代码\",\"阻止原始方法的执行\",\"总结：增强\",\"这个拦截器和我们之前说的AOP思想是一致的，所以说拦截器也是对AOP思想的实现\",\"拦截器和过滤器在作用和执行顺序上也很相似\",\"思考：拦截器和过滤器之间的区别是什么?\",\"归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术\",\"拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强\"]},{\"header\":\"5.2 拦截器入门案例\",\"slug\":\"_5-2-拦截器入门案例\",\"contents\":[\"拦截器是对AOP思想的具体实现，最终的目的是为了增强，增强的内容，之前我们给的名称是通知，被增强的点叫切入点\",\"所以在拦截器的入门案例中，需要考虑:\",\"1.制作拦截器工具类(通知)\",\"2.配置拦截器的执行位置(切入点)\"]},{\"header\":\"5.2.1 环境准备\",\"slug\":\"_5-2-1-环境准备\",\"contents\":[\"创建一个Web的Maven项目\",\"pom.xml添加SSM整合所需jar包\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?> <project xmlns=\\\"http://maven.apache.org/POM/4.0.0\\\" xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xsi:schemaLocation=\\\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\\\"> <modelVersion>4.0.0</modelVersion> <groupId>com.itheima</groupId> <artifactId>springmvc_12_interceptor</artifactId> <version>1.0-SNAPSHOT</version> <packaging>war</packaging> <dependencies> <dependency> <groupId>javax.servlet</groupId> <artifactId>javax.servlet-api</artifactId> <version>3.1.0</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>5.2.10.RELEASE</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.9.0</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.apache.tomcat.maven</groupId> <artifactId>tomcat7-maven-plugin</artifactId> <version>2.1</version> <configuration> <port>80</port> <path>/</path> </configuration> </plugin> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-compiler-plugin</artifactId> <configuration> <source>8</source> <target>8</target> </configuration> </plugin> </plugins> </build> </project> \",\"创建对应的配置类\",\"public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer { protected Class<?>[] getRootConfigClasses() { return new Class[0]; } protected Class<?>[] getServletConfigClasses() { return new Class[]{SpringMvcConfig.class}; } protected String[] getServletMappings() { return new String[]{\\\"/\\\"}; } //乱码处理 @Override protected Filter[] getServletFilters() { CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(\\\"UTF-8\\\"); return new Filter[]{filter}; } } @Configuration @ComponentScan({\\\"com.itheima.controller\\\"}) @EnableWebMvc public class SpringMvcConfig{ } \",\"创建模型类Book\",\"public class Book { private String name; private double price; public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return \\\"Book{\\\" + \\\"书名='\\\" + name + '\\\\'' + \\\", 价格=\\\" + price + '}'; } } \",\"编写Controller\",\"@RestController @RequestMapping(\\\"/books\\\") public class BookController { @PostMapping public String save(@RequestBody Book book){ System.out.println(\\\"book save...\\\" + book); return \\\"{'module':'book save'}\\\"; } @DeleteMapping(\\\"/{id}\\\") public String delete(@PathVariable Integer id){ System.out.println(\\\"book delete...\\\" + id); return \\\"{'module':'book delete'}\\\"; } @PutMapping public String update(@RequestBody Book book){ System.out.println(\\\"book update...\\\"+book); return \\\"{'module':'book update'}\\\"; } @GetMapping(\\\"/{id}\\\") public String getById(@PathVariable Integer id){ System.out.println(\\\"book getById...\\\"+id); return \\\"{'module':'book getById'}\\\"; } @GetMapping public String getAll(){ System.out.println(\\\"book getAll...\\\"); return \\\"{'module':'book getAll'}\\\"; } } \",\"最终创建好的项目结构如下:\"]},{\"header\":\"5.2.2 拦截器开发\",\"slug\":\"_5-2-2-拦截器开发\",\"contents\":[]},{\"header\":\"步骤1:创建拦截器类\",\"slug\":\"步骤1-创建拦截器类\",\"contents\":[\"让类实现HandlerInterceptor接口，重写接口中的三个方法\",\"@Component //定义拦截器类，实现HandlerInterceptor接口 //注意当前类必须受Spring容器控制 public class ProjectInterceptor implements HandlerInterceptor { @Override //原始方法调用前执行的内容 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"preHandle...\\\"); return true; } @Override //原始方法调用后执行的内容 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\\\"postHandle...\\\"); } @Override //原始方法调用完成后执行的内容 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\\\"afterCompletion...\\\"); } } \",\"注意: 拦截器类要被SpringMVC容器扫描到\"]},{\"header\":\"步骤2:配置拦截器类\",\"slug\":\"步骤2-配置拦截器类\",\"contents\":[\"@Configuration public class SpringMvcSupport extends WebMvcConfigurationSupport { @Autowired private ProjectInterceptor projectInterceptor; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\\\"/pages/**\\\").addResourceLocations(\\\"/pages/\\\"); } @Override protected void addInterceptors(InterceptorRegistry registry) { //配置拦截器 registry.addInterceptor(projectInterceptor).addPathPatterns(\\\"/books\\\" ); } } \"]},{\"header\":\"步骤3:SpringMVC添加SpringMvcSupport包扫描\",\"slug\":\"步骤3-springmvc添加springmvcsupport包扫描\",\"contents\":[\"@Configuration @ComponentScan({\\\"com.itheima.controller\\\",\\\"com.itheima.config\\\"}) @EnableWebMvc public class SpringMvcConfig{ } \"]},{\"header\":\"步骤4:运行程序测试\",\"slug\":\"步骤4-运行程序测试\",\"contents\":[\"使用PostMan发送http://localhost/books\",\"如果发送http://localhost/books/100会发现拦截器没有被执行，原因是拦截器的addPathPatterns方法配置的拦截路径是/books,我们现在发送的是/books/100，所以没有匹配上，因此没有拦截，拦截器就不会执行\"]},{\"header\":\"步骤5:修改拦截器拦截规则\",\"slug\":\"步骤5-修改拦截器拦截规则\",\"contents\":[\"@Configuration public class SpringMvcSupport extends WebMvcConfigurationSupport { @Autowired private ProjectInterceptor projectInterceptor; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\\\"/pages/**\\\").addResourceLocations(\\\"/pages/\\\"); } @Override protected void addInterceptors(InterceptorRegistry registry) { //配置拦截器 registry.addInterceptor(projectInterceptor).addPathPatterns(\\\"/books\\\",\\\"/books/*\\\" ); } } \",\"拦截器中的preHandler方法，如果返回true，则代表放行，会执行原始Controller类中要请求的方法，如果返回false，则代表拦截，后面的就不会再执行了\"]},{\"header\":\"步骤6:简化SpringMvcSupport的编写\",\"slug\":\"步骤6-简化springmvcsupport的编写\",\"contents\":[\"@Configuration @ComponentScan({\\\"com.itheima.controller\\\"}) @EnableWebMvc //实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性 public class SpringMvcConfig implements WebMvcConfigurer { @Autowired private ProjectInterceptor projectInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //配置多拦截器 registry.addInterceptor(projectInterceptor).addPathPatterns(\\\"/books\\\",\\\"/books/*\\\"); } } \",\"此后不用再写SpringMvcSupport类了。\",\"拦截器的执行流程:\",\"当有拦截器后，请求会先进入preHandle方法，\",\"如果方法返回true，则放行继续执行后面的handle(controller的方法)和后面的方法\",\"如果返回false，则直接跳过后面方法的执行。\"]},{\"header\":\"5.3 拦截器参数\",\"slug\":\"_5-3-拦截器参数\",\"contents\":[]},{\"header\":\"5.3.1 前置处理方法\",\"slug\":\"_5-3-1-前置处理方法\",\"contents\":[\"原始方法之前运行preHandle\",\"public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"preHandle\\\"); return true; } \",\"request：请求对象\",\"response：响应对象\",\"handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装\",\"使用request对象可以获取请求数据中的内容，如获取请求头的Content-Type\",\"public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String contentType = request.getHeader(\\\"Content-Type\\\"); System.out.println(\\\"preHandle...\\\"+contentType); return true; } \",\"使用handler参数，可以获取方法的相关信息\",\"public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { HandlerMethod hm = (HandlerMethod)handler; String methodName = hm.getMethod().getName();//可以获取方法的名称 System.out.println(\\\"preHandle...\\\"+methodName); return true; } \"]},{\"header\":\"5.3.2 后置处理方法\",\"slug\":\"_5-3-2-后置处理方法\",\"contents\":[\"原始方法运行后运行，如果原始方法被拦截，则不执行\",\"public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\\\"postHandle\\\"); } \",\"前三个参数和上面的是一致的\",\"modelAndView: 如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整\",\"因为现在都是返回json数据，所以该参数的使用率不高\"]},{\"header\":\"5.3.3 完成处理方法\",\"slug\":\"_5-3-3-完成处理方法\",\"contents\":[\"拦截器最后执行的方法，无论原始方法是否执行\",\"public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\\\"afterCompletion\\\"); } \",\"前三个参数与上面的是一致的\",\"ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理\",\"因为我们现在已经有全局异常处理器类，所以该参数的使用率也不高\",\"这三个方法中，最常用的是preHandle，在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回true放行，不满足则返回false拦截\"]},{\"header\":\"5.4 拦截器链配置\",\"slug\":\"_5-4-拦截器链配置\",\"contents\":[\"在项目中只添加了一个拦截器，如果有多个，该如何配置?配置多个后，执行顺序是什么?\"]},{\"header\":\"5.4.1 配置多个拦截器\",\"slug\":\"_5-4-1-配置多个拦截器\",\"contents\":[]},{\"header\":\"步骤1: 创建拦截器类\",\"slug\":\"步骤1-创建拦截器类-1\",\"contents\":[\"实现接口，并重写接口中的方法\",\"@Component public class ProjectInterceptor2 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\\\"preHandle...222\\\"); return false; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\\\"postHandle...222\\\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\\\"afterCompletion...222\\\"); } } \"]},{\"header\":\"步骤2: 配置拦截器类\",\"slug\":\"步骤2-配置拦截器类-1\",\"contents\":[\"@Configuration @ComponentScan({\\\"com.itheima.controller\\\"}) @EnableWebMvc //实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性 public class SpringMvcConfig implements WebMvcConfigurer { @Autowired private ProjectInterceptor projectInterceptor; @Autowired private ProjectInterceptor2 projectInterceptor2; @Override public void addInterceptors(InterceptorRegistry registry) { //配置多拦截器 registry.addInterceptor(projectInterceptor).addPathPatterns(\\\"/books\\\",\\\"/books/*\\\"); registry.addInterceptor(projectInterceptor2).addPathPatterns(\\\"/books\\\",\\\"/books/*\\\"); } } \",\"步骤3:运行程序，观察顺序\",\"拦截器执行的顺序是和配置顺序有关，先进后出\",\"当配置多个拦截器时，形成拦截器链\",\"拦截器链的运行顺序参照拦截器添加顺序为准\",\"当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行\",\"当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作\",\"preHandle：与配置顺序相同，必定运行\",\"postHandle：与配置顺序相反，可能不运行\",\"afterCompletion：与配置顺序相反，可能不运行。\",\"这个顺序不太好记，最终只需要把握住一个原则即可：以最终的运行结果为准\"]}]},\"/ComputerBasics/ComputerNetwork/\":{\"title\":\"README\",\"contents\":[{\"header\":\"1. 计算机网络体系结构\",\"slug\":\"_1-计算机网络体系结构\",\"contents\":[]},{\"header\":\"1.1 简介\",\"slug\":\"_1-1-简介\",\"contents\":[\"定义：计算机网络的各层 + 其协议的集合\",\"作用：定义该计算机网络的所能完成的功能\"]},{\"header\":\"1.2 结构介绍\",\"slug\":\"_1-2-结构介绍\",\"contents\":[\"计算机网络体系结构分为3种：OSI体系结构、TCP / IP体系结构、五层体系结构。\",\"OSI 体系结构：概念清楚 & 理念完整，但复杂 & 不实用；\",\"TCP / IP 体系结构：含了一系列构成互联网基础的网络协议，是Internet的核心协议 & 被广泛应用于局域网和广域网； 五层体系结构：融合了OSI 与 TCP / IP的体系结构，目的是为了学习 & 讲解计算机原理。\",\"低三层为通信子网，负责数据传输\\n高三层为资源子网，相当于计算机系统\\n完成数据处理；传输层承上启下\"]}]},\"/ComputerBasics/ComputerNetwork/computernetword01.html\":{\"title\":\"计算机网络01\",\"contents\":[{\"header\":\"1 网桥模式、路由模式、NAT模式、旁路模式\",\"slug\":\"_1-网桥模式、路由模式、nat模式、旁路模式\",\"contents\":[]},{\"header\":\"1.1 网桥模式\",\"slug\":\"_1-1-网桥模式\",\"contents\":[\"网桥模式是计算机网络中的一种网络设备工作模式，它可以连接多个局域网（LAN）并转发数据帧以实现不同网段之间的通信。网桥是一个二层设备，它在物理层和数据链路层工作，可以识别数据帧的目的MAC地址，并将数据帧转发到正确的目标端口。网桥可以减少网络中的广播风暴，提高网络性能和安全性。\",\"在网桥模式中，多个局域网连接到网桥的不同端口上，网桥通过学习每个端口上连接的设备的MAC地址，建立一个MAC地址表，从而可以转发数据帧到正确的目标端口。当数据帧到达网桥时，网桥会检查数据帧的目的MAC地址，并将数据帧转发到MAC地址表中对应的端口上，如果该地址不在MAC地址表中，则将数据帧广播到所有端口上，以便学习新的MAC地址。\"]},{\"header\":\"1.2 路由模式\",\"slug\":\"_1-2-路由模式\",\"contents\":[\"路由模式是计算机网络中的一种网络设备工作模式，它可以连接不同的网络，并通过转发IP数据包来实现跨网络的通信。路由器是一个三层设备，它在网络层工作，可以识别数据包的目的IP地址，并将数据包转发到正确的目标网络。\",\"在路由模式中，多个网络连接到路由器的不同接口上，路由器通过学习每个接口连接的网络的IP地址，建立一个路由表，从而可以转发数据包到正确的目标网络。当数据包到达路由器时，路由器会检查数据包的目的IP地址，并将数据包根据路由表转发到正确的接口上，如果该地址不在路由表中，则将数据包发送到默认路由或者丢弃该数据包。\"]},{\"header\":\"1.3 NAT模式\",\"slug\":\"_1-3-nat模式\",\"contents\":[\"NAT（网络地址转换）模式是计算机网络中的一种网络设备工作模式，它可以将私有网络内部的IP地址转换为公网IP地址，从而实现私有网络与公网之间的通信。NAT是一种在网络层上进行地址转换的技术，通常被用于家庭或企业内部的局域网中，以便让内部的设备访问互联网。\",\"在NAT模式中，NAT设备连接到公网上，并分配一个公网IP地址，内部设备连接到NAT设备的私有网络上，通过NAT设备进行地址转换。当内部设备向公网发送数据时，NAT设备会将数据包的源IP地址改为NAT设备的公网IP地址，并分配一个唯一的端口号，从而实现与公网的通信。当公网向内部设备发送数据时，NAT设备会将数据包的目的IP地址和端口号转换为内部设备的IP地址和端口号，从而实现与内部设备的通信。\",\"NAT模式可以实现多个内部设备共享一个公网IP地址，从而节省公网IP地址的使用。此外，NAT模式还可以提高网络的安全性，因为NAT设备可以过滤和阻止不合法的数据包，从而保护内部网络不受来自公网的攻击。\",\"需要注意的是，NAT模式会引入一定的网络延迟和复杂性，因为数据包需要经过NAT设备的处理和转换。此外，在某些情况下，NAT模式可能会影响某些网络应用程序的正常运行，例如P2P应用程序或者视频会议应用程序，因为这些应用程序需要直接访问设备的IP地址。\"]},{\"header\":\"1.4 旁路模式\",\"slug\":\"_1-4-旁路模式\",\"contents\":[\"旁路模式是计算机网络中的一种网络设备工作模式，它是指网络设备在处理数据流时，将数据流旁路到专门的处理单元进行处理，同时保证数据流的正常转发。在旁路模式下，网络设备通常会配备专门的硬件加速器或者处理器，以处理网络流量的特定类型或者特定协议，例如防火墙、入侵检测系统、负载均衡器等。\",\"在旁路模式下，网络设备通常会有两个或者多个网口，其中一个网口用于接收数据流，另外一个网口则用于将数据流旁路到处理单元进行处理，处理单元处理完毕后将数据流发送回来，再由网络设备将数据流转发到正确的目标设备。\",\"旁路模式可以提高网络设备的性能和安全性，因为它可以将特定类型的网络流量优先处理，从而提高网络设备的处理效率和响应速度。例如，防火墙可以通过旁路模式来检测和阻止网络中的恶意流量，避免网络攻击和恶意软件的传播。\",\"需要注意的是，旁路模式需要额外的硬件和软件支持，因此通常会增加网络设备的成本和复杂性。此外，如果处理单元出现故障或者性能不足，可能会影响网络设备的正常运行，因此在设计和部署旁路模式时需要考虑相关的风险和容错措施。\"]},{\"header\":\"2 IPV4的计算\",\"slug\":\"_2-ipv4的计算\",\"contents\":[\"如：192.168.2.0/16 有多少位IP地址，写一个正常IPV4转长整形类型、长整形类型转正常IPV4的不同方法\"]},{\"header\":\"2.1 192.168.2.0/16有多少位IP地址\",\"slug\":\"_2-1-192-168-2-0-16有多少位ip地址\",\"contents\":[\"192.168.2.0/16 是一个 CIDR（无类别域间路由）表示方法的 IP 地址块 其中的 /16 表示这个地址块中有 16 位是网络地址，剩下的 32-16=16 位是主机地址 因此，这个地址块中有 216 个 IP 地址可供分配，即 216−2 个（因为其中的第一个和最后一个 IP 地址是网络地址和广播地址，不能分配给主机使用），即65534个IP地址\"]},{\"header\":\"2.2 正常IPV4转长整形类型\",\"slug\":\"_2-2-正常ipv4转长整形类型\",\"contents\":[\"public static long ipToLong(String ipAddress) { String[] ipAddressInArray = ipAddress.split(\\\"\\\\\\\\.\\\"); long result = 0; for (int i = 0; i < ipAddressInArray.length; i++) { int power = 3 - i; int ip = Integer.parseInt(ipAddressInArray[i]); result += ip * Math.pow(256, power); } return result; } \",\"该方法接受一个字符串类型的IPv4地址，将其拆分成四个整数，然后将这四个整数转换为长整型类型。具体地，将IP地址的每个部分乘以256的不同次幂，然后将它们相加，得到一个长整型类型的IP地址。\",\"例如，将字符串 \\\"192.168.0.1\\\" 转换为长整型类型的IP地址：\",\"String ipAddress = \\\"192.168.0.1\\\"; long ipLong = ipToLong(ipAddress); System.out.println(ipLong); // 输出 3232235521 \",\"其中，输出的结果 3232235521 就是该IP地址对应的长整型类型表示。\"]},{\"header\":\"2.3 长整形类型转正常IPV4\",\"slug\":\"_2-3-长整形类型转正常ipv4\",\"contents\":[\"public static String longToIp(long ip) { StringBuilder sb = new StringBuilder(15); for (int i = 0; i < 4; i++) { sb.insert(0, Long.toString(ip & 0xff)); if (i < 3) { sb.insert(0, '.'); } ip = ip >> 8; } return sb.toString(); } \",\"该方法接受一个长整型类型的IP地址，将其转换为对应的IPv4地址。具体地，将长整型类型的IP地址从右向左逐个取出每个8位，转换成十进制数，并使用\\\".\\\"连接四个部分，得到一个字符串类型的IPv4地址。\",\"例如，将长整型类型的IP地址 3232235521 转换为IPv4地址：\",\"long ipLong = 3232235521L; String ipAddress = longToIp(ipLong); System.out.println(ipAddress); // 输出 192.168.0.1 \",\"其中，输出的结果 \\\"192.168.0.1\\\" 就是该长整型类型的IP地址对应的IPv4地址表示。\"]},{\"header\":\"3 校验一段字符串是否是IPV4\",\"slug\":\"_3-校验一段字符串是否是ipv4\",\"contents\":[\"public static boolean isIpv4Address(String input) { if (input == null || input.isEmpty()) { return false; } String[] parts = input.split(\\\"\\\\\\\\.\\\"); if (parts.length != 4) { return false; } for (String part : parts) { try { int value = Integer.parseInt(part); if (value < 0 || value > 255) { return false; } } catch (NumberFormatException e) { return false; } } return true; } \",\"该方法接受一个字符串参数，用于检查该字符串是否是IPv4地址\",\"检查输入字符串是否为空或者null，如果是，则返回false\",\"使用\\\".\\\"分隔符将输入字符串拆分成四个字符串部分，如果拆分后的字符串部分数量不是4，则返回false\",\"接着，该方法会逐个检查每个字符串部分是否是一个介于0和255之间的整数，如果不是，则返回false\",\"最后，如果所有的检查都通过，则返回true，表示输入字符串是一个IPv4地址\",\"例如，检查字符串 \\\"192.168.0.1\\\" 是否是IPv4地址：\",\"String input = \\\"192.168.0.1\\\"; boolean isIpv4 = isIpv4Address(input); System.out.println(isIpv4); // 输出 true \"]}]},\"/ComputerBasics/ComputerNetwork/computernetwork02.html\":{\"title\":\"计算机网络02\",\"contents\":[{\"header\":\"1 snmp协议的概念\",\"slug\":\"_1-snmp协议的概念\",\"contents\":[\"SNMP（Simple Network Management Protocol）是一种用于网络管理的应用层协议，它可以在网络中的设备之间进行通信和信息交换，从而实现对网络设备的监控、配置和管理。SNMP协议定义了一组标准的消息格式和协议操作，可以实现对网络设备的远程管理和监控。\",\"SNMP协议主要包括以下几个部分：\",\"管理站：指执行网络管理任务的计算机或者设备，使用SNMP协议向网络设备发送请求，获取设备的状态信息。\",\"管理代理：指网络设备上的软件模块，用于响应管理站的请求，提供设备的状态信息和配置数据。\",\"管理信息库：指保存在管理代理中的设备状态信息和配置数据，可以由管理站查询和修改。\",\"管理对象：指网络设备中的各种资源，例如接口、路由表、系统信息等，可以由管理站查询和配置。\",\"SNMP协议通常使用UDP协议进行通信，它支持三种主要的操作：\",\"Get：指获取一个或多个管理对象的值，管理站向管理代理发送Get请求，管理代理返回管理对象的值。\",\"Set：指设置一个或多个管理对象的值，管理站向管理代理发送Set请求，管理代理设置管理对象的值。\",\"Trap：指在管理代理发生重要事件时主动向管理站发送通知，例如设备出现故障或者网络流量超过阈值等。\",\"SNMP协议是一个重要的网络管理协议，它可以帮助网络管理员实现对网络设备的远程监控和管理，提高网络的可靠性和性能。同时，SNMP协议也具有一定的安全风险，因此在使用SNMP协议时需要采取适当的安全措施，例如使用安全版本的SNMP协议和加密传输等。\"]},{\"header\":\"2 交换机阻断和iptables防火墙阻断的原理和实现\",\"slug\":\"_2-交换机阻断和iptables防火墙阻断的原理和实现\",\"contents\":[]},{\"header\":\"2.1 交换机阻断原理\",\"slug\":\"_2-1-交换机阻断原理\",\"contents\":[\"交换机阻断（Port Security）是一种网络安全措施，可以限制接入网络的设备数量，并防止未经授权的设备接入网络。\",\"交换机阻断通常可以通过以下两种方式来实现：\",\"静态MAC地址绑定：在交换机上配置一个静态MAC地址表，将每个接口绑定到特定的MAC地址上。当网络设备连接到交换机的接口上时，交换机会检查设备的MAC地址是否在该接口的绑定列表中，如果不在，则该接口被阻断，设备无法连接到网络。\",\"动态MAC地址学习：交换机可以动态学习每个接口连接的设备的MAC地址，并将其记录在MAC地址表中。当新设备连接到交换机的接口上时，交换机会将其MAC地址添加到MAC地址表中，并检查该MAC地址是否超过了预定义的阈值（通常是1或2个设备），如果超过了阈值，则该接口被阻断，设备无法连接到网络。\"]},{\"header\":\"2.2 交换机阻断的实现\",\"slug\":\"_2-2-交换机阻断的实现\",\"contents\":[]},{\"header\":\"2.3 iptables防火墙阻断的原理\",\"slug\":\"_2-3-iptables防火墙阻断的原理\",\"contents\":[\"iptables是Linux系统中的一个防火墙软件，用于过滤和管理网络数据包。它的阻断原理可以简单概括为以下三个步骤：\",\"匹配规则：iptables会按照事先定义好的规则对接收到的每个网络数据包进行匹配。规则可以根据IP地址、端口号、协议类型等多个条件来匹配。\",\"判断动作：如果匹配成功，iptables会根据规则中定义的动作来判断是否阻断该数据包。常见的动作包括DROP（丢弃该数据包）、REJECT（拒绝该数据包并向发送端发送一个错误消息）和ACCEPT（接受该数据包）。\",\"执行动作：如果匹配成功且判断动作为DROP或REJECT，则iptables会阻断该数据包；否则，iptables会允许该数据包通过防火墙并传递到下一层网络设备。\"]},{\"header\":\"2.4 iptables防火墙阻断的实现\",\"slug\":\"_2-4-iptables防火墙阻断的实现\",\"contents\":[]},{\"header\":\"3 主动扫描和被动扫描的区别\",\"slug\":\"_3-主动扫描和被动扫描的区别\",\"contents\":[\"主动扫描和被动扫描是网络安全中两种常见的扫描方式，它们的区别如下：\",\"主动扫描：是指通过专门的扫描工具，对网络中的目标进行主动扫描，以便发现目标的漏洞和弱点。主动扫描通常需要事先对目标进行信息收集，例如获取目标的IP地址、端口和服务信息等，然后使用专门的扫描工具对目标进行扫描。主动扫描具有主动性、准确性和高效性等特点，但也容易引起目标系统的警觉和防御。\",\"被动扫描：是指通过对网络流量进行监听和分析，发现网络中的目标漏洞和弱点。被动扫描通常不需要对目标进行主动扫描，而是通过对目标系统的网络流量进行分析，发现其中的异常或者恶意行为。被动扫描具有隐蔽性和针对性等特点，但需要对网络流量进行实时监控和分析，并且可能会误报或漏报目标的漏洞和弱点。\"]},{\"header\":\"4 写一个多线程的Java实例\",\"slug\":\"_4-写一个多线程的java实例\",\"contents\":[\"不要完全照搬网上，结合自己的一些想法，写一个带点业务性质的实例\",\"public class BankAccount { private double balance; // 银行账户余额 public BankAccount(double balance) { this.balance = balance; } // 取款操作 public synchronized void withdraw(double amount) { if (balance >= amount) { System.out.println(Thread.currentThread().getName() + \\\"正在取款：\\\" + amount); balance -= amount; System.out.println(Thread.currentThread().getName() + \\\"取款成功，余额为：\\\" + balance); } else { System.out.println(Thread.currentThread().getName() + \\\"取款失败，余额不足！\\\"); } } public static void main(String[] args) { BankAccount account = new BankAccount(1000); // 初始化银行账户余额为1000元 // 创建多个线程模拟多个客户进行取款操作 Thread t1 = new Thread(() -> account.withdraw(500), \\\"客户A\\\"); Thread t2 = new Thread(() -> account.withdraw(300), \\\"客户B\\\"); Thread t3 = new Thread(() -> account.withdraw(200), \\\"客户C\\\"); // 启动多个线程，进行取款操作 t1.start(); t2.start(); t3.start(); } } \"]},{\"header\":\"5 建两张表，主、从表，然后关联查询出对应的信息\",\"slug\":\"_5-建两张表-主、从表-然后关联查询出对应的信息\",\"contents\":[\"如：ipv4信息表，ipv4端口表，需要关联两张表查询出对应的IP信息和端口信息\",\"假设有两张表ipv4和ipv4_port，ipv4表中包含ipv4地址的信息，ipv4_port表中包含ipv4地址的端口信息，可以通过以下SQL语句实现关联查询：\",\"SELECT ipv4.ip, ipv4_port.port, ipv4_port.service FROM ipv4 LEFT JOIN ipv4_port ON ipv4.ip = ipv4_port.ip \",\"在上述SQL语句中，使用LEFT JOIN关键字将ipv4和ipv4_port表进行关联，关联条件为ipv4表中的ip字段和ipv4_port表中的ip字段相等。SELECT语句中选择ipv4表中的ip字段，ipv4_port表中的port字段和service字段。\",\"LEFT JOIN关键字表示左连接，即返回左表（ipv4表）中所有记录，以及匹配右表（ipv4_port表）中的记录。如果没有匹配的记录，则返回NULL。如果需要返回右表中所有记录，则可以使用RIGHT JOIN关键字。如果需要返回两个表中都存在的记录，则可以使用INNER JOIN关键字。\"]}]},\"/Database/NoSQL/\":{\"title\":\"NoSQL\",\"contents\":[]},\"/Database/SQL/\":{\"title\":\"MySQL基础\",\"contents\":[{\"header\":\"1 数据库相关概念\",\"slug\":\"_1-数据库相关概念\",\"contents\":[\"数据持久化的存储采用的是文件存储。\"]},{\"header\":\"1.1 数据库\",\"slug\":\"_1-1-数据库\",\"contents\":[\"DataBase，简称 DB。\",\"存储和管理数据的仓库。\"]},{\"header\":\"1.2 数据库管理系统\",\"slug\":\"_1-2-数据库管理系统\",\"contents\":[\"DataBase Management System，简称 DBMS\",\"管理数据库的大型软件\"]},{\"header\":\"1.3 常见的数据库管理系统\",\"slug\":\"_1-3-常见的数据库管理系统\",\"contents\":[\"Oracle：收费的大型数据库\",\"MySQL： 开源免费的中小型数据库。后来 Sun 公司收购了 MySQL，而 Sun 公司又被 Oracle 收购\",\"SQL Server：MicroSoft 公司收费的中型数据库。C#、.net 等语言常使用\",\"PostgreSQL：开源免费的中小型数据库\",\"DB2：IBM 公司的大型收费数据库产品\",\"SQLite：嵌入式的微型数据库。如：作为 Android 内置数据库\",\"MariaDB：开源免费中小型的数据库\"]},{\"header\":\"2 MySQL数据模型\",\"slug\":\"_2-mysql数据模型\",\"contents\":[]},{\"header\":\"2.1 关系型数据库\",\"slug\":\"_2-1-关系型数据库\",\"contents\":[\"关系型数据库是 建立在关系模型基础上的数据库\",\"关系型数据库是 由多张能互相连接的 二维表 组成的数据库\",\"上图中右边的 db.frm 是表文件，db.MYD 是数据文件，通过这两个文件就可以查询到数据展示成二维表的效果。\"]},{\"header\":\"2.2 小结\",\"slug\":\"_2-2-小结\",\"contents\":[\"MySQL 中可以创建多个数据库，每个数据库对应到磁盘上的一个文件夹\",\"在每个数据库中可以创建多个表，每张都对应到磁盘上一个 frm 文件\",\"每张表可以存储多条数据，数据会被存储到磁盘中 MYD 文件中\"]},{\"header\":\"3 SQL概述\",\"slug\":\"_3-sql概述\",\"contents\":[]},{\"header\":\"3.1 SQL简介\",\"slug\":\"_3-1-sql简介\",\"contents\":[\"Structured Query Language，简称 SQL，结构化查询语言\",\"SQL\",\"操作关系型数据库的编程语言 定义操作所有关系型数据库的统一标准，可以使用SQL操作所有的关系型数据库管理系统\",\"对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”\"]},{\"header\":\"3.2 SQL分类\",\"slug\":\"_3-2-sql分类\",\"contents\":[\"SQL语句根据其功能被分为四大类：DDL、DML、DQL、DCL\",\"分类\",\"全称\",\"说明\",\"DDL\",\"Data Definition Language\",\"数据定义语言，用来定义数据库对象(数据库，表，字段)\",\"DML\",\"Data Manipulation Language\",\"数据操作语言，用来对数据库表中的数据进行增删改\",\"DQL\",\"Data Query Language\",\"数据查询语言，用来查询数据库中表的记录\",\"DCL\",\"Data Control Language\",\"数据控制语言，用来创建数据库用户、控制数据库的访问权限\",\"注意： 开发中最常用操作就是 DML 和 DQL\"]},{\"header\":\"4 数据类型\",\"slug\":\"_4-数据类型\",\"contents\":[\"MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。\"]},{\"header\":\"4.1 数值类型\",\"slug\":\"_4-1-数值类型\",\"contents\":[\"类型\",\"大小\",\"有符号(SIGNED)范围\",\"无符号(UNSIGNED)范围\",\"TINYINT\",\"1byte\",\"(-128，127)\",\"(0，255)\",\"SMALLINT\",\"2bytes\",\"(-32768，32767)\",\"(0，65535)\",\"MEDIUMINT\",\"3bytes\",\"(-8388608，8388607)\",\"(0，16777215)\",\"INT/INTEGER\",\"4bytes\",\"(-2147483648，2147483647)\",\"(0，4294967295)\",\"BIGINT\",\"8bytes\",\"(-2^63, 2^63-1)\",\"(0，2^64-1)\",\"FLOAT\",\"4bytes\",\"(-3.402823466 E+38，3.402823466351 E+38)\",\"0 和 (1.175494351 E-38，3.402823466 E+38)\",\"DOUBLE\",\"8bytes\",\"(-1.7976931348623157 E+308，1.7976931348623157 E+308)\",\"0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)\",\"DECIMAL\",\"依赖于M(精度)和D(标度)的值\",\"依赖于M(精度)和D(标度)的值\"]},{\"header\":\"4.2 字符串类型\",\"slug\":\"_4-2-字符串类型\",\"contents\":[\"类型\",\"大小\",\"描述\",\"CHAR\",\"0-255 bytes\",\"定长字符串(需要指定长度)\",\"VARCHAR\",\"0-65535 bytes\",\"变长字符串(需要指定长度)\",\"TINYBLOB\",\"0-255 bytes\",\"不超过255个字符的二进制数据\",\"TINYTEXT\",\"0-255 bytes\",\"短文本字符串\",\"BLOB\",\"0-65 535 bytes\",\"二进制形式的长文本数据\",\"TEXT\",\"0-65 535 bytes\",\"长文本数据\",\"MEDIUMBLOB\",\"0-16 777 215 bytes\",\"二进制形式的中等长度文本数据\",\"MEDIUMTEXT\",\"0-16 777 215 bytes\",\"中等长度文本数据\",\"LONGBLOB\",\"0-4 294 967 295 bytes\",\"二进制形式的极大文本数据\",\"LONGTEXT\",\"0-4 294 967 295 bytes\",\"极大文本数据\",\"char 与 varchar\",\"char 与 varchar 都可以描述字符串\",\"char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 varchar是变长字符串，指定的长度为最大占用长度。\"]},{\"header\":\"4.3 日期时间类型\",\"slug\":\"_4-3-日期时间类型\",\"contents\":[\"类型\",\"大小\",\"范围\",\"格式\",\"描述\",\"DATE\",\"3\",\"1000-01-01 至 9999-12-31\",\"YYYY-MM-DD\",\"日期值\",\"TIME\",\"3\",\"-838:59:59 至 838:59:59\",\"HH:MM:SS\",\"时间值或持续时间\",\"YEAR\",\"1\",\"1901 至 2155\",\"YYYY\",\"年份值\",\"DATETIME\",\"8\",\"1000-01-01 00:00:00 至 9999-12-31 23:59:59\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值\",\"TIMESTAMP\",\"4\",\"1970-01-01 00:00:01 至 2038-01-19 03:14:07\",\"YYYY-MM-DD HH:MM:SS\",\"混合日期和时间值，时间戳\"]}]},\"/Database/SQL/sql01.html\":{\"title\":\"DDL\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Data Definition Language\"]},{\"header\":\"1. 操作数据库\",\"slug\":\"_1-操作数据库\",\"contents\":[]},{\"header\":\"1.1 查询所有的数据库\",\"slug\":\"_1-1-查询所有的数据库\",\"contents\":[\"SHOW DATABASES; \"]},{\"header\":\"1.2 创建数据库\",\"slug\":\"_1-2-创建数据库\",\"contents\":[\"CREATE DATABASE 数据库名称; CREATE DATABASE IF NOT EXISTS 数据库名称; \"]},{\"header\":\"1.3 删除数据库\",\"slug\":\"_1-3-删除数据库\",\"contents\":[\"DROP DATABASE 数据库名称; DROP DATABASE IF EXISTS 数据库名称; \"]},{\"header\":\"1.4 使用数据库\",\"slug\":\"_1-4-使用数据库\",\"contents\":[\"USE 数据库名称; \"]},{\"header\":\"1.5 查看当前使用的数据库\",\"slug\":\"_1-5-查看当前使用的数据库\",\"contents\":[\"SELECT DATABASE(); \"]},{\"header\":\"2. 操作表\",\"slug\":\"_2-操作表\",\"contents\":[\"对表进行 增（Create）删（Delete）改（Update）查（Retrieve）\"]},{\"header\":\"2.1 查询表\",\"slug\":\"_2-1-查询表\",\"contents\":[\"查询当前数据库下所有表名称\",\"SHOW TABLES; \",\"查询表结构\",\"DESC 表名称; \"]},{\"header\":\"2.2 创建表\",\"slug\":\"_2-2-创建表\",\"contents\":[\"CREATE TABLE 表名 ( 字段名1 数据类型1, 字段名2 数据类型2, … 字段名n 数据类型n ); \",\"注意：最后一行末尾，不能加逗号\",\"create table tb_user ( id int, username varchar(20), password varchar(32) ); \"]},{\"header\":\"2.3 删除表\",\"slug\":\"_2-3-删除表\",\"contents\":[\"DROP TABLE 表名; DROP TABLE IF EXISTS 表名; \"]},{\"header\":\"2.4 修改表\",\"slug\":\"_2-4-修改表\",\"contents\":[\"ALTER TABLE 表名 RENAME TO 新的表名; -- 将表名student修改为stu alter table student rename to stu; \",\"添加一列\",\"ALTER TABLE 表名 ADD 列名 数据类型; -- 给stu表添加一列address，该字段类型是varchar(50) alter table stu add address varchar(50); \",\"修改数据类型\",\"ALTER TABLE 表名 MODIFY 列名 新数据类型; -- 将stu表中的address字段的类型改为 char(50) alter table stu modify address char(50); \",\"修改列名和数据类型\",\"ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型; -- 将stu表中的address字段名改为 addr，类型改为varchar(50) alter table stu change address addr varchar(50); \",\"删除列\",\"ALTER TABLE 表名 DROP 列名; -- 将stu表中的addr字段 删除 alter table stu drop addr; \"]}]},\"/Database/SQL/sql02.html\":{\"title\":\"DML\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Data Manipulation Language\",\"DML主要是对数据进行 增（insert）删（delete）改（update）操作。\"]},{\"header\":\"1 添加数据\",\"slug\":\"_1-添加数据\",\"contents\":[\"给指定列添加数据\",\"INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…); \",\"给全部列添加数据\",\"INSERT INTO 表名 VALUES(值1,值2,…); \",\"批量添加数据\",\"INSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…; \",\"练习:\",\"select * from stu; -- 给指定列添加数据 INSERT INTO stu (id, NAME) VALUES (1, '张三'); -- 给所有列添加数据，列名的列表可以省略的 INSERT INTO stu (id,NAME,sex,birthday,score,email,tel,STATUS) VALUES (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1); INSERT INTO stu VALUES (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1); -- 批量添加数据 INSERT INTO stu VALUES (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1), (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1), (2,'李四','男','1999-11-11',88.88,'lisi@itcast.cn','13888888888',1); \"]},{\"header\":\"2 删除数据\",\"slug\":\"_2-删除数据\",\"contents\":[\"DELETE FROM 表名 [WHERE 条件] ; \",\"练习:\",\"-- 删除张三记录 delete from stu where name = '张三'; -- 删除stu表中所有的数据 delete from stu; \"]},{\"header\":\"3 修改数据\",\"slug\":\"_3-修改数据\",\"contents\":[\"UPDATE 表名 SET 列名1=值1,列名2=值2,… [WHERE 条件] ; \",\"练习:\",\"将张三的性别改为女\",\"update stu set sex = '女' where name = '张三'; \",\"将张三的生日改为 1999-12-12 分数改为99.99\",\"update stu set birthday = '1999-12-12', score = 99.99 where name = '张三'; \",\"注意：如果update语句没有加where条件，则会将表中所有数据全部修改！\",\"update stu set sex = '女'; \"]}]},\"/Database/SQL/sql03.html\":{\"title\":\"DQL\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Data Query Language\",\"SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段 HAVING 分组后条件 ORDER BY 排序字段 LIMIT 分页限定 \",\"准备表及一些数据：\",\"-- 删除stu表 drop table if exists stu; -- 创建stu表 CREATE TABLE stu ( id int, -- 编号 name varchar(20), -- 姓名 age int, -- 年龄 sex varchar(5), -- 性别 address varchar(100), -- 地址 math double(5,2), -- 数学成绩 english double(5,2), -- 英语成绩 hire_date date -- 入学时间 ); -- 添加数据 INSERT INTO stu(id,NAME,age,sex,address,math,english,hire_date) VALUES (1,'马运',55,'男','杭州',66,78,'1995-09-01'), (2,'马花疼',45,'女','深圳',98,87,'1998-09-01'), (3,'马斯克',55,'男','香港',56,77,'1999-09-02'), (4,'柳白',20,'女','湖南',76,65,'1997-09-05'), (5,'柳青',20,'男','湖南',86,NULL,'1998-09-01'), (6,'刘德花',57,'男','香港',99,99,'1998-09-01'), (7,'张学右',22,'女','香港',99,99,'1998-09-01'), (8,'德玛西亚',18,'男','南京',56,65,'1994-09-02'); \"]},{\"header\":\"1. 基础查询\",\"slug\":\"_1-基础查询\",\"contents\":[]},{\"header\":\"1.1 语法\",\"slug\":\"_1-1-语法\",\"contents\":[\"查询多个字段\",\"SELECT 字段列表 FROM 表名; SELECT * FROM 表名; -- 查询所有数据 \",\"去除重复记录\",\"SELECT DISTINCT 字段列表 FROM 表名; \",\"起别名\",\"AS: AS 也可以省略 \",\"练习\",\"查询name、age两列\",\"select name,age from stu; \",\"查询所有列的数据\",\"select * from stu; \",\"查询地址信息\",\"select address from stu; \",\"去除重复记录\",\"select distinct address from stu; \",\"查询姓名、数学成绩、英语成绩。并通过as给math和english起别名\",\"select name,math as 数学成绩,english as 英文成绩 from stu; select name,math 数学成绩,english 英文成绩 from stu; \"]},{\"header\":\"1.2 条件查询\",\"slug\":\"_1-2-条件查询\",\"contents\":[\"SELECT 字段列表 FROM 表名 WHERE 条件列表; \",\"条件\",\"条件列表运算符\",\"练习\",\"查询年龄大于20岁的学员信息\",\"select * from stu where age > 20; \",\"查询年龄 大于等于20岁 并且年龄 小于等于30岁 的学员信息\",\"select * from stu where age >= 20 and age <= 30; select * from stu where age BETWEEN 20 and 30; \",\"查询入学日期在 '1998-09-01' 到 '1999-09-01' 之间的学员信息\",\"select * from stu where hire_date BETWEEN '1998-09-01' and '1999-09-01'; \",\"查询年龄不等于18岁的学员信息\",\"select * from stu where age != 18; select * from stu where age <> 18; \",\"查询年龄等于18岁 或者 年龄等于20岁 或者 年龄等于22岁的学员信息\",\"select * from stu where age = 18 or age = 20 or age = 22; select * from stu where age in (18,20 ,22); \",\"查询英语成绩为 null 的学员信息\",\"值得注意的是：null值的比较不能使用 = or !=，需要使用 is 或者 is not\",\"select * from stu where english is null; select * from stu where english is not null; select * from stu where english = null; -- 这个语句是不行的 \"]},{\"header\":\"1.3 模糊查询\",\"slug\":\"_1-3-模糊查询\",\"contents\":[\"使用like关键字, 可以使用通配符进行占位:\",\"（1）_ : 代表单个任意字符 （2）% : 代表任意个数字符\",\"查询姓'马'的学员信息\",\"select * from stu where name like '马%'; \",\"查询第二个字是'花'的学员信息\",\"select * from stu where name like '_花%'; \",\"查询名字中包含 '德' 的学员信息\",\"select * from stu where name like '%德%'; \"]},{\"header\":\"1.4 排序查询\",\"slug\":\"_1-4-排序查询\",\"contents\":[\"SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …; \",\"排序方式有两种\",\"ASC ： 升序排列 （默认值） DESC ： 降序排列\",\"练习\",\"查询学生信息，按照年龄升序排列\",\"select * from stu order by age ; \",\"查询学生信息，按照数学成绩降序排列\",\"select * from stu order by math desc ; \",\"查询学生信息，按照数学成绩降序排列，如果数学成绩一样，再按照英语成绩升序排列\",\"select * from stu order by math desc, english asc ; \"]},{\"header\":\"1.5 聚合函数\",\"slug\":\"_1-5-聚合函数\",\"contents\":[\"将一列数据作为一个整体，进行纵向计算。\",\"函数名\",\"功能\",\"count(列名)\",\"统计数量（一般选用不为null的列）\",\"max(列名)\",\"最大值\",\"min(列名)\",\"最小值\",\"sum(列名)\",\"求和\",\"avg(列名)\",\"平均值\",\"语法:\",\"SELECT 聚合函数名(列名) FROM 表; 值得注意的是：null 值不参与所有聚合函数运算 \",\"练习\",\"统计班级一共有多少个学生\",\"select count(*) from stu; \",\"查询数学成绩的最高分\",\"select max(math) from stu; \",\"查询数学成绩的最低分\",\"select min(math) from stu; \",\"查询数学成绩的总分\",\"select sum(math) from stu; \",\"查询数学成绩的平均分\",\"select avg(math) from stu; \",\"查询英语成绩的最低分\",\"select min(english) from stu; \"]},{\"header\":\"1.6 分组查询\",\"slug\":\"_1-6-分组查询\",\"contents\":[\"SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤]; \",\"练习\",\"查询男同学和女同学各自的数学平均分\",\"select sex, avg(math) from stu group by sex; \",\"注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义\",\"select name, sex, avg(math) from stu group by sex; -- 这里查询name字段就没有任何意义 \",\"查询男同学和女同学各自的数学平均分，以及各自人数\",\"select sex, avg(math), count(*) from stu group by sex; \",\"查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组\",\"select sex, avg(math), count(*) from stu where math > 70 group by sex; \",\"查询男同学和女同学各自的数学平均分，以及各自人数，要求：分数低于70分的不参与分组，分组之后人数大于2个的\",\"select sex, avg(math), count(*) from stu where math > 70 group by sex having count(*) > 2; \",\"where 和 having 区别\",\"执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。\",\"可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。\"]},{\"header\":\"1.7 分页查询\",\"slug\":\"_1-7-分页查询\",\"contents\":[\"SELECT 字段列表 FROM 表名 LIMIT 起始索引 , 查询条目数; \",\"注意： 起始索引从0开始\",\"练习\",\"从0开始查询，查询3条数据\",\"select * from stu limit 0 , 3; \",\"每页显示3条数据，查询第1页数据\",\"select * from stu limit 0 , 3; \",\"每页显示3条数据，查询第2页数据\",\"select * from stu limit 3 , 3; \",\"每页显示3条数据，查询第3页数据\",\"select * from stu limit 6 , 3; \",\"推导出起始索引计算公式：\",\"起始索引 = (当前页码 - 1) * 每页显示的条数 \"]}]},\"/Database/SQL/sql04.html\":{\"title\":\"MySQL高级\",\"contents\":[{\"header\":\"1 约束\",\"slug\":\"_1-约束\",\"contents\":[\"在MySQL数据库当中，提供了以下5种约束：\",\"约束\",\"描述\",\"关键字\",\"非空约束\",\"限制该字段值不能为null\",\"not null\",\"唯一约束\",\"保证字段的所有数据都是唯一、不重复的\",\"unique\",\"主键约束\",\"主键是一行数据的唯一标识，要求非空且唯一\",\"primary key\",\"默认约束\",\"保存数据时，如果未指定该字段值，则采用默认值\",\"default\",\"外键约束\",\"让两张表的数据建立连接，保证数据的一致性和完整性\",\"foreign key\",\"练习\",\"-- 员工表 CREATE TABLE emp ( id INT, -- 员工id，主键且自增长 ename VARCHAR(50), -- 员工姓名，非空且唯一 joindate DATE, -- 入职日期，非空 salary DOUBLE(7,2), -- 工资，非空 bonus DOUBLE(7,2) -- 奖金，如果没有将近默认为0 ); \",\"DROP TABLE IF EXISTS emp; -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY auto_increment, -- 员工id，主键且自增长 ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空并且唯一 joindate DATE NOT NULL , -- 入职日期，非空 salary DOUBLE(7,2) NOT NULL , -- 工资，非空 bonus DOUBLE(7,2) DEFAULT 0 -- 奖金，如果没有奖金默认为0 ); \",\"注意：默认约束只有在不给值时才会采用默认值。如果给了null，那值就是null值。\"]},{\"header\":\"1.1 外键约束\",\"slug\":\"_1-1-外键约束\",\"contents\":[\"外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。\",\"添加外键约束\",\"-- 创建表时添加外键约束 CREATE TABLE 表名( 列名 数据类型, … [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) ); \",\"-- 建完表后添加外键约束 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); \",\"删除外键约束\",\"ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; \",\"练习\",\"-- 删除表 DROP TABLE IF EXISTS emp; DROP TABLE IF EXISTS dept; -- 部门表 CREATE TABLE dept( id int primary key auto_increment, dep_name varchar(20), addr varchar(20) ); -- 员工表 CREATE TABLE emp( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 添加外键 dep_id,关联 dept 表的id主键 CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id) ); \",\"添加数据\",\"-- 添加 2 个部门 insert into dept(dep_name,addr) values ('研发部','广州'),('销售部', '深圳'); -- 添加员工,dep_id 表示员工所在的部门 INSERT INTO emp (NAME, age, dep_id) VALUES ('张三', 20, 1), ('李四', 20, 1), ('王五', 20, 1), ('赵六', 20, 2), ('孙七', 22, 2), ('周八', 18, 2); \",\"此时删除 研发部 这条数据，会发现无法删除。\",\"删除外键\",\"alter table emp drop FOREIGN key fk_emp_dept; \",\"重新添加外键\",\"alter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id); \"]},{\"header\":\"2 数据库设计\",\"slug\":\"_2-数据库设计\",\"contents\":[]},{\"header\":\"2.1 表关系\",\"slug\":\"_2-1-表关系\",\"contents\":[\"一对一\",\"如：用户 和 用户详情\",\"一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能\",\"一对多\",\"如：部门 和 员工\",\"一个部门对应多个员工，一个员工对应一个部门。\",\"多对多\",\"如：商品 和 订单\",\"一个商品对应多个订单，一个订单包含多个商品。\"]},{\"header\":\"2.2 表关系(一对多)\",\"slug\":\"_2-2-表关系-一对多\",\"contents\":[\"实现方式\",\"在多的一方建立外键，指向少的一方的主键\",\"案例\",\"经过分析发现，员工表属于多的一方，而部门表属于少的一方，此时我们会在员工表中添加一列（dep_id），指向于部门表的主键（id）：\",\"建表语句如下：\",\"-- 删除表 DROP TABLE IF EXISTS tb_emp; DROP TABLE IF EXISTS tb_dept; -- 部门表 CREATE TABLE tb_dept( id int primary key auto_increment, dep_name varchar(20), addr varchar(20) ); -- 员工表 CREATE TABLE tb_emp( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 添加外键 dep_id,关联 dept 表的id主键 CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES tb_dept(id) ); \"]},{\"header\":\"2.3 表关系(多对多)\",\"slug\":\"_2-3-表关系-多对多\",\"contents\":[\"实现方式\",\"建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\",\"案例\",\"以 订单表 和 商品表 举例：\",\"在中间表中添加订单表的外键和商品表的外键指向两张表的主键：\",\"建表语句如下：\",\"-- 删除表 DROP TABLE IF EXISTS tb_order_goods; DROP TABLE IF EXISTS tb_order; DROP TABLE IF EXISTS tb_goods; -- 订单表 CREATE TABLE tb_order( id int primary key auto_increment, payment double(10,2), payment_type TINYINT, status TINYINT ); -- 商品表 CREATE TABLE tb_goods( id int primary key auto_increment, title varchar(100), price double(10,2) ); -- 订单商品中间表 CREATE TABLE tb_order_goods( id int primary key auto_increment, order_id int, goods_id int, count int ); -- 建完表后，添加外键 alter table tb_order_goods add CONSTRAINT fk_order_id FOREIGN key(order_id) REFERENCES tb_order(id); alter table tb_order_goods add CONSTRAINT fk_goods_id FOREIGN key(goods_id) REFERENCES tb_goods(id); \",\"查看表结构模型图：\"]},{\"header\":\"2.4 表关系(一对一)\",\"slug\":\"_2-4-表关系-一对一\",\"contents\":[\"实现方式\",\"在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)\",\"案例\",\"而在真正使用过程中发现 id、photo、nickname、age、gender 字段比较常用，此时就可以将这张表查分成两张表。\",\"建表语句如下：\",\"create table tb_user_desc ( id int primary key auto_increment, city varchar(20), edu varchar(10), income int, status char(2), des varchar(100) ); create table tb_user ( id int primary key auto_increment, photo varchar(100), nickname varchar(50), age int, gender char(1), desc_id int unique, -- 添加外键 CONSTRAINT fk_user_desc FOREIGN KEY(desc_id) REFERENCES tb_user_desc(id) ); \",\"查看表结构模型图：\"]},{\"header\":\"3 多表查询\",\"slug\":\"_3-多表查询\",\"contents\":[\"DROP TABLE IF EXISTS emp; DROP TABLE IF EXISTS dept; # 创建部门表 CREATE TABLE dept( did INT PRIMARY KEY AUTO_INCREMENT, dname VARCHAR(20) ); # 创建员工表 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dep_id INT, FOREIGN KEY (dep_id) REFERENCES dept(did) -- 外键，关联部门表(部门表的主键) ); -- 添加部门数据 INSERT INTO dept (dNAME) VALUES ('研发部'),('市场部'),('财务部'),('销售部'); -- 添加员工数据 INSERT INTO emp(NAME,gender,salary,join_date,dep_id) VALUES ('孙悟空','男',7200,'2013-02-24',1), ('猪八戒','男',3600,'2010-12-02',2), ('唐僧','男',9000,'2008-08-08',2), ('白骨精','女',5000,'2015-10-07',3), ('蜘蛛精','女',4500,'2011-03-14',1), ('小白龙','男',2500,'2011-02-14',null); \"]},{\"header\":\"3.1 内连接查询\",\"slug\":\"_3-1-内连接查询\",\"contents\":[\"语法\",\"-- 隐式内连接 SELECT 字段列表 FROM 表1,表2… WHERE 条件; -- 显示内连接 SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件; \",\"案例\",\"隐式内连接\",\"SELECT * FROM emp, dept WHERE emp.dep_id = dept.did; \",\"执行上述语句结果如下：\",\"查询 emp的 name， gender，dept表的dname\",\"SELECT t1.NAME, t1.gender, t2.dname FROM emp t1, dept t2 WHERE t1.dep_id = t2.did; \",\"显式内连接\",\"select * from emp inner join dept on emp.dep_id = dept.did; -- 上面语句中的inner可以省略，可以书写为如下语句 select * from emp join dept on emp.dep_id = dept.did; \"]},{\"header\":\"3.2 外连接查询\",\"slug\":\"_3-2-外连接查询\",\"contents\":[\"语法\",\"-- 左外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件; -- 右外连接 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件; \",\"左外连接：相当于查询A表所有数据和交集部分数据 右外连接：相当于查询B表所有数据和交集部分数据\",\"案例\",\"查询emp表所有数据和对应的部门信息（左外连接）\",\"select * from emp left join dept on emp.dep_id = dept.did; \",\"执行语句结果如下： \",\"查询dept表所有数据和对应的员工信息（右外连接）\",\"select * from emp right join dept on emp.dep_id = dept.did; \",\"执行语句结果如下： \",\"要查询出部门表中所有的数据，也可以通过左外连接实现，只需要将两个表的位置进行互换：\",\"select * from dept left join emp on emp.dep_id = dept.did; \"]},{\"header\":\"3.3 子查询\",\"slug\":\"_3-3-子查询\",\"contents\":[\"查询中嵌套查询，称嵌套查询为子查询。\",\"需求：查询工资高于猪八戒的员工信息\",\"第一步：先查询出来 猪八戒的工资\",\"select salary from emp where name = '猪八戒' \",\"第二步：查询工资高于猪八戒的员工信息\",\"select * from emp where salary > 3600; \",\"第二步中的3600可以通过第一步的sql查询出来，所以将3600用第一步的sql语句进行替换\",\"select * from emp where salary > (select salary from emp where name = '猪八戒'); \",\"子查询根据查询结果不同，作用不同\",\"子查询语句结果是单行单列，子查询语句作为条件值，使用 = != > < 等进行条件判断 子查询语句结果是多行单列，子查询语句作为条件值，使用 in 等关键字进行条件判断 子查询语句结果是多行多列，子查询语句作为虚拟表\",\"案例\",\"查询 '财务部' 和 '市场部' 所有的员工信息\",\"-- 查询 '财务部' 或者 '市场部' 所有的员工的部门did select did from dept where dname = '财务部' or dname = '市场部'; select * from emp where dep_id in (select did from dept where dname = '财务部' or dname = '市场部'); \",\"查询入职日期是 '2011-11-11' 之后的员工信息和部门信息\",\"-- 查询入职日期是 '2011-11-11' 之后的员工信息 select * from emp where join_date > '2011-11-11' ; -- 将上面语句的结果作为虚拟表和dept表进行内连接查询 select * from (select * from emp where join_date > '2011-11-11' ) t1, dept where t1.dep_id = dept.did; \"]},{\"header\":\"3.4 案例\",\"slug\":\"_3-4-案例\",\"contents\":[\"环境准备：\",\"DROP TABLE IF EXISTS emp; DROP TABLE IF EXISTS dept; DROP TABLE IF EXISTS job; DROP TABLE IF EXISTS salarygrade; -- 部门表 CREATE TABLE dept ( did INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); -- 职务表，职务名称，职务描述 CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50) ); -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id) ); -- 工资等级表 CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资 ); -- 添加4个部门 INSERT INTO dept(did,dname,loc) VALUES (10,'教研部','北京'), (20,'学工部','上海'), (30,'销售部','广州'), (40,'财务部','深圳'); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, '董事长', '管理整个公司，接单'), (2, '经理', '管理部门员工'), (3, '销售员', '向客人推销产品'), (4, '文员', '使用办公软件'); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,'孙悟空',4,1004,'2000-12-17','8000.00',NULL,20), (1002,'卢俊义',3,1006,'2001-02-20','16000.00','3000.00',30), (1003,'林冲',3,1006,'2001-02-22','12500.00','5000.00',30), (1004,'唐僧',2,1009,'2001-04-02','29750.00',NULL,20), (1005,'李逵',4,1006,'2001-09-28','12500.00','14000.00',30), (1006,'宋江',2,1009,'2001-05-01','28500.00',NULL,30), (1007,'刘备',2,1009,'2001-09-01','24500.00',NULL,10), (1008,'猪八戒',4,1004,'2007-04-19','30000.00',NULL,20), (1009,'罗贯中',1,NULL,'2001-11-17','50000.00',NULL,10), (1010,'吴用',3,1006,'2001-09-08','15000.00','0.00',30), (1011,'沙僧',4,1004,'2007-05-23','11000.00',NULL,20), (1012,'李逵',4,1006,'2001-12-03','9500.00',NULL,30), (1013,'小白龙',4,1004,'2001-12-03','30000.00',NULL,20), (1014,'关羽',4,1007,'2002-01-23','13000.00',NULL,10); -- 添加5个工资等级 INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000), (4,20010,30000), (5,30010,99990); \",\"需求\",\"查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述\",\"/* 分析： 1. 员工编号，员工姓名，工资 信息在emp 员工表中 2. 职务名称，职务描述 信息在 job 职务表中 3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id */ -- 方式一 ：隐式内连接 SELECT emp.id, emp.ename, emp.salary, job.jname, job.description FROM emp, job WHERE emp.job_id = job.id; -- 方式二 ：显式内连接 SELECT emp.id, emp.ename, emp.salary, job.jname, job.description FROM emp INNER JOIN job ON emp.job_id = job.id; \",\"查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置\",\"/* 分析： 1. 员工编号，员工姓名，工资 信息在emp 员工表中 2. 职务名称，职务描述 信息在 job 职务表中 3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id 4. 部门名称，部门位置 来自于 部门表 dept 5. dept 和 emp 一对多关系 dept.id = emp.dept_id */ -- 方式一 ：隐式内连接 SELECT emp.id, emp.ename, emp.salary, job.jname, job.description, dept.dname, dept.loc FROM emp, job, dept WHERE emp.job_id = job.id and dept.id = emp.dept_id ; -- 方式二 ：显式内连接 SELECT emp.id, emp.ename, emp.salary, job.jname, job.description, dept.dname, dept.loc FROM emp INNER JOIN job ON emp.job_id = job.id INNER JOIN dept ON dept.id = emp.dept_id \",\"查询员工姓名，工资，工资等级\",\"/* 分析： 1. 员工姓名，工资 信息在emp 员工表中 2. 工资等级 信息在 salarygrade 工资等级表中 3. emp.salary >= salarygrade.losalary and emp.salary <= salarygrade.hisalary */ SELECT emp.ename, emp.salary, t2.* FROM emp, salarygrade t2 WHERE emp.salary >= t2.losalary AND emp.salary <= t2.hisalary \",\"查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级\",\"/* 分析： 1. 员工编号，员工姓名，工资 信息在emp 员工表中 2. 职务名称，职务描述 信息在 job 职务表中 3. job 职务表 和 emp 员工表 是 一对多的关系 emp.job_id = job.id 4. 部门名称，部门位置 来自于 部门表 dept 5. dept 和 emp 一对多关系 dept.id = emp.dept_id 6. 工资等级 信息在 salarygrade 工资等级表中 7. emp.salary >= salarygrade.losalary and emp.salary <= salarygrade.hisalary */ SELECT emp.id, emp.ename, emp.salary, job.jname, job.description, dept.dname, dept.loc, t2.grade FROM emp INNER JOIN job ON emp.job_id = job.id INNER JOIN dept ON dept.id = emp.dept_id INNER JOIN salarygrade t2 ON emp.salary BETWEEN t2.losalary and t2.hisalary; \",\"查询出部门编号、部门名称、部门位置、部门人数\",\"/* 分析： 1. 部门编号、部门名称、部门位置 来自于部门 dept 表 2. 部门人数: 在emp表中 按照dept_id 进行分组，然后count(*) 统计数量 3. 使用子查询，让部门表和分组后的表进行内连接 */ -- 根据部门id分组查询每一个部门id和员工数 select dept_id, count(*) from emp group by dept_id; SELECT dept.id, dept.dname, dept.loc, t1.count FROM dept, ( SELECT dept_id, count(*) count FROM emp GROUP BY dept_id ) t1 WHERE dept.id = t1.dept_id \"]},{\"header\":\"4 事务\",\"slug\":\"_4-事务\",\"contents\":[\"数据库的事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令。\",\"事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败。\",\"语法：\",\"开启事务\",\"START TRANSACTION; 或者 BEGIN; \",\"提交事务\",\"commit; \",\"回滚事务\",\"rollback; \",\"环境准备\",\"DROP TABLE IF EXISTS account; -- 创建账户表 CREATE TABLE account( id int PRIMARY KEY auto_increment, name varchar(10), money double(10,2) ); -- 添加数据 INSERT INTO account(name,money) values('张三',1000),('李四',1000); \",\"添加事务sql如下：\",\"-- 开启事务 BEGIN; -- 转账操作 -- 1. 查询李四账户金额是否大于500 -- 2. 李四账户 -500 UPDATE account set money = money - 500 where name = '李四'; 出现异常了... -- 此处不是注释，在整体执行时后面的sql不执行 -- 3. 张三账户 +500 UPDATE account set money = money + 500 where name = '张三'; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; \",\"事务的四大特征\",\"原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败\",\"一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态\",\"隔离性（Isolation） :多个事务之间，操作的可见性\",\"持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\",\"说明：\",\"mysql中事务是自动提交的。\",\"查询到的结果是1表示自动提交，结果是0表示手动提交。\",\"SELECT @@autocommit; \",\"可以通过下面语句修改提交方式\",\"set @@autocommit = 0; \"]}]},\"/FrontEnd/CSS/\":{\"title\":\"什么是CSS ?\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Cascading Style Sheet，层叠样式表\",\"用于控制页面的样式（表现）\"]}]},\"/FrontEnd/CSS/css01.html\":{\"title\":\"CSS引入方式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"css引入方式主要有三种，分别是行行内样式、内嵌式、外链式。\",\"行内样式是直接把css代码放到HTML标签里面，作为style属性的属性值。\",\"<div style=\\\"width: 100px; height: 100px; border: 1px solid black;\\\"> 这是一个长宽都为100px的div </div> \",\"内嵌式是在HTML中创建一个style标签，把css样式写入style标签内，style标签可以写在HTML中的任何位置，通常写在head标签内。\",\"<style> div { width: 100px; height: 100px; border: 1px solid black; } </style> <div>这是一个长宽都为100px的div</div> \",\"外链式是把css样式写入.css文件内，然后通过link标签链接。\",\"/*css代码*/ div { width: 100px; height: 100px; border: 1px solid black; } \",\"<link rel=\\\"stylesheet\\\" href=\\\"url\\\"> <div>这是一个长宽都为100px的div</div> \"]}]},\"/FrontEnd/CSS/css02.html\":{\"title\":\"CSS选择器\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"选择器是选取需设置样式的元素（标签）\",\"3种选择器是元素选择器，id选择器，class选择器，语法以及作用如下：\"]},{\"header\":\"元素（标签）选择器\",\"slug\":\"元素-标签-选择器\",\"contents\":[\"选择器的名字必须是标签的名字\",\"作用：选择器中的样式会作用于所有同名的标签上\",\"元素名称 { css样式名:css样式值； } \",\"例子如下：\",\"div{ color: red; } \"]},{\"header\":\"id选择器\",\"slug\":\"id选择器\",\"contents\":[\"选择器的名字前面需要加上#\",\"作用：选择器中的样式会作用于指定id的标签上，有且只有一个标签（由于id是唯一的）\",\"#id属性值 { css样式名:css样式值； } \",\"例子如下：\",\"#did { color: blue; } \"]},{\"header\":\"类选择器\",\"slug\":\"类选择器\",\"contents\":[\"选择器的名字前面需要加上 .\",\"作用：选择器中的样式会作用于所有class的属性值和该名字一样的标签上，可以是多个\",\".class属性值 { css样式名:css样式值； } \",\"例子如下：\",\".cls{ color: green; } \",\"text-indent: 设置段落的首行缩进\",\"line-height: 设置行高\",\"text-align: 设置对齐方式, 可取值为 left / center / right\"]}]},\"/FrontEnd/CSS/css03.html\":{\"title\":\"CSS页面布局\",\"contents\":[{\"header\":\"盒子模型\",\"slug\":\"盒子模型\",\"contents\":[\"盒子：页面中所有的元素（标签），都可以看做是一个 盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局\",\"盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）\",\"CSS盒子模型，其实和日常生活中的包装盒是非常类似的，就比如：\",\"盒子的大小，其实就包括三个部分： border、padding、content，而margin外边距是不包括在盒子之内的。\"]},{\"header\":\"盒子模型代码\",\"slug\":\"盒子模型代码\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>盒子模型</title> <style> div { width: 200px; /* 宽度 */ height: 200px; /* 高度 */ box-sizing: border-box; /* 指定width height为盒子的高宽 */ background-color: aquamarine; /* 背景色 */ padding: 20px 20px 20px 20px; /* 内边距, 上 右 下 左 , 边距都一行, 可以简写: padding: 20px;*/ border: 10px solid red; /* 边框, 宽度 线条类型 颜色 */ margin: 30px 30px 30px 30px; /* 外边距, 上 右 下 左 , 边距都一行, 可以简写: margin: 30px; */ } </style> </head> <body> <div> A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A </div> </body> </html> \",\"盒子各个组成部分(内容、内边距、边框、外边距)：\",\"image-20230310094312355\",\"我们也可以，通过浏览器的开发者工具，清晰的看到这个盒子，以及每一个部分的大小：\",\"image-20230310094412539\"]},{\"header\":\"布局实现\",\"slug\":\"布局实现\",\"contents\":[\"在实现新闻页面的布局时，我们需要做两部操作：\",\"第一步：需要将body中的新闻标题部分、正文部分使用一个 div 布局标签将其包裹起来，方便通过css设置内容占用的宽度，比如：65%。\",\"第二步：通过css为该div设置外边距，左右的外边距分别为：17.5%，上下外边距靠边展示即可，为：0%。\",\"代码实现如下：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>焦点访谈：中国底气 新思想夯实大国粮仓</title> <style> h1 { color: #4D4F53; } #time { color: #968D92; font-size: 13px; /* 设置字体大小 */ } a { color: black; text-decoration: none; /* 设置文本为一个标准的文本 */ } p { text-indent: 35px; /* 设置首行缩进 */ line-height: 40px; /* 设置行高 */ } #plast { text-align: right; /* 对齐方式 */ } #center { width: 65%; /* margin: 0% 17.5% 0% 17.5% ; */ /* 外边距, 上 右 下 左 */ margin: 0 auto; } </style> </head> <body> <div id=\\\"center\\\"> <!-- 标题 --> <img src=\\\"img/news_logo.png\\\"> <a href=\\\"http://gov.sina.com.cn/\\\" target=\\\"_self\\\">新浪政务</a> > 正文 <h1>焦点访谈：中国底气 新思想夯实大国粮仓</h1> <hr> <span id=\\\"time\\\">2023年03月02日 21:50</span> <span><a href=\\\"https://news.cctv.com/2023/03/02/ARTIUCKFf9kE9eXgYE46ugx3230302.shtml\\\" target=\\\"_blank\\\">央视网</a></span> <hr> <!-- 正文 --> <!-- 视频 --> <video src=\\\"video/1.mp4\\\" controls width=\\\"950px\\\"></video> <!-- 音频 --> <!-- <audio src=\\\"audio/1.mp3\\\" controls></audio> --> <p> <strong>央视网消息</strong> （焦点访谈）：党的十八大以来，以习近平同志为核心的党中央始终把解决粮食安全问题作为治国理政的头等大事，重农抓粮一系列政策举措有力有效，我国粮食产量站稳1.3万亿斤台阶，实现谷物基本自给、口粮绝对安全。我们把饭碗牢牢端在自己手中，为保障经济社会发展提供了坚实支撑，为应对各种风险挑战赢得了主动。连续八年1.3万亿斤，这个沉甸甸的数据是如何取得的呢？ </p> <p> 人勤春来早，春耕农事忙。立春之后，由南到北，我国春耕春管工作陆续展开，春天的田野处处生机盎然。 </p> <img src=\\\"img/1.jpg\\\"> <p> 今年，我国启动了新一轮千亿斤粮食产能提升行动，这是一个新的起点。2015年以来，我国粮食产量连续8年稳定在1.3万亿斤以上，人均粮食占有量始终稳稳高于国际公认的400公斤粮食安全线。从十年前的约12200亿斤到2022年的约13700亿斤，粮食产量提高了1500亿斤。 </p> <img src=\\\"img/2.jpg\\\"> <p> 中国式现代化一个重要的中国特色是人口规模巨大的现代化。我们粮食生产的发展，意味着我们要立足国内，解决14亿多人吃饭的问题。仓廪实，天下安。保障粮食安全是一个永恒的课题，任何时候都不能放松。在以习近平同志为核心的党中央坚强领导下，亿万中国人民辛勤耕耘、不懈奋斗，我们就一定能够牢牢守住粮食安全这一“国之大者”，把中国人的饭碗牢牢端在自己手中，夯实中国式现代化基础。 </p> <p id=\\\"plast\\\"> 责任编辑：王树淼 SN242 </p> </div> </body> </html> \",\"浏览器打开此页面，最终效果如下：\",\"image-20230310094732466\"]}]},\"/FrontEnd/HTML/\":{\"title\":\"Introduction to front-end\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"浏览器中对代码进行解析和渲染的部分，称为 浏览器内核\",\"Web标准也称为网页标准，大部分由W3C（ World Wide Web Consortium，万维网联盟）负责制定。\",\"Web由三个组成部分：\",\"HTML：负责网页的结构（页面元素和内容）。\",\"CSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。\",\"JavaScript：负责网页的行为（交互效果）。\",\"image-20230309170412197\"]}]},\"/FrontEnd/HTML/html01.html\":{\"title\":\"什么是HTML ?\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"HyperText Markup Language，超文本标记语言\",\"超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容。\",\"标记语言：由标签构成的语言\",\"HTML标签都是预定义好的。\",\"提示\",\"<h1> 标签展示标题 <a>展示超链接 <img>展示图片 <video>展示视频\",\"HTML代码直接在浏览器中运行，HTML标签由浏览器解析。\"]}]},\"/FrontEnd/HTML/html02.html\":{\"title\":\"HTML标签\",\"contents\":[{\"header\":\"布局标签\",\"slug\":\"布局标签\",\"contents\":[\"实际开发网页中，会大量频繁的使用 div 和 span 这两个没有语义的布局标签。\",\"标签：<div> <span>\",\"div标签：\",\"一行只显示一个（独占一行）\",\"宽度默认是父元素的宽度，高度默认由内容撑开\",\"可以设置宽高（width、height）\",\"span标签：\",\"一行可以显示多个\",\"宽度和高度默认由内容撑开\",\"不可以设置宽高（width、height）\"]},{\"header\":\"段落标签\",\"slug\":\"段落标签\",\"contents\":[\"标签 <br> <p>\",\"<p> 这是一个段落标签 </p>\",\"<br> 这是一个换行标签 </br>\"]},{\"header\":\"超链接\",\"slug\":\"超链接\",\"contents\":[\"标签: <a href=\\\"...\\\" target=\\\"...\\\">央视网</a>\",\"href: 指定资源访问的url\",\"target: 指定在何处打开资源链接 \",\"_self: 默认值，在当前页面打开\",\"_blank: 在空白页面打开\"]},{\"header\":\"视频、音频标签\",\"slug\":\"视频、音频标签\",\"contents\":[\"<video> <audio>\",\"<video>\",\"src: 规定视频的url\",\"controls: 显示播放控件\",\"width: 播放器的宽度\",\"height: 播放器的高度\",\"<audio>\",\"src: 规定音频的url\",\"controls: 显示播放控件\"]},{\"header\":\"文本格式标签\",\"slug\":\"文本格式标签\",\"contents\":[\"效果\",\"标签\",\"标签(强调)\",\"加粗\",\"b\",\"strong\",\"倾斜\",\"i\",\"em\",\"下划线\",\"u\",\"ins\",\"删除线\",\"s\",\"del\"]},{\"header\":\"注意事项\",\"slug\":\"注意事项\",\"contents\":[\"在HTML页面中无论输入了多少个空格, 最多只会显示一个。 可以使用空格占位符（ &nbsp; ）来生成空格\",\"在HTML中，除了空格占位符以外，还有一些其他的占位符如下：\",\"显示结果\",\"描述\",\"占位符\",\"空格\",\"&nbsp;\",\"<\",\"小于号\",\"&lt;\",\">\",\"大于号\",\"&gt;\",\"&\",\"和号\",\"&amp;\",\"\\\"\",\"引号\",\"&quot;\",\"'\",\"撇号\",\"&apos;\"]}]},\"/FrontEnd/HTML/html03.html\":{\"title\":\"HTML标签\",\"contents\":[{\"header\":\"表格标签\",\"slug\":\"表格标签\",\"contents\":[\"标签：\",\"<table> : 用于定义整个表格, 可以包裹多个 <tr>， 常用属性如下：\",\"border：规定表格边框的宽度\",\"width：规定表格的宽度\",\"cellspacing: 规定单元之间的空间\",\"<tr> : 表格的行，可以包裹多个 <td>\",\"<td> : 表格单元格(普通)，可以包裹内容 , 如果是表头单元格，可以替换为 <th>\",\"演示：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>HTML-表格</title> <style> td { text-align: center; /* 单元格内容居中展示 */ } </style> </head> <body> <table border=\\\"1px\\\" cellspacing=\\\"0\\\" width=\\\"600px\\\"> <tr> <th>序号</th> <th>品牌Logo</th> <th>品牌名称</th> <th>企业名称</th> </tr> <tr> <td>1</td> <td> <img src=\\\"img/huawei.jpg\\\" width=\\\"100px\\\"> </td> <td>华为</td> <td>华为技术有限公司</td> </tr> <tr> <td>2</td> <td> <img src=\\\"img/alibaba.jpg\\\" width=\\\"100px\\\"> </td> <td>阿里</td> <td>阿里巴巴集团控股有限公司</td> </tr> </table> </body> </html> \",\"image-20230309175121361\"]},{\"header\":\"表单标签\",\"slug\":\"表单标签\",\"contents\":[\"1668055779440\",\"20230309175941128\",\"表单场景: 表单就是在网页中负责数据采集功能的，如：注册、登录的表单。\",\"表单标签: <form>\",\"表单属性:\",\"action: 规定表单提交时，向何处发送表单数据，表单提交的URL。\",\"method: 规定用于发送表单数据的方式，常见为： GET、POST。 \",\"GET：表单数据是拼接在url后面的， 如： xxxxxxxxxxx?username=Tom&age=12，url中能携带的表单数据大小是有限制的。\",\"POST： 表单数据是在请求体（消息体）中携带的，大小没有限制。\",\"表单项标签: 不同类型的input元素、下拉列表、文本域等。\",\"input: 定义表单项，通过type属性控制输入形式\",\"select: 定义下拉列表\",\"textarea: 定义文本域\",\"演示:\",\"GET方式提交的表单\",\"<form action=\\\"\\\" method=\\\"get\\\"> 用户名: <input type=\\\"text\\\" name=\\\"username\\\"> 年龄: <input type=\\\"text\\\" name=\\\"age\\\"> <input type=\\\"submit\\\" value=\\\"提交\\\"> </form> \",\"表单的数据在url后面提交到服务端，格式为：?username=Tom&age=12。\",\"assets/image-20230309191725329.png\",\"POST方式提交表单\",\" <form action=\\\"\\\" method=\\\"post\\\"> 用户名: <input type=\\\"text\\\" name=\\\"username\\\"> 年龄: <input type=\\\"text\\\" name=\\\"age\\\"> <input type=\\\"submit\\\" value=\\\"提交\\\"> </form> \",\"image-20230309192625939\",\"注意事项:\",\"表单中的所有表单项，要想能够正常的采集数据，在提交的时候能提交到服务端，表单项必须指定name属性。 否则，无法提交该表单项。\",\"用户名: <input type=\\\"text\\\" name=\\\"username\\\"> \"]},{\"header\":\"表单项\",\"slug\":\"表单项\",\"contents\":[\"在一个表单中，可以存在很多的表单项，而虽然表单项的形式各式各样，但是表单项的标签其实就只有三个，分别是：\",\"<input>: 表单项 , 通过type属性控制输入形式。\",\"type取值\",\"描述\",\"text\",\"默认值，定义单行的输入字段\",\"password\",\"定义密码字段\",\"radio\",\"定义单选按钮\",\"checkbox\",\"定义复选框\",\"file\",\"定义文件上传按钮\",\"date/time/datetime-local\",\"定义日期/时间/日期时间\",\"number\",\"定义数字输入框\",\"email\",\"定义邮件输入框\",\"hidden\",\"定义隐藏域\",\"submit / reset / button\",\"定义提交按钮 / 重置按钮 / 可点击按钮\",\"<select>: 定义下拉列表, <option> 定义列表项\",\"<textarea>: 文本域\",\"演示\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>HTML-表单项标签</title> </head> <body> <!-- value: 表单项提交的值 --> <form action=\\\"\\\" method=\\\"post\\\"> 姓名: <input type=\\\"text\\\" name=\\\"name\\\"> <br><br> 密码: <input type=\\\"password\\\" name=\\\"password\\\"> <br><br> 性别: <input type=\\\"radio\\\" name=\\\"gender\\\" value=\\\"1\\\"> 男 <label><input type=\\\"radio\\\" name=\\\"gender\\\" value=\\\"2\\\"> 女 </label> <br><br> 爱好: <label><input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"java\\\"> java </label> <label><input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"game\\\"> game </label> <label><input type=\\\"checkbox\\\" name=\\\"hobby\\\" value=\\\"sing\\\"> sing </label> <br><br> 图像: <input type=\\\"file\\\" name=\\\"image\\\"> <br><br> 生日: <input type=\\\"date\\\" name=\\\"birthday\\\"> <br><br> 时间: <input type=\\\"time\\\" name=\\\"time\\\"> <br><br> 日期时间: <input type=\\\"datetime-local\\\" name=\\\"datetime\\\"> <br><br> 邮箱: <input type=\\\"email\\\" name=\\\"email\\\"> <br><br> 年龄: <input type=\\\"number\\\" name=\\\"age\\\"> <br><br> 学历: <select name=\\\"degree\\\"> <option value=\\\"\\\">----------- 请选择 -----------</option> <option value=\\\"1\\\">大专</option> <option value=\\\"2\\\">本科</option> <option value=\\\"3\\\">硕士</option> <option value=\\\"4\\\">博士</option> </select> <br><br> 描述: <textarea name=\\\"description\\\" cols=\\\"30\\\" rows=\\\"10\\\"></textarea> <br><br> <input type=\\\"hidden\\\" name=\\\"id\\\" value=\\\"1\\\"> <!-- 表单常见按钮 --> <input type=\\\"button\\\" value=\\\"按钮\\\"> <input type=\\\"reset\\\" value=\\\"重置\\\"> <input type=\\\"submit\\\" value=\\\"提交\\\"> <br> </form> </body> </html> \",\"通过浏览器打开上述的表单项html文件，最终展示出的表单信息如下：\",\"image-20230309221308252\",\"而对于input type=\\\"hidden\\\"，是一个隐藏域，在表单中并不会显示出来，但是在提交表单的时候，是会提交到服务端的。\",\"image-20230309221530214\"]}]},\"/FrontEnd/JavaScript/\":{\"title\":\"JavaScript\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"提示\",\"html完成了架子，css做了美化\\n但是网页是死的，我们需要注入灵魂，JavaScript会让我们的页面能够和用户进行交互。\"]}]},\"/FrontEnd/JavaScript/javascript01.html\":{\"title\":\"基础语法\",\"contents\":[{\"header\":\"书写语法\",\"slug\":\"书写语法\",\"contents\":[\"api\",\"描述\",\"window.alert()\",\"警告框\",\"document.write()\",\"在HTML 输出内容\",\"console.log()\",\"写入浏览器控制台\"]},{\"header\":\"变量\",\"slug\":\"变量\",\"contents\":[\"关键字\",\"解释\",\"var\",\"早期 ECMAScript5 中用于变量声明的关键字\",\"let\",\"ECMAScript6 中新增的用于变量声明的关键字，相比较var，let只在代码块内生效\",\"const \",\"声明常量的，常量一旦声明，不能修改\",\"JavaScript 是一门弱类型语言，变量可以存放不同类型的值 。\"]},{\"header\":\"数据类型和运算符\",\"slug\":\"数据类型和运算符\",\"contents\":[\"虽然js是弱数据类型的语言，但是js中也存在数据类型 js中的数据类型分为 ：原始类型 和 引用类型\",\"数据类型\",\"描述\",\"number\",\"数字（整数、小数、NaN(Not a Number)）\",\"string\",\"字符串，单双引皆可\",\"boolean\",\"布尔。true，false\",\"null\",\"对象为空\",\"undefined\",\"当声明的变量未初始化时，该变量的默认值是 undefined\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>JS-数据类型</title> </head> <body> </body> <script> //原始数据类型 alert(typeof 3); //number alert(typeof 3.14); //number alert(typeof \\\"A\\\"); //string alert(typeof 'Hello');//string alert(typeof true); //boolean alert(typeof false);//boolean alert(typeof null); //object var a ; alert(typeof a); //undefined </script> </html> \",\"JavaScript和Java不一致的地方\",\"==：只比较值是否相等，不区分数据类型，哪怕类型不一致，也会自动转换类型进行值得比较\",\"===：不光比较值，还要比较类型，如果类型不一致，直接返回false\",\"0 , null , undefined , \\\"\\\" , NaN 理解成false,反之理解成true。\",\" if(0){ //false alert(\\\"0 转换为false\\\"); } \"]},{\"header\":\"函数\",\"slug\":\"函数\",\"contents\":[\"通过关键字function来定义。\"]},{\"header\":\"第一种定义格式\",\"slug\":\"第一种定义格式\",\"contents\":[\"function 函数名(参数1,参数2..){ 要执行的代码 } \",\"function add(a, b){ return a + b; } \"]},{\"header\":\"第二种定义格式\",\"slug\":\"第二种定义格式\",\"contents\":[\"var functionName = function (参数1,参数2..){ //要执行的代码 } \",\"<script> //定义函数-1 // function add(a,b){ // return a + b; // } //定义函数-2 var add = function(a,b){ return a + b; } var result = add(10,20); alert(result); </script> \",\"在JavaScript中，函数的调用只需要名称正确即可，参数列表不管的。\"]}]},\"/FrontEnd/JavaScript/javascript02.html\":{\"title\":\"基本对象\",\"contents\":[{\"header\":\"Array对象\",\"slug\":\"array对象\",\"contents\":[\"语法格式:\",\"Array对象时用来定义数组的。常用语法格式有如下2种：\",\"<script> //定义数组 var arr = new Array(1,2,3,4); //格式1 var arr = [1,2,3,4]; //格式2 //获取数组中的值，索引从0开始计数 console.log(arr[0]); console.log(arr[1]); </script> \",\"特点：\",\"与java中不一样的是，JavaScript中数组相当于java中的集合，数组的长度是可以变化的。而且JavaScript是弱数据类型的语言，所以数组中可以存储任意数据类型的值。\",\"//特点: 长度可变 类型可变 var arr = [1,2,3,4]; arr[10] = 50; console.log(arr[10]); console.log(arr[9]); console.log(arr[8]); \",\"1668590614787\",\"//特点: 长度可变 类型可变 var arr = [1,2,3,4]; arr[10] = 50; arr[9] = \\\"A\\\"; arr[8] = true; console.log(arr); \",\"1668590895662\",\"属性和方法:\",\"属性\",\"描述\",\"length\",\"设置或返回数组中元素的数量。\",\"方法\",\"描述\",\"forEach()\",\"遍历数组中的每个有值得元素，并调用一次传入的函数\",\"push()\",\"将新元素添加到数组的末尾，并返回新的长度\",\"splice()\",\"从数组中删除元素\",\"forEach()函数\",\"//e是形参，接受的是数组遍历时的值 arr.forEach(function(e){ console.log(e); }) \",\"在ES6中，引入箭头函数的写法，语法类似 java 中 lambda 表达式\",\"arr.forEach((e) => { console.log(e); }) \",\"值得注意的是，没有元素的内容是不会输出的，因为forEach只会遍历有值的元素\",\"1668592407223\",\"push()\",\"向数组的末尾添加元素的，\",\"arr.push(7,8,9); console.log(arr); \",\"1668593799333\",\"splice()\",\"用来删除数组中的元素，有2个参数。\",\"参数1：表示从哪个索引位置删除\",\"参数2：表示删除元素的个数\",\"如下代码表示：从索引2的位置开始删，删除2个元素\",\"arr.splice(2,2); console.log(arr); \",\"1668594075039\"]},{\"header\":\"String对象\",\"slug\":\"string对象\",\"contents\":[\"语法格式:\",\"String对象的创建方式有2种：\",\"<script> //创建字符串对象 //var str = new String(\\\"Hello String\\\"); //方式1 var str = \\\" Hello String \\\"; //方式2 console.log(str); </script> \",\"属性和方法:\",\"属性\",\"描述\",\"length\",\"字符串的长度。\",\"方法\",\"描述\",\"charAt()\",\"返回在指定位置的字符。\",\"indexOf()\",\"检索字符串。\",\"trim()\",\"去除字符串两边的空格\",\"substring()\",\"提取字符串中两个指定的索引号之间的字符。\",\"代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>JS-对象-String</title> </head> <body> </body> <script> //创建字符串对象 //var str = new String(\\\"Hello String\\\"); var str = \\\" Hello String \\\"; console.log(str); //length console.log(str.length); //charAt console.log(str.charAt(4)); //indexOf console.log(str.indexOf(\\\"lo\\\")); //trim var s = str.trim(); console.log(s.length); //substring(start,end) --- 开始索引, 结束索引 (含头不含尾) console.log(s.substring(0,5)); </script> </html> \",\"1668595450181\"]},{\"header\":\"JSON对象\",\"slug\":\"json对象\",\"contents\":[\"自定义对象：\",\"var 对象名 = { 属性名1: 属性值1, 属性名2: 属性值2, 属性名3: 属性值3, 函数名称: function(形参列表){} }; \",\"通过如下语法调用属性：\",\"对象名.属性名 \",\"通过如下语法调用函数：\",\"对象名.函数名() \",\"<script> //自定义对象 var user = { name: \\\"Tom\\\", age: 10, gender: \\\"male\\\", eat: function(){ console.log(\\\"用膳~\\\"); } } console.log(user.name); user.eat(); <script> \",\"JSON对象:\",\"JSON对象：JavaScript Object Notation JavaScript对象标记法，是通过JavaScript标记法书写的文本。其格式如下：\",\"{ \\\"key\\\":value, \\\"key\\\":value, \\\"key\\\":value } \",\"其中，key必须使用引号并且是双引号标记，value可以是任意数据类型。\",\"提示\",\"json这种数据格式的文本应用在企业开发的什么地方呢？\",\"-- 经常用来作为前后台交互的数据载体\",\"json字符串和json对象的转换。\",\"var obj = JSON.parse(jsonstr); alert(obj.name); \",\"1668597489911\",\"通过如下函数将json对象再次转换成json字符串\",\"alert( JSON.stringify(obj) ); \",\"1668597624263\"]}]},\"/FrontEnd/JavaScript/javascript03.html\":{\"title\":\"BOM对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"BOM的全称是 Browser Object Model ，浏览器对象模型。\",\"JavaScript将浏览器的各个组成部分封装成了对象。我们要操作浏览器的部分功能，可以通过操作BOM对象的相关属性或者函数来完成。\",\"BOM中提供了如下5个对象：\",\"对象名称\",\"描述\",\"Window\",\"浏览器窗口对象\",\"Navigator\",\"浏览器对象\",\"Screen\",\"屏幕对象\",\"History\",\"历史记录对象\",\"Location\",\"地址栏对象\",\"20210815194911914\"]},{\"header\":\"Window对象\",\"slug\":\"window对象\",\"contents\":[\"window对象提供了获取其他BOM对象的属性：\",\"属性\",\"描述\",\"history\",\"用于获取history对象\",\"location\",\"用于获取location对象\",\"Navigator\",\"用于获取Navigator对象\",\"Screen\",\"用于获取Screen对象\",\"window也提供了一些常用的函数，如下表格所示：\",\"函数\",\"描述\",\"alert()\",\"显示带有一段消息和一个确认按钮的警告框。\",\"comfirm()\",\"显示带有一段消息以及确认按钮和取消按钮的对话框。\",\"setInterval()\",\"按照指定的周期（以毫秒计）来调用函数或计算表达式。\",\"setTimeout()\",\"在指定的毫秒数后调用函数或计算表达式。\",\"confirm()函数：弹出确认框，并且提供用户2个按钮，分别是确认和取消。\",\"confirm(\\\"您确认删除该记录吗?\\\"); \",\"1668794898891\",\"setInterval(fn, 毫秒值)：定时器，用于周期性的执行某个功能，并且是循环执行。\",\"需要传递2个参数\",\"fn: 函数，需要周期性执行的功能代码\",\"毫秒值：间隔时间\",\"//定时器 -- setInterval -- 周期性的执行某一个函数 var i = 0; setInterval(function(){ i++; console.log(\\\"定时器执行了\\\"+i+\\\"次\\\"); },2000); \",\"1668795435780\",\"setTimeout(fn, 毫秒值) ：定时器，只会在一段时间后执行一次功能。\",\"//定时器 - setTimeout -- 延迟指定时间执行一次 setTimeout(function(){ alert(\\\"JS\\\"); },3000); \"]},{\"header\":\"Location对象\",\"slug\":\"location对象\",\"contents\":[\"location是指代浏览器的地址栏对象 我们常用的是href属性，用于获取或者设置浏览器的地址信息，添加如下代码：\",\"//获取浏览器地址栏信息 alert(location.href); //设置浏览器地址栏信息 location.href = \\\"https://www.itcast.cn\\\"; \",\"1668796236628\"]}]},\"/FrontEnd/JavaScript/javascript04.html\":{\"title\":\"DOM对象\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"DOM对象，JavaScript中将html的每一个标签都封装成一个对象\"]},{\"header\":\"DOM介绍\",\"slug\":\"dom介绍\",\"contents\":[\"DOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。\",\"DOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。\",\"封装的对象分为:\",\"Document：整个文档对象\",\"Element：元素对象\",\"Attribute：属性对象\",\"Text：文本对象\",\"Comment：注释对象\",\"如下图，左边是 HTML 文档内容，右边是 DOM 树\",\"1668796698067\",\"那么我们学习DOM技术有什么用呢？\",\"主要作用如下：\",\"改变 HTML 元素的内容\",\"改变 HTML 元素的样式（CSS）\",\"对 HTML DOM 事件作出反应\",\"添加和删除 HTML 元素\",\"从而达到动态改变页面效果目的\"]},{\"header\":\"获取DOM对象\",\"slug\":\"获取dom对象\",\"contents\":[\"如何获取DOM中的元素对象（Element对象 ，也就是标签）\",\"如何操作Element对象的属性，也就是标签的属性。\",\"HTML中的 Element 对象可以通过 Document 对象获取，而 Document 对象是通过 window 对象获取的。\",\"函数\",\"描述\",\"document.getElementById()\",\"根据id属性值获取，返回单个Element对象\",\"document.getElementsByTagName()\",\"根据标签名称获取，返回Element对象数组\",\"document.getElementsByName()\",\"根据name属性值获取，返回Element对象数组\",\"document.getElementsByClassName()\",\"根据class属性值获取，返回Element对象数组\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>JS-对象-DOM</title> </head> <body> <img id=\\\"h1\\\" src=\\\"img/off.gif\\\"> <br><br> <div class=\\\"cls\\\">传智教育</div> <br> <div class=\\\"cls\\\">黑马程序员</div> <br> <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 电影 <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 旅游 <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 游戏 </body> </html> \",\"document.getElementById()： 根据标签的id属性获取标签对象，id是唯一的，所以获取到是单个标签对象。\",\"<script> //1. 获取Element元素 //1.1 获取元素-根据ID获取 var img = document.getElementById('h1'); alert(img); </script> \",\"document.getElementsByTagName() : 根据标签的名字获取标签对象，同名的标签有很多，所以返回值是数组。\",\"//1.2 获取元素-根据标签获取 - div var divs = document.getElementsByTagName('div'); for (let i = 0; i < divs.length; i++) { alert(divs[i]); } \",\"document.getElementsByName() ：根据标签的name的属性值获取标签对象，name属性值可以重复，所以返回值是一个数组。\",\"//1.3 获取元素-根据name属性获取 var ins = document.getElementsByName('hobby'); for (let i = 0; i < ins.length; i++) { alert(ins[i]); } \",\"浏览器会有3次如下图所示的弹框：\",\"1668799393592\",\"document.getElementsByClassName() : 根据标签的class属性值获取标签对象，class属性值也可以重复，返回值是数组。\",\"//1.4 获取元素-根据class属性获取 var divs = document.getElementsByClassName('cls'); for (let i = 0; i < divs.length; i++) { alert(divs[i]); } \",\"浏览器会弹框2次，都是div标签对象\",\"1668799564602\"]},{\"header\":\"操作属性\",\"slug\":\"操作属性\",\"contents\":[\"那么获取到标签了，我们如何操作标签的属性呢？通过查询文档资料，如下图所示：\",\"1668800047162\",\"得出我们可以通过div标签对象的 innerHTML 属性来修改标签的内容。此时我们想把页面中的传智教育替换成传智教育666，所以要获取2个div中的第一个，所以可以通过下标0获取数组中的第一个div。\",\"var divs = document.getElementsByClassName('cls'); var div1 = divs[0]; div1.innerHTML = \\\"传智教育666\\\"; \"]},{\"header\":\"案例\",\"slug\":\"案例\",\"contents\":[]},{\"header\":\"需求说明\",\"slug\":\"需求说明\",\"contents\":[\"通过案例来加强对于上述DOM知识的掌握。需求如下3个：\",\"点亮灯泡\",\"将所有的div标签的标签体内容后面加上：very good\",\"使所有的复选框呈现被选中的状态\",\"效果如下所示：\",\"1668800646200\"]},{\"header\":\"完整代码\",\"slug\":\"完整代码\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>JS-对象-DOM-案例</title> </head> <body> <img id=\\\"h1\\\" src=\\\"img/off.gif\\\"> <br><br> <div class=\\\"cls\\\">传智教育</div> <br> <div class=\\\"cls\\\">黑马程序员</div> <br> <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 电影 <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 旅游 <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 游戏 </body> <script> //1. 点亮灯泡 : src 属性值 var img = document.getElementById('h1'); img.src = \\\"img/on.gif\\\"; //2. 将所有div标签的内容后面加上: //very good (红色字体) -- <font color='red'></font> var divs = document.getElementsByTagName('div'); for (let i = 0; i < divs.length; i++) { const div = divs[i]; div.innerHTML += \\\"<font color='red'>very good</font>\\\"; } //3. 使所有的复选框呈现选中状态 var ins = document.getElementsByName('hobby'); for (let i = 0; i < ins.length; i++) { const check = ins[i]; check.checked = true;//选中 } </script> </html> \"]}]},\"/FrontEnd/JavaScript/javascript05.html\":{\"title\":\"事件\",\"contents\":[{\"header\":\"事件介绍\",\"slug\":\"事件介绍\",\"contents\":[\"事件绑定\",\"常用事件\"]},{\"header\":\"事件绑定\",\"slug\":\"事件绑定\",\"contents\":[\"JavaScript对于事件的绑定提供了2种方式：\",\"方式1：通过 html标签 中的事件属性进行绑定\",\"例如一个按钮，对于按钮可以绑定单机事件，可以借助标签的onclick属性，属性值指向一个函数。\",\"<input type=\\\"button\\\" id=\\\"btn1\\\" value=\\\"事件绑定1\\\" onclick=\\\"on()\\\"> \",\"<script> function on(){ alert(\\\"按钮1被点击了...\\\"); } </script> \",\"1668804375833\",\"方式2：通过 DOM 中 Element 元素的事件属性进行绑定\",\"html中的标签被加载成element对象，所以我们也可以通过element对象的属性来操作标签的属性。此时我们再次添加一个按钮，代码如下：\",\"<input type=\\\"button\\\" id=\\\"btn2\\\" value=\\\"事件绑定2\\\"> \",\"我们可以先通过id属性获取按钮对象，然后操作对象的onclick属性来绑定事件，代码如下：\",\"document.getElementById('btn2').onclick = function(){ alert(\\\"按钮2被点击了...\\\"); } \",\"1668804696373\",\"需要注意的是：事件绑定的函数，只有在事件被触发时，函数才会被调用。\",\"整体代码如下：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>JS-事件-事件绑定</title> </head> <body> <input type=\\\"button\\\" id=\\\"btn1\\\" value=\\\"事件绑定1\\\" onclick=\\\"on()\\\"> <input type=\\\"button\\\" id=\\\"btn2\\\" value=\\\"事件绑定2\\\"> </body> <script> function on(){ alert(\\\"按钮1被点击了...\\\"); } document.getElementById('btn2').onclick = function(){ alert(\\\"按钮2被点击了...\\\"); } </script> </html> \"]},{\"header\":\"常见事件\",\"slug\":\"常见事件\",\"contents\":[\"事件属性名\",\"说明\",\"onclick\",\"鼠标单击事件\",\"onblur\",\"元素失去焦点\",\"onfocus\",\"元素获得焦点\",\"onload\",\"某个页面或图像被完成加载\",\"onsubmit\",\"当表单提交时触发该事件\",\"onmouseover\",\"鼠标被移到某元素之上\",\"onmouseout\",\"鼠标从某元素移开\"]},{\"header\":\"案例\",\"slug\":\"案例\",\"contents\":[]},{\"header\":\"需求说明\",\"slug\":\"需求说明\",\"contents\":[\"点击 “点亮”按钮 点亮灯泡，点击“熄灭”按钮 熄灭灯泡\",\"输入框鼠标聚焦后，展示小写；鼠标离焦后，展示大写。\",\"点击 “全选”按钮使所有的复选框呈现被选中的状态，点击 “反选”按钮使所有的复选框呈现取消勾选的状态。\",\"1668806049390\"]},{\"header\":\"完整代码\",\"slug\":\"完整代码\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>JS-事件-案例</title> </head> <body> <img id=\\\"light\\\" src=\\\"img/off.gif\\\"> <br> <input type=\\\"button\\\" value=\\\"点亮\\\" onclick=\\\"on()\\\"> <input type=\\\"button\\\" value=\\\"熄灭\\\" onclick=\\\"off()\\\"> <br> <br> <input type=\\\"text\\\" id=\\\"name\\\" value=\\\"ITCAST\\\" onfocus=\\\"lower()\\\" onblur=\\\"upper()\\\"> <br> <br> <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 电影 <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 旅游 <input type=\\\"checkbox\\\" name=\\\"hobby\\\"> 游戏 <br> <input type=\\\"button\\\" value=\\\"全选\\\" onclick=\\\"checkAll()\\\"> <input type=\\\"button\\\" value=\\\"反选\\\" onclick=\\\"reverse()\\\"> </body> <script> //1. 点击 \\\"点亮\\\" 按钮, 点亮灯泡; 点击 \\\"熄灭\\\" 按钮, 熄灭灯泡; -- onclick function on(){ //a. 获取img元素对象 var img = document.getElementById(\\\"light\\\"); //b. 设置src属性 img.src = \\\"img/on.gif\\\"; } function off(){ //a. 获取img元素对象 var img = document.getElementById(\\\"light\\\"); //b. 设置src属性 img.src = \\\"img/off.gif\\\"; } //2. 输入框聚焦后, 展示小写; 输入框离焦后, 展示大写; -- onfocus , onblur function lower(){//小写 //a. 获取输入框元素对象 var input = document.getElementById(\\\"name\\\"); //b. 将值转为小写 input.value = input.value.toLowerCase(); } function upper(){//大写 //a. 获取输入框元素对象 var input = document.getElementById(\\\"name\\\"); //b. 将值转为大写 input.value = input.value.toUpperCase(); } //3. 点击 \\\"全选\\\" 按钮使所有的复选框呈现选中状态 ; // 点击 \\\"反选\\\" 按钮使所有的复选框呈现取消勾选的状态 ; -- onclick function checkAll(){ //a. 获取所有复选框元素对象 var hobbys = document.getElementsByName(\\\"hobby\\\"); //b. 设置选中状态 for (let i = 0; i < hobbys.length; i++) { const element = hobbys[i]; element.checked = true; } } function reverse(){ //a. 获取所有复选框元素对象 var hobbys = document.getElementsByName(\\\"hobby\\\"); //b. 设置未选中状态 for (let i = 0; i < hobbys.length; i++) { const element = hobbys[i]; element.checked = false; } } </script> </html> \"]}]},\"/FrontEnd/Vue/\":{\"title\":\"Vue概述\",\"contents\":[{\"header\":\"MVVM模式\",\"slug\":\"mvvm模式\",\"contents\":[\"MVVM: Model-View-ViewModel:\",\"Model: 数据模型，指前端通过请求从后台获取的数据\",\"View: 视图，用于展示数据的页面，可以理解成html+css搭建的页面，但没有数据\",\"ViewModel: 数据绑定到视图，负责将数据（Model）通过 JavaScript 的 DOM 技术，将数据展示到视图（View）上\",\"MVVM开发思想的含义：\",\"1668857055058\",\"基于上述的 MVVM 思想\",\"Model部分可以通过Ajax来发起请求从后台获取 View部分，可以通过一款ElementUI框架来替代HTML+CSS来更加方便的搭建View ViewModel部分， vue 前端框架，用来替代JavaScript的DOM操作，让数据展示到视图的代码开发变得更加的简单\",\"1668858213508\",\"Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。\"]},{\"header\":\"示例\",\"slug\":\"示例\",\"contents\":[\"<script>标签引入vue.js文件\",\"<script src=\\\"js/vue.js\\\"></script> \",\"在js代码区域定义vue对象：\",\"<script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ message: \\\"Hello Vue\\\" } }) </script> \",\"创建vue对象时，几个常用的属性：\",\"el: 用来指定哪些标签受 Vue 管理。 该属性取值 #app 中的 app 是受管理的标签的id属性值\",\"data: 用来定义数据模型\",\"methods: 用来定义函数。\",\"在html区域编写视图，其中{{}}是插值表达式，用来将vue对象中定义的model展示到页面上的\",\"<body> <div id=\\\"app\\\"> <input type=\\\"text\\\" v-model=\\\"message\\\"> {{message}} </div> </body> \",\"1668859214102\",\"整体代码如下：\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-快速入门</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <input type=\\\"text\\\" v-model=\\\"message\\\"> {{message}} </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ message: \\\"Hello Vue\\\" } }) </script> </html> \"]}]},\"/FrontEnd/Vue/vue01.html\":{\"title\":\"Vue指令\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"指令： HTML 标签上带有 v- 前缀的特殊属性，不同指令具有不同含义。\",\"指令\",\"作用\",\"v-bind\",\"为HTML标签绑定属性值，如设置 href , css样式等\",\"v-model\",\"在表单元素上创建双向数据绑定\",\"v-on\",\"为HTML标签绑定事件\",\"v-if\",\"条件性的渲染某元素，判定为true时渲染,否则不渲染\",\"v-else\",\"v-else-if\",\"v-show\",\"根据条件展示某元素，区别在于切换的是display属性的值\",\"v-for\",\"列表渲染，遍历容器的元素或者对象的属性\"]},{\"header\":\"v-bind和v-model\",\"slug\":\"v-bind和v-model\",\"contents\":[\"指令\",\"作用\",\"v-bind\",\"为HTML标签绑定属性值，如设置 href , css样式等\",\"v-model\",\"在表单元素上创建双向数据绑定\"]},{\"header\":\"v-bind\",\"slug\":\"v-bind\",\"contents\":[\"为 HTML 标签绑定属性值，如设置 href , css 样式等。 当 vue 对象中的数据模型发生变化时，标签的属性值会随之发生变化。\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-v-bind</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <a >链接1</a> <a >链接2</a> <input type=\\\"text\\\" > </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ url: \\\"https://www.baidu.com\\\" } }) </script> </html> \",\"<a v-bind:href=\\\"url\\\">链接1</a> \",\"v-bind指令可省略，但是 : 不能省略\",\"<a :href=\\\"url\\\">链接2</a> \",\"1668860425429\"]},{\"header\":\"v-model\",\"slug\":\"v-model\",\"contents\":[\"在表单元素上创建双向数据绑定。什么是双向？\",\"vue 对象的 data 属性中的数据变化，视图展示会一起变化\",\"视图数据发生变化，vue对象的 data 属性中的数据也会随着变化。\",\"只有表单项标签！所以双向绑定一定是使在表单项标签上的。\",\"<input type=\\\"text\\\" v-model=\\\"url\\\"> \",\"1668861009068\",\"双向绑定的作用：可以获取表单的数据的值，然后提交给服务器\",\"完整代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-v-bind</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <a v-bind:href=\\\"url\\\">链接1</a> <a :href=\\\"url\\\">链接2</a> <input type=\\\"text\\\" v-model=\\\"url\\\"> </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ url: \\\"https://www.baidu.com\\\" } }) </script> </html> \"]},{\"header\":\"v-on\",\"slug\":\"v-on\",\"contents\":[\"v-on: 用来给html标签绑定事件的。需要注意的是如下2点：\",\"v-on 语法给标签的事件绑定的函数，必须是 vue 对象中声明的函数\",\"v-on 语法绑定事件时，事件名相比较 js 中的事件名，没有 on\",\"js 中，事件绑定demo函数\",\"<input onclick=\\\"demo()\\\"> \",\"vue 中，事件绑定demo函数\",\"<input v-on:click=\\\"demo()\\\"> \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-v-on</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <input type=\\\"button\\\" value=\\\"点我一下\\\"> <input type=\\\"button\\\" value=\\\"点我一下\\\"> </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ }, methods: { } }) </script> </html> \",\" methods: { handle: function(){ alert(\\\"你点我了一下...\\\"); } } \",\"给第一个按钮，通过v-on指令绑定单击事件，代码如下：\",\" <input type=\\\"button\\\" value=\\\"点我一下\\\" v-on:click=\\\"handle()\\\"> \",\"v-on也存在简写方式，即 v-on: 可以替换成 @\",\"<input type=\\\"button\\\" value=\\\"点我一下\\\" @click=\\\"handle()\\\"> \",\"完整代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-v-on</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <input type=\\\"button\\\" value=\\\"点我一下\\\" v-on:click=\\\"handle()\\\"> <input type=\\\"button\\\" value=\\\"点我一下\\\" @click=\\\"handle()\\\"> </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ }, methods: { handle: function(){ alert(\\\"你点我了一下...\\\"); } } }) </script> </html> \"]},{\"header\":\"v-if和v-show\",\"slug\":\"v-if和v-show\",\"contents\":[\"指令\",\"描述\",\"v-if\",\"条件性的渲染某元素，判定为true时渲染,否则不渲染\",\"v-if-else\",\"v-else\",\"v-show\",\"根据条件展示某元素，区别在于切换的是display属性的值\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-v-if与v-show</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> 年龄<input type=\\\"text\\\" v-model=\\\"age\\\">经判定,为: <span>年轻人(35及以下)</span> <span>中年人(35-60)</span> <span>老年人(60及以上)</span> </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ age: 20 }, methods: { } }) </script> </html> \",\"年龄<input type=\\\"text\\\" v-model=\\\"age\\\">经判定,为: <span v-if=\\\"age <= 35\\\">年轻人(35及以下)</span> <span v-else-if=\\\"age > 35 && age < 60\\\">中年人(35-60)</span> <span v-else>老年人(60及以上)</span> \",\"1668864281939\",\"v-show和v-if的作用效果是一样的，只是原理不一样。\",\"年龄<input type=\\\"text\\\" v-model=\\\"age\\\">经判定,为: <span v-show=\\\"age <= 35\\\">年轻人(35及以下)</span> <span v-show=\\\"age > 35 && age < 60\\\">中年人(35-60)</span> <span v-show=\\\"age >= 60\\\">老年人(60及以上)</span> \",\"1668864558419\",\"完整代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-v-if与v-show</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> 年龄<input type=\\\"text\\\" v-model=\\\"age\\\">经判定,为: <span v-if=\\\"age <= 35\\\">年轻人(35及以下)</span> <span v-else-if=\\\"age > 35 && age < 60\\\">中年人(35-60)</span> <span v-else>老年人(60及以上)</span> <br><br> 年龄<input type=\\\"text\\\" v-model=\\\"age\\\">经判定,为: <span v-show=\\\"age <= 35\\\">年轻人(35及以下)</span> <span v-show=\\\"age > 35 && age < 60\\\">中年人(35-60)</span> <span v-show=\\\"age >= 60\\\">老年人(60及以上)</span> </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ age: 20 }, methods: { } }) </script> </html> \"]},{\"header\":\"v-for\",\"slug\":\"v-for\",\"contents\":[\"<标签 v-for=\\\"变量名 in 集合模型数据\\\"> {{变量名}} </标签> \",\"值得注意的是：需要循环那个标签，v-for 指令就写在那个标签上。\",\"有时我们遍历时需要使用索引，那么 v-for 指令遍历的语法格式如下：\",\"<标签 v-for=\\\"(变量名,索引变量) in 集合模型数据\\\"> <!--索引变量是从0开始，所以要表示序号的话，需要手动的加1--> {{索引变量 + 1}} {{变量名}} </标签> \",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-v-for</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ addrs:[\\\"北京\\\", \\\"上海\\\", \\\"西安\\\", \\\"成都\\\", \\\"深圳\\\"] }, methods: { } }) </script> </html> \",\" <div id=\\\"app\\\"> <div v-for=\\\"addr in addrs\\\">{{addr}}</div> <hr> <div v-for=\\\"(addr,index) in addrs\\\">{{index + 1}} : {{addr}}</div> </div> \",\"1668866805981\"]},{\"header\":\"综合案例\",\"slug\":\"综合案例\",\"contents\":[\"需求：\",\"1668868100828\",\"将数据以表格的形式，展示到页面上，其中，性别需要转换成中文男女，等级需要将分数数值转换成对应的等级。\",\"分析：\",\"首先我们肯定需要遍历数组的，所以需要使用v-for标签\",\"然后我们每一条数据对应一行，所以v-for需要添加在 tr 标签上\",\"其次我们需要将编号，所以需要使用索引的遍历语法\",\"然后我们要将数据展示到表格的单元格中，所以我们需要使用{{}}插值表达式 \",\"最后，我们需要转换内容，所以我们需要使用v-if指令，进行条件判断和内容的转换\",\"步骤：\",\"使用v-for的带索引方式添加到表格的<tr>标签上\",\"使用{{ }}插值表达式展示内容到单元格\",\"使用索引+1来作为编号\",\"使用v-if来判断，改变性别和等级这俩列的值\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-案例</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <table border=\\\"1\\\" cellspacing=\\\"0\\\" width=\\\"60%\\\"> <tr> <th>编号</th> <th>姓名</th> <th>年龄</th> <th>性别</th> <th>成绩</th> <th>等级</th> </tr> </table> </div> </body> <script> new Vue({ el: \\\"#app\\\", data: { users: [{ name: \\\"Tom\\\", age: 20, gender: 1, score: 78 },{ name: \\\"Rose\\\", age: 18, gender: 2, score: 86 },{ name: \\\"Jerry\\\", age: 26, gender: 1, score: 90 },{ name: \\\"Tony\\\", age: 30, gender: 1, score: 52 }] }, methods: { }, }) </script> </html> \",\"然后在<tr>上添加 v-for 进行遍历，以及通过 插值表达式{{ }} 和 v-if 指令来填充内容和改变内容，其代码如下：\",\" <tr align=\\\"center\\\" v-for=\\\"(user,index) in users\\\"> <td>{{index + 1}}</td> <td>{{user.name}}</td> <td>{{user.age}}</td> <td> <span v-if=\\\"user.gender == 1\\\">男</span> <span v-if=\\\"user.gender == 2\\\">女</span> </td> <td>{{user.score}}</td> <td> <span v-if=\\\"user.score >= 85\\\">优秀</span> <span v-else-if=\\\"user.score >= 60\\\">及格</span> <span style=\\\"color: red;\\\" v-else>不及格</span> </td> </tr> \",\"完整代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-案例</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <table border=\\\"1\\\" cellspacing=\\\"0\\\" width=\\\"60%\\\"> <tr> <th>编号</th> <th>姓名</th> <th>年龄</th> <th>性别</th> <th>成绩</th> <th>等级</th> </tr> <tr align=\\\"center\\\" v-for=\\\"(user,index) in users\\\"> <td>{{index + 1}}</td> <td>{{user.name}}</td> <td>{{user.age}}</td> <td> <span v-if=\\\"user.gender == 1\\\">男</span> <span v-if=\\\"user.gender == 2\\\">女</span> </td> <td>{{user.score}}</td> <td> <span v-if=\\\"user.score >= 85\\\">优秀</span> <span v-else-if=\\\"user.score >= 60\\\">及格</span> <span style=\\\"color: red;\\\" v-else>不及格</span> </td> </tr> </table> </div> </body> <script> new Vue({ el: \\\"#app\\\", data: { users: [{ name: \\\"Tom\\\", age: 20, gender: 1, score: 78 },{ name: \\\"Rose\\\", age: 18, gender: 2, score: 86 },{ name: \\\"Jerry\\\", age: 26, gender: 1, score: 90 },{ name: \\\"Tony\\\", age: 30, gender: 1, score: 52 }] }, methods: { }, }) </script> </html> \"]}]},\"/FrontEnd/Vue/vue02.html\":{\"title\":\"Vue生命周期\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"指的是vue对象从创建到销毁的过程\",\"vue的生命周期包含 8 个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法，这些生命周期方法也被称为钩子方法。\",\"状态\",\"阶段周期\",\"beforeCreate\",\"创建前\",\"created\",\"创建后\",\"beforeMount\",\"挂载前\",\"mounted\",\"挂载完成\",\"beforeUpdate\",\"更新前\",\"updated\",\"更新后\",\"beforeDestroy\",\"销毁前\",\"destroyed\",\"销毁后\",\"下图是 Vue 官网提供的从创建 Vue 到效果 Vue 对象的整个过程及各个阶段对应的钩子函数：\",\"1668867134683\",\"mounted：挂载完成，Vue初始化成功，HTML页面渲染成功。以后我们一般用于页面初始化自动的ajax请求后台数据\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Vue-指令-v-for</title> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> </div> </body> <script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ }, methods: { } }) </script> </html> \",\"编写mounted声明周期的钩子函数，与methods同级\",\"<script> //定义Vue对象 new Vue({ el: \\\"#app\\\", //vue接管区域 data:{ }, methods: { }, mounted () { alert(\\\"vue挂载完成,发送请求到服务端\\\") } }) </script> \",\"1668867458156\"]}]},\"/FrontEnd/Vue/vue03.html\":{\"title\":\"AJAX\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Ajax: Asynchronous JavaScript And XML，异步的 JavaScript 和 XML 。\",\"其作用有如下2点：\",\"与服务器进行数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。\",\"异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用的校验等等。\"]},{\"header\":\"同步异步\",\"slug\":\"同步异步\",\"contents\":[\"Ajax 的局部刷新功能是是异步的，与之对应的有同步请求。\",\"同步请求：\",\"1669105385944\",\"浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。\",\"异步请求：\",\"1669105479350\",\"浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。\"]},{\"header\":\"原生Ajax\",\"slug\":\"原生ajax\",\"contents\":[\"Ajax请求是基于客户端发送请求，服务器响应数据的技术。\",\"服务器端: 后台服务器地址\",\"1669105963948\",\"客户端:\",\"第一步：按钮绑定单击事件，点击按钮，发送ajax请求\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>原生Ajax</title> </head> <body> <input type=\\\"button\\\" value=\\\"获取数据\\\" onclick=\\\"getData()\\\"> <div id=\\\"div1\\\"></div> </body> <script> function getData(){ } </script> </html> \",\"第二步：创建 XMLHttpRequest 对象，用于和服务器交换数据，也是原生Ajax请求的核心对象\",\"//1. 创建XMLHttpRequest var xmlHttpRequest = new XMLHttpRequest(); \",\"第三步：调用对象的 open() 方法设置请求的参数信息，例如请求地址，请求方式。然后调用 send() 方法向服务器发送请求\",\"//2. 发送异步请求 xmlHttpRequest.open('GET','http://yapi.smart-xwork.cn/mock/169327/emp/list'); xmlHttpRequest.send();//发送请求 \",\"第四步：通过绑定事件的方式，来获取服务器响应的数据。\",\"//3. 获取服务响应数据 xmlHttpRequest.onreadystatechange = function(){ //此处判断 4表示浏览器已经完全接受到Ajax请求得到的响应， 200表示这是一个正确的Http请求，没有错误 if(xmlHttpRequest.readyState == 4 && xmlHttpRequest.status == 200){ document.getElementById('div1').innerHTML = xmlHttpRequest.responseText; } } \",\"1669106705778\",\"并且通过浏览器的F12抓包，点击网络中的 XHR 请求，可以抓包到我们发送的 Ajax 请求。 XHR 代表的就是异步请求\"]},{\"header\":\"Axios\",\"slug\":\"axios\",\"contents\":[\"Axios是对原生的 AJAX 进行封装，简化书写。\"]},{\"header\":\"Axios的基本使用\",\"slug\":\"axios的基本使用\",\"contents\":[\"Axios的使用比较简单，主要分为2步：\",\"引入Axios文件\",\"<script src=\\\"js/axios-0.18.0.js\\\"></script> \",\"使用Axios发送请求，并获取响应结果\",\"发送 get 请求\",\"axios({ method:\\\"get\\\", url:\\\"http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan\\\" }).then(function (resp){ alert(resp.data); }) \",\"发送 post 请求\",\"axios({ method:\\\"post\\\", url:\\\"http://localhost:8080/ajax-demo1/aJAXDemo1\\\", data:\\\"username=zhangsan\\\" }).then(function (resp){ alert(resp.data); }); \",\"axios()是用来发送异步请求的，小括号中使用 js 的JSON对象传递请求相关的参数：\",\"method属性：用来设置请求方式的。取值为 get 或者 post。\",\"url属性：用来书写请求的资源路径。\",\"data属性：作为请求体被发送的数据。如果是 post 请求的话，数据需要作为 data 属性的值。\",\"then() 需要传递一个匿名函数。我们将 then()中传递的匿名函数称为 回调函数，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。该回调函数中的 resp 参数是对响应的数据进行封装的对象，通过 resp.data 可以获取到响应的数据。\"]},{\"header\":\"Axios快速入门\",\"slug\":\"axios快速入门\",\"contents\":[\"后端实现\",\"查询所有员工：http://yapi.smart-xwork.cn/mock/169327/emp/list\",\"根据员工id删除员工：http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\",\"前端实现\",\"在html中引入axios所依赖的js文件，并且提供2个按钮，绑定单击事件，分别用于点击时发送ajax请求\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Ajax-Axios</title> <script src=\\\"js/axios-0.18.0.js\\\"></script> </head> <body> <input type=\\\"button\\\" value=\\\"获取数据GET\\\" onclick=\\\"get()\\\"> <input type=\\\"button\\\" value=\\\"删除数据POST\\\" onclick=\\\"post()\\\"> </body> <script> function get(){ //通过axios发送异步请求-get } function post(){ //通过axios发送异步请求-post } </script> </html> \",\"get请求代码如下：\",\"//通过axios发送异步请求-get axios({ method: \\\"get\\\", url: \\\"http://yapi.smart-xwork.cn/mock/169327/emp/list\\\" }).then(result => { console.log(result.data); }) \",\"post请求代码如下：\",\"//通过axios发送异步请求-post axios({ method: \\\"post\\\", url: \\\"http://yapi.smart-xwork.cn/mock/169327/empdeleteById\\\", data: \\\"id=1\\\" }).then(result => { console.log(result.data); }) \",\"浏览器打开，f12抓包，然后分别点击2个按钮，查看控制台效果如下：\",\"1669109382408\",\"完整代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Ajax-Axios</title> <script src=\\\"js/axios-0.18.0.js\\\"></script> </head> <body> <input type=\\\"button\\\" value=\\\"获取数据GET\\\" onclick=\\\"get()\\\"> <input type=\\\"button\\\" value=\\\"删除数据POST\\\" onclick=\\\"post()\\\"> </body> <script> function get(){ //通过axios发送异步请求-get axios({ method: \\\"get\\\", url: \\\"http://yapi.smart-xwork.cn/mock/169327/emp/list\\\" }).then(result => { console.log(result.data); }) } function post(){ // 通过axios发送异步请求-post axios({ method: \\\"post\\\", url: \\\"http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\\\", data: \\\"id=1\\\" }).then(result => { console.log(result.data); }) } </script> </html> \"]},{\"header\":\"请求方法的别名\",\"slug\":\"请求方法的别名\",\"contents\":[\"Axios还针对不同的请求，提供了别名方式的api\",\"方法\",\"描述\",\"axios.get(url [, config])\",\"发送get请求\",\"axios.delete(url [, config])\",\"发送delete请求\",\"axios.post(url [, data[, config]])\",\"发送post请求\",\"axios.put(url [, data[, config]])\",\"发送put请求\",\"get请求改写成如下：\",\"axios.get(\\\"http://yapi.smart-xwork.cn/mock/169327/emp/list\\\").then(result => { console.log(result.data); }) \",\"post请求改写成如下：\",\"axios.post(\\\"http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\\\",\\\"id=1\\\").then(result => { console.log(result.data); }) \"]},{\"header\":\"案例\",\"slug\":\"案例\",\"contents\":[\"需求：基于 Vue 及 Axios 完成数据的动态加载展示\",\"1669139756551\",\"数据地址是：http://yapi.smart-xwork.cn/mock/169327/emp/list\",\"步骤：\",\"首先创建文件，提前准备基础代码，包括表格以及vue.js, axios.js文件的引入\",\"需要在vue的mounted钩子函数中发送ajax请求，获取数据\",\"拿到数据，数据需要绑定给vue的 data 属性\",\"在 <tr> 标签上通过 v-for 指令遍历数据，展示数据\",\"代码实现：\",\"首先创建文件，提前准备基础代码，包括表格以及vue.js和axios.js文件的引入\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Ajax-Axios-案例</title> <script src=\\\"js/axios-0.18.0.js\\\"></script> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <table border=\\\"1\\\" cellspacing=\\\"0\\\" width=\\\"60%\\\"> <tr> <th>编号</th> <th>姓名</th> <th>图像</th> <th>性别</th> <th>职位</th> <th>入职日期</th> <th>最后操作时间</th> </tr> <tr align=\\\"center\\\" > <td>1</td> <td>Tom</td> <td> <img src=\\\"\\\" width=\\\"70px\\\" height=\\\"50px\\\"> </td> <td> <span>男</span> <!-- <span>女</span>--> </td> <td>班主任</td> <td>2009-08-09</td> <td>2009-08-09 12:00:00</td> </tr> </table> </div> </body> <script> new Vue({ el: \\\"#app\\\", data: { } }); </script> </html> \",\"在 vue 的 mounted 钩子函数，编写Ajax请求，请求数据\",\"mounted () { //发送异步请求,加载数据 axios.get(\\\"http://yapi.smart-xwork.cn/mock/169327/emp/list\\\").then(result => { }) } \",\"ajax 请求的数据绑定给 vue 的 data 属性，之后才能进行数据绑定到视图；并且浏览器打开后台地址，数据返回格式：\",\"1669141982809\",\"服务器响应的json中的data属性才是我们需要展示的信息，所以我们应该将员工列表信息赋值给vue的data属性，代码如下：\",\" //发送异步请求,加载数据 axios.get(\\\"http://yapi.smart-xwork.cn/mock/169327/emp/list\\\").then(result => { this.emps = result.data.data; }) \",\"其中，data中emps变量\",\"data: { emps:[] }, \",\"在<tr>标签上通过v-for指令遍历数据，展示数据，其中需要注意的是图片的值，需要使用vue的属性绑定，男女的展示需要使用条件判断\",\"<tr align=\\\"center\\\" v-for=\\\"(emp,index) in emps\\\"> <td>{{index + 1}}</td> <td>{{emp.name}}</td> <td> <img :src=\\\"emp.image\\\" width=\\\"70px\\\" height=\\\"50px\\\"> </td> <td> <span v-if=\\\"emp.gender == 1\\\">男</span> <span v-if=\\\"emp.gender == 2\\\">女</span> </td> <td>{{emp.job}}</td> <td>{{emp.entrydate}}</td> <td>{{emp.updatetime}}</td> </tr> \",\"完整代码\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> <title>Ajax-Axios-案例</title> <script src=\\\"js/axios-0.18.0.js\\\"></script> <script src=\\\"js/vue.js\\\"></script> </head> <body> <div id=\\\"app\\\"> <table border=\\\"1\\\" cellspacing=\\\"0\\\" width=\\\"60%\\\"> <tr> <th>编号</th> <th>姓名</th> <th>图像</th> <th>性别</th> <th>职位</th> <th>入职日期</th> <th>最后操作时间</th> </tr> <tr align=\\\"center\\\" v-for=\\\"(emp,index) in emps\\\"> <td>{{index + 1}}</td> <td>{{emp.name}}</td> <td> <img :src=\\\"emp.image\\\" width=\\\"70px\\\" height=\\\"50px\\\"> </td> <td> <span v-if=\\\"emp.gender == 1\\\">男</span> <span v-if=\\\"emp.gender == 2\\\">女</span> </td> <td>{{emp.job}}</td> <td>{{emp.entrydate}}</td> <td>{{emp.updatetime}}</td> </tr> </table> </div> </body> <script> new Vue({ el: \\\"#app\\\", data: { emps:[] }, mounted () { //发送异步请求,加载数据 axios.get(\\\"http://yapi.smart-xwork.cn/mock/169327/emp/list\\\").then(result => { console.log(result.data); this.emps = result.data.data; }) } }); </script> </html> \"]}]},\"/FrontEnd/Vue/vue04.html\":{\"title\":\"Vue-cli脚手架\",\"contents\":[{\"header\":\"前后台分离开发介绍\",\"slug\":\"前后台分离开发介绍\",\"contents\":[\"1669143781533\",\"需求分析：首先我们需要阅读需求文档，分析需求，理解需求。\",\"接口定义：查询接口文档中关于需求的接口的定义，包括地址，参数，响应数据类型等等\",\"前后台并行开发：各自按照接口文档进行开发，实现需求\",\"测试：前后台开发完了，各自按照接口文档进行测试\",\"前后端联调测试：前端工程请求后端工程，测试功能\"]},{\"header\":\"前端工程化介绍\",\"slug\":\"前端工程化介绍\",\"contents\":[\"模块化：将js和css等，做成一个个可复用模块\",\"组件化：将UI组件，css样式，js行为封装成一个个的组件，便于管理\",\"规范化：提供一套标准的规范的目录接口和编码规范，所有开发人员遵循这套规范\",\"自动化：项目的构建，测试，部署全部都是自动完成\"]},{\"header\":\"前端工程化入门\",\"slug\":\"前端工程化入门\",\"contents\":[]},{\"header\":\"1 环境准备\",\"slug\":\"_1-环境准备\",\"contents\":[\"前端工程化是通过vue官方提供的脚手架 Vue-cli 来完成的，用于快速的生成一个Vue的项目模板。\",\"Vue-cli主要提供了如下功能\",\"统一的目录结构 本地调试 热部署 单元测试 集成打包上线\"]},{\"header\":\"2 Vue项目简介\",\"slug\":\"_2-vue项目简介\",\"contents\":[\"Vue-cli提供了如下俩种方式创建vue项目:\",\"命令行：\",\"vue create vue-project01 \",\"图形化界面：\",\"vue ui \",\"1669294586147\"]},{\"header\":\"3 vue项目目录结构介绍\",\"slug\":\"_3-vue项目目录结构介绍\",\"contents\":[\"1669302973198\",\"平时开发代码就是在src目录下\"]},{\"header\":\"4 Vue项目开发流程\",\"slug\":\"_4-vue项目开发流程\",\"contents\":[\"template: 模板部分，主要是HTML代码，用来展示页面主体结构的\",\"script: js代码区域，主要是通过js代码来控制模板的数据来源和行为的\",\"style: css样式部分，主要通过css样式控制模板的页面效果\",\"1669313699186\"]}]},\"/FrontEnd/Vue/vue05.html\":{\"title\":\"Element-UI\",\"contents\":[{\"header\":\"Element介绍\",\"slug\":\"element介绍\",\"contents\":[\"Element-UI就是一款侧重于 V 开发的前端框架，主要用于开发美观的页面。\"]},{\"header\":\"组件属性详解\",\"slug\":\"组件属性详解\",\"contents\":[\"ElementUI是如何将数据模型绑定到视图的呢？主要通过如下几个属性：\",\"data: 定义table组件的数据模型prop: data中定义的具体的数据模型label: 定义列的标题width: 定义列的宽度\",\"1669363098610\",\"PS: Element组件的所有属性都可以在组件页面的最下方找到\"]},{\"header\":\"Pagination分页\",\"slug\":\"pagination分页\",\"contents\":[\"layout: 分页工具条的布局，其具体值包含sizes, prev, pager, next, jumper, ->, total, slot 这些值\",\"total: 数据的总数量\",\" layout=\\\"sizes, prev, pager, next, jumper, total\\\" \",\"1669364533849\"]},{\"header\":\"组件事件详解\",\"slug\":\"组件事件详解\",\"contents\":[\"对于分页组件，除了上述几个属性，还有2个非常重要的事件\",\"size-change ： pageSize 改变时会触发 每页条数\",\"current-change ：currentPage 改变时会触发 当前页\",\"1669364990991\",\"此时Panigation组件的template完整代码如下：\",\"<!-- Pagination分页 --> <el-pagination @size-change=\\\"handleSizeChange\\\" @current-change=\\\"handleCurrentChange\\\" background layout=\\\"sizes,prev, pager, next,jumper,total\\\" :total=\\\"1000\\\"> </el-pagination> \",\"此时Panigation组件的script部分完整代码如下：\",\"<script> export default { methods: { handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } }, data() { return { tableData: [{ date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }, { date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1517 弄' }, { date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1519 弄' }, { date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1516 弄' }] } } } </script> \",\"f12打开开发者控制台，然后切换当前页码和切换每页显示的数量，呈现如下效果：\",\"1669365585379\"]},{\"header\":\"案例\",\"slug\":\"案例\",\"contents\":[]},{\"header\":\"案例需求\",\"slug\":\"案例需求\",\"contents\":[\"制作类似格式的页面\",\"即上面是标题，左侧栏是导航，右侧是数据展示区域\",\"右侧需要展示搜索表单\",\"右侧表格数据是动态展示的，数据来自于后台\",\"1669373639681\",\"数据Mock地址：http://yapi.smart-xwork.cn/mock/169327/emp/list\",\"1669373386131\"]},{\"header\":\"案例分析\",\"slug\":\"案例分析\",\"contents\":[\"先整体，后局部细节。整个页面可以分为3个部分\",\"1669374858620\",\"主要步骤如下：\",\"创建页面，完成页面的整体布局规划\",\"然后分别针对3个部分进行各自组件的具体实现\",\"针对于右侧核心内容展示区域，需要使用异步加载数据，以表格渲染数据\"]},{\"header\":\"代码实现\",\"slug\":\"代码实现\",\"contents\":[]},{\"header\":\"1 环境搭建\",\"slug\":\"_1-环境搭建\",\"contents\":[\"App.vue完整代码如下：\",\"<template> <div id=\\\"app\\\"> <emp-view></emp-view> </div> </template> <script> import EmpView './views/tlias/EmpView.vue' export default { components: {EmpView }, data(){ return { \\\"message\\\":\\\"hello world\\\" } } } </script> <style> </style> \"]},{\"header\":\"2 整体布局\",\"slug\":\"_2-整体布局\",\"contents\":[\"1669376226430\",\"<el-container> <el-header>Header</el-header> <el-container> <el-aside width=\\\"200px\\\">Aside</el-aside> <el-main>Main</el-main> </el-container> </el-container> \",\"1669376527001\",\"<!-- 设置最外层容器高度为700px,在加上一个很细的边框 --> <el-container style=\\\"height: 700px; border: 1px solid #eee\\\"> \"]},{\"header\":\"3 顶部标题\",\"slug\":\"_3-顶部标题\",\"contents\":[\"修改顶部的文本内容，并且提供背景色的css样式：\",\"<el-header style=\\\"font-size:40px;background-color: rgb(238, 241, 246)\\\"> tlias 智能学习辅助系统</el-header> \",\"1669377134623\",\"完整代码\",\"<template> <div> <!-- 设置最外层容器高度为700px,在加上一个很细的边框 --> <el-container style=\\\"height: 700px; border: 1px solid #eee\\\"> <el-header style=\\\"font-size:40px;background-color: rgb(238, 241, 246)\\\">tlias 智能学习辅助系统</el-header> <el-container> <el-aside width=\\\"200px\\\">Aside</el-aside> <el-main>Main</el-main> </el-container> </el-container> </div> </template> <script> export default { } </script> <style> </style> \"]},{\"header\":\"4 左侧导航栏\",\"slug\":\"_4-左侧导航栏\",\"contents\":[\"1669377371518\",\"<el-menu :default-openeds=\\\"['1', '3']\\\"> <el-submenu index=\\\"1\\\"> <template slot=\\\"title\\\"><i class=\\\"el-icon-message\\\"></i>导航一</template> <el-menu-item index=\\\"1-1\\\">选项1</el-menu-item> <el-menu-item index=\\\"1-2\\\">选项2</el-menu-item> </el-submenu> </el-menu> \",\"删减前后对比图：\",\"1669377954508\",\"完整代码\",\"<template> <div> <!-- 设置最外层容器高度为700px,在加上一个很细的边框 --> <el-container style=\\\"height: 700px; border: 1px solid #eee\\\"> <el-header style=\\\"font-size:40px;background-color: rgb(238, 241, 246)\\\">tlias 智能学习辅助系统</el-header> <el-container> <el-aside width=\\\"200px\\\"> <el-menu :default-openeds=\\\"['1', '3']\\\"> <el-submenu index=\\\"1\\\"> <template slot=\\\"title\\\"><i class=\\\"el-icon-message\\\"></i>系统信息管理</template> <el-menu-item index=\\\"1-1\\\">部门管理</el-menu-item> <el-menu-item index=\\\"1-2\\\">员工管理</el-menu-item> </el-submenu> </el-menu> </el-aside> <el-main> </el-main> </el-container> </el-container> </div> </template> <script> export default { } </script> <style> </style> \"]},{\"header\":\"5 右侧核心内容\",\"slug\":\"_5-右侧核心内容\",\"contents\":[\"表格编写:\",\"<el-table :data=\\\"tableData\\\"> <el-table-column prop=\\\"date\\\" label=\\\"日期\\\" width=\\\"140\\\"> </el-table-column> <el-table-column prop=\\\"name\\\" label=\\\"姓名\\\" width=\\\"120\\\"> </el-table-column> <el-table-column prop=\\\"address\\\" label=\\\"地址\\\"> </el-table-column> </el-table> \",\" data() { return { tableData: [ { date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' } ] } \",\"1669378670102\",\"修改表格，添加列，并且修改列名。\",\"<el-table-column prop=\\\"name\\\" label=\\\"姓名\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"image\\\" label=\\\"图像\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"gender\\\" label=\\\"性别\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"job\\\" label=\\\"职位\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"entrydate\\\" label=\\\"入职日期\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"updatetime\\\" label=\\\"最后操作时间\\\" width=\\\"230\\\"></el-table-column> <el-table-column label=\\\"操作\\\" > <el-button type=\\\"primary\\\" size=\\\"mini\\\">编辑</el-button> <el-button type=\\\"danger\\\" size=\\\"mini\\\">删除</el-button> </el-table-column> \",\"prop属性值的内容并不是乱写的，将来是需要绑定后台的数据的\",\"1669379153961\",\"并且data中之前的数据模型就不可用了，所以需要清空数据，设置为空数组\",\" data() { return { tableData: [ ] } } \",\"1669379291238\",\"完整代码\",\"<template> <div> <!-- 设置最外层容器高度为700px,在加上一个很细的边框 --> <el-container style=\\\"height: 700px; border: 1px solid #eee\\\"> <el-header style=\\\"font-size:40px;background-color: rgb(238, 241, 246)\\\">tlias 智能学习辅助系统</el-header> <el-container> <el-aside width=\\\"200px\\\"> <el-menu :default-openeds=\\\"['1', '3']\\\"> <el-submenu index=\\\"1\\\"> <template slot=\\\"title\\\"><i class=\\\"el-icon-message\\\"></i>系统信息管理</template> <el-menu-item index=\\\"1-1\\\">部门管理</el-menu-item> <el-menu-item index=\\\"1-2\\\">员工管理</el-menu-item> </el-submenu> </el-menu> </el-aside> <el-main> <el-table :data=\\\"tableData\\\"> <el-table-column prop=\\\"name\\\" label=\\\"姓名\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"image\\\" label=\\\"图像\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"gender\\\" label=\\\"性别\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"job\\\" label=\\\"职位\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"entrydate\\\" label=\\\"入职日期\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"updatetime\\\" label=\\\"最后操作时间\\\" width=\\\"230\\\"></el-table-column> <el-table-column label=\\\"操作\\\" > <el-button type=\\\"primary\\\" size=\\\"mini\\\">编辑</el-button> <el-button type=\\\"danger\\\" size=\\\"mini\\\">删除</el-button> </el-table-column> </el-table> </el-main> </el-container> </el-container> </div> </template> <script> export default { data() { return { tableData: [ ] } } } </script> <style> </style> \",\"表单编写:\",\"<!-- 表单 --> <el-form :inline=\\\"true\\\" :model=\\\"searchForm\\\" class=\\\"demo-form-inline\\\"> <el-form-item label=\\\"姓名\\\"> <el-input v-model=\\\"searchForm.name\\\" placeholder=\\\"姓名\\\"></el-input> </el-form-item> <el-form-item label=\\\"性别\\\"> <el-select v-model=\\\"searchForm.gender\\\" placeholder=\\\"性别\\\"> <el-option label=\\\"男\\\" value=\\\"1\\\"></el-option> <el-option label=\\\"女\\\" value=\\\"2\\\"></el-option> </el-select> </el-form-item> <el-form-item> <el-button type=\\\"primary\\\" @click=\\\"onSubmit\\\">查询</el-button> </el-form-item> </el-form> \",\"既然表单使用v-model进行数据的双向绑定了，需要在data中定义searchForm的数据模型，代码如下：\",\" data() { return { tableData: [ ], searchForm:{ name:'', gender:'' } } } \",\"而且，表单的提交按钮，绑定了onSubmit函数，所以还需要在methods中定义onSubmit函数\",\" methods:{ onSubmit:function(){ console.log(this.searchForm); } } \",\"1669381520004\",\"参考官方代码，然后在我们之前的表单中添加一个日期表单，具体代码如下：\",\" </el-form-item> <el-form-item label=\\\"入职日期\\\"> <el-date-picker v-model=\\\"searchForm.entrydate\\\" type=\\\"daterange\\\" range-separator=\\\"至\\\" start-placeholder=\\\"开始日期\\\" end-placeholder=\\\"结束日期\\\"> </el-date-picker> </el-form-item> \",\"添加了双向绑定，所以我们需要在data的searchForm中定义出来，需要注意的是这个日期包含2个值，所以我们定义为数组，代码如下：\",\" searchForm:{ name:'', gender:'', entrydate:[] } \",\"此时我们打开浏览器，填写表单，并且点击查询按钮，查看浏览器控制台，可以看到表单的内容，效果如下图所示：\",\"1669382161813\",\"完整代码\",\"<template> <div> <!-- 设置最外层容器高度为700px,在加上一个很细的边框 --> <el-container style=\\\"height: 700px; border: 1px solid #eee\\\"> <el-header style=\\\"font-size:40px;background-color: rgb(238, 241, 246)\\\">tlias 智能学习辅助系统</el-header> <el-container> <el-aside width=\\\"200px\\\"> <el-menu :default-openeds=\\\"['1', '3']\\\"> <el-submenu index=\\\"1\\\"> <template slot=\\\"title\\\"><i class=\\\"el-icon-message\\\"></i>系统信息管理</template> <el-menu-item index=\\\"1-1\\\">部门管理</el-menu-item> <el-menu-item index=\\\"1-2\\\">员工管理</el-menu-item> </el-submenu> </el-menu> </el-aside> <el-main> <!-- 表单 --> <el-form :inline=\\\"true\\\" :model=\\\"searchForm\\\" class=\\\"demo-form-inline\\\"> <el-form-item label=\\\"姓名\\\"> <el-input v-model=\\\"searchForm.name\\\" placeholder=\\\"姓名\\\"></el-input> </el-form-item> <el-form-item label=\\\"性别\\\"> <el-select v-model=\\\"searchForm.gender\\\" placeholder=\\\"性别\\\"> <el-option label=\\\"男\\\" value=\\\"1\\\"></el-option> <el-option label=\\\"女\\\" value=\\\"2\\\"></el-option> </el-select> </el-form-item> <el-form-item label=\\\"入职日期\\\"> <el-date-picker v-model=\\\"searchForm.entrydate\\\" type=\\\"daterange\\\" range-separator=\\\"至\\\" start-placeholder=\\\"开始日期\\\" end-placeholder=\\\"结束日期\\\"> </el-date-picker> </el-form-item> <el-form-item> <el-button type=\\\"primary\\\" @click=\\\"onSubmit\\\">查询</el-button> </el-form-item> </el-form> <!-- 表格 --> <el-table :data=\\\"tableData\\\"> <el-table-column prop=\\\"name\\\" label=\\\"姓名\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"image\\\" label=\\\"图像\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"gender\\\" label=\\\"性别\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"job\\\" label=\\\"职位\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"entrydate\\\" label=\\\"入职日期\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"updatetime\\\" label=\\\"最后操作时间\\\" width=\\\"230\\\"></el-table-column> <el-table-column label=\\\"操作\\\" > <el-button type=\\\"primary\\\" size=\\\"mini\\\">编辑</el-button> <el-button type=\\\"danger\\\" size=\\\"mini\\\">删除</el-button> </el-table-column> </el-table> </el-main> </el-container> </el-container> </div> </template> <script> export default { data() { return { tableData: [ ], searchForm:{ name:'', gender:'', entrydate:[] } } }, methods:{ onSubmit:function(){ console.log(this.searchForm); } } } </script> <style> </style> \",\"分页工具栏:\",\" <!-- Pagination分页 --> <el-pagination @size-change=\\\"handleSizeChange\\\" @current-change=\\\"handleCurrentChange\\\" background layout=\\\"sizes,prev, pager, next,jumpertotal\\\" :total=\\\"1000\\\"> </el-pagination> \",\"同时methods中需要声明2个函数，代码如下：\",\"handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } \",\"1669382952832\",\"完整代码\",\"<template> <div> <!-- 设置最外层容器高度为700px,在加上一个很细的边框 --> <el-container style=\\\"height: 700px; border: 1px solid #eee\\\"> <el-header style=\\\"font-size:40px;background-color: rgb(238, 241, 246)\\\">tlias 智能学习辅助系统</el-header> <el-container> <el-aside width=\\\"200px\\\"> <el-menu :default-openeds=\\\"['1', '3']\\\"> <el-submenu index=\\\"1\\\"> <template slot=\\\"title\\\"><i class=\\\"el-icon-message\\\"></i>系统信息管理</template> <el-menu-item index=\\\"1-1\\\">部门管理</el-menu-item> <el-menu-item index=\\\"1-2\\\">员工管理</el-menu-item> </el-submenu> </el-menu> </el-aside> <el-main> <!-- 表单 --> <el-form :inline=\\\"true\\\" :model=\\\"searchForm\\\" class=\\\"demo-form-inline\\\"> <el-form-item label=\\\"姓名\\\"> <el-input v-model=\\\"searchForm.name\\\" placeholder=\\\"姓名\\\"></el-input> </el-form-item> <el-form-item label=\\\"性别\\\"> <el-select v-model=\\\"searchForm.gender\\\" placeholder=\\\"性别\\\"> <el-option label=\\\"男\\\" value=\\\"1\\\"></el-option> <el-option label=\\\"女\\\" value=\\\"2\\\"></el-option> </el-select> </el-form-item> <el-form-item label=\\\"入职日期\\\"> <el-date-picker v-model=\\\"searchForm.entrydate\\\" type=\\\"daterange\\\" range-separator=\\\"至\\\" start-placeholder=\\\"开始日期\\\" end-placeholder=\\\"结束日期\\\"> </el-date-picker> </el-form-item> <el-form-item> <el-button type=\\\"primary\\\" @click=\\\"onSubmit\\\">查询</el-button> </el-form-item> </el-form> <!-- 表格 --> <el-table :data=\\\"tableData\\\"> <el-table-column prop=\\\"name\\\" label=\\\"姓名\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"image\\\" label=\\\"图像\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"gender\\\" label=\\\"性别\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"job\\\" label=\\\"职位\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"entrydate\\\" label=\\\"入职日期\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"updatetime\\\" label=\\\"最后操作时间\\\" width=\\\"230\\\"></el-table-column> <el-table-column label=\\\"操作\\\" > <el-button type=\\\"primary\\\" size=\\\"mini\\\">编辑</el-button> <el-button type=\\\"danger\\\" size=\\\"mini\\\">删除</el-button> </el-table-column> </el-table> <!-- Pagination分页 --> <el-pagination @size-change=\\\"handleSizeChange\\\" @current-change=\\\"handleCurrentChange\\\" background layout=\\\"sizes,prev, pager, next,jumper,total\\\" :total=\\\"1000\\\"> </el-pagination> </el-main> </el-container> </el-container> </div> </template> <script> export default { data() { return { tableData: [ ], searchForm:{ name:'', gender:'', entrydate:[] } } }, methods:{ onSubmit:function(){ console.log(this.searchForm); }, handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } } } </script> <style> </style> \"]},{\"header\":\"6 异步数据加载\",\"slug\":\"_6-异步数据加载\",\"contents\":[\"数据的mock地址http://yapi.smart-xwork.cn/mock/169327/emp/list\",\"最后要做的就是异步加载数据，需要使用axios发送ajax请求。\",\"在vue项目中，对于axios的使用\",\"安装axios: npm install axios\",\"需要使用axios时，导入axios: import axios 'axios'\",\"1669383450054\",\"然后重启项目，在EmpView.vue组件页面，通过import命令导入axios，代码如下：\",\"import axios 'axios'; \",\"时候发送axios请求呢？页面加载完成，自动加载，mounted钩子函数，并且需要将得到的员工数据要展示到表格，数据需要赋值给数据模型tableData\",\" mounted(){ axios.get(\\\"http://yapi.smart-xwork.cn/mock/169327/emp/list\\\") .then(resp=>{ this.tableData=resp.data.data; //响应数据赋值给数据模型 }); } \",\"1669383786402\",\"很明显，性别和图片的内容显示不正确，需要修复。\",\"性别内容展示修复：\",\"1669384072912\",\"仔细对比效果和功能实现代码，发现其中涉及2个非常重要的点：\",\"<template> : 用于自定义列的内容 \",\"slot-scope: 通过属性的row获取当前行的数据\",\" <el-table-column prop=\\\"gender\\\" label=\\\"性别\\\" width=\\\"140\\\"> <template slot-scope=\\\"scope\\\"> {{scope.row.gender==1?\\\"男\\\":\\\"女\\\"}} </template> </el-table-column> \",\"1669384537662\",\"图片内容展示修复：\",\"图片内容的修复和上述一致，需要借助<template>标签自定义列的内容，直接借助<img>标签即可，并且需要设置图片的宽度和高度\",\"<el-table-column prop=\\\"image\\\" label=\\\"图像\\\" width=\\\"180\\\"> <template slot-scope=\\\"scope\\\"> <img :src=\\\"scope.row.image\\\" width=\\\"100px\\\" height=\\\"70px\\\"> </template> </el-table-column> \",\"1669384726550\",\"完整代码\",\"<template> <div> <!-- 设置最外层容器高度为700px,在加上一个很细的边框 --> <el-container style=\\\"height: 700px; border: 1px solid #eee\\\"> <el-header style=\\\"font-size:40px;background-color: rgb(238, 241, 246)\\\">tlias 智能学习辅助系统</el-header> <el-container> <el-aside width=\\\"230px\\\" style=\\\"border: 1px solid #eee\\\"> <el-menu :default-openeds=\\\"['1', '3']\\\"> <el-submenu index=\\\"1\\\"> <template slot=\\\"title\\\"><i class=\\\"el-icon-message\\\"></i>系统信息管理</template> <el-menu-item index=\\\"1-1\\\">部门管理</el-menu-item> <el-menu-item index=\\\"1-2\\\">员工管理</el-menu-item> </el-submenu> </el-menu> </el-aside> <el-main> <!-- 表单 --> <el-form :inline=\\\"true\\\" :model=\\\"searchForm\\\" class=\\\"demo-form-inline\\\"> <el-form-item label=\\\"姓名\\\"> <el-input v-model=\\\"searchForm.name\\\" placeholder=\\\"姓名\\\"></el-input> </el-form-item> <el-form-item label=\\\"性别\\\"> <el-select v-model=\\\"searchForm.gender\\\" placeholder=\\\"性别\\\"> <el-option label=\\\"男\\\" value=\\\"1\\\"></el-option> <el-option label=\\\"女\\\" value=\\\"2\\\"></el-option> </el-select> </el-form-item> <el-form-item label=\\\"入职日期\\\"> <el-date-picker v-model=\\\"searchForm.entrydate\\\" type=\\\"daterange\\\" range-separator=\\\"至\\\" start-placeholder=\\\"开始日期\\\" end-placeholder=\\\"结束日期\\\"> </el-date-picker> </el-form-item> <el-form-item> <el-button type=\\\"primary\\\" @click=\\\"onSubmit\\\">查询</el-button> </el-form-item> </el-form> <!-- 表格 --> <el-table :data=\\\"tableData\\\"> <el-table-column prop=\\\"name\\\" label=\\\"姓名\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"image\\\" label=\\\"图像\\\" width=\\\"180\\\"> <template slot-scope=\\\"scope\\\"> <img :src=\\\"scope.row.image\\\" width=\\\"100px\\\" height=\\\"70px\\\"> </template> </el-table-column> <el-table-column prop=\\\"gender\\\" label=\\\"性别\\\" width=\\\"140\\\"> <template slot-scope=\\\"scope\\\"> {{scope.row.gender==1?\\\"男\\\":\\\"女\\\"}} </template> </el-table-column> <el-table-column prop=\\\"job\\\" label=\\\"职位\\\" width=\\\"140\\\"></el-table-column> <el-table-column prop=\\\"entrydate\\\" label=\\\"入职日期\\\" width=\\\"180\\\"></el-table-column> <el-table-column prop=\\\"updatetime\\\" label=\\\"最后操作时间\\\" width=\\\"230\\\"></el-table-column> <el-table-column label=\\\"操作\\\" > <el-button type=\\\"primary\\\" size=\\\"mini\\\">编辑</el-button> <el-button type=\\\"danger\\\" size=\\\"mini\\\">删除</el-button> </el-table-column> </el-table> <!-- Pagination分页 --> <el-pagination @size-change=\\\"handleSizeChange\\\" @current-change=\\\"handleCurrentChange\\\" background layout=\\\"sizes,prev, pager, next,jumper,total\\\" :total=\\\"1000\\\"> </el-pagination> </el-main> </el-container> </el-container> </div> </template> <script> import axios 'axios' export default { data() { return { tableData: [ ], searchForm:{ name:'', gender:'', entrydate:[] } } }, methods:{ onSubmit:function(){ console.log(this.searchForm); }, handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } }, mounted(){ axios.get(\\\"http://yapi.smart-xwork.cn/mock/169327/emp/list\\\") .then(resp=>{ this.tableData=resp.data.data; }); } } </script> <style> </style> \"]}]},\"/FrontEnd/Vue/vue06.html\":{\"title\":\"Vue路由\",\"contents\":[{\"header\":\"路由介绍\",\"slug\":\"路由介绍\",\"contents\":[\"此时基于案例中的功能，实现点击侧边栏的部门管理，显示部门管理的信息，点击员工管理，显示员工管理的信息，这就需要vue的路由功能了。\",\"1669385425617\",\"1669385446343\",\"前端路由：URL中的hash(#号之后的内容）与组件之间的对应关系\",\"1669385782145\",\"当我们点击左侧导航栏时，浏览器的地址栏会发生变化，路由自动更新显示与url所对应的vue组件。\",\"vue官方提供了路由插件Vue Router\",\"VueRouter：路由器类，根据路由请求在路由视图中动态渲染选中的组件 <router-link>：请求链接组件，浏览器会解析成<a> <router-view>：动态视图组件，用来渲染展示与路由路径对应的组件\",\"工作原理：\",\"1669386261570\",\"首先VueRouter根据我们配置的url的hash片段和路由的组件关系去维护一张路由表\",\"然后页面提供一个<router-link>组件，用户点击，发出路由请求\",\"接着VueRouter根据路由请求，在路由表中找到对应的vue组件\",\"最后VueRouter会切换<router-view>中的组件，从而进行视图的更新\"]},{\"header\":\"路由入门\",\"slug\":\"路由入门\",\"contents\":[\"npm install vue-router@3.5.1 \",\"在src/router/index.js文件中定义路由表\",\"import Vue 'vue' import VueRouter 'vue-router' Vue.use(VueRouter) const routes = [ { path: '/emp', //地址hash name: 'emp', component: () => import('../views/tlias/EmpView.vue') //对应的vue组件 }, { path: '/dept', name: 'dept', component: () => import('../views/tlias/DeptView.vue') }, // 值得注意的是：默认的路由路径是 / { path: '/', redirect:'/emp' //表示重定向到/emp即可 }, ] const router = new VueRouter({ routes }) export default router \",\"路由基本信息配置好了，路由表已经被加载，此时还缺少2个东西，就是<router-link>和<router-view>，所以我们需要修改2个页面（ EmpView.vue 和 DeptView.vue ）\",\"<el-menu-item index=\\\"1-1\\\"> <router-link to=\\\"/dept\\\">部门管理</router-link> </el-menu-item> <el-menu-item index=\\\"1-2\\\"> <router-link to=\\\"/emp\\\">员工管理</router-link> </el-menu-item> \",\"还需要在内容展示区域即App.vue中定义route-view\",\"<template> <div id=\\\"app\\\"> <!-- {{message}} --> <!-- <element-view></element-view> --> <!-- <emp-view></emp-view> --> <router-view></router-view> </div> </template> <script> // import EmpView './views/tlias/EmpView.vue' // import ElementView './views/Element/ElementView.vue' export default { components: { }, data(){ return { \\\"message\\\":\\\"hello world\\\" } } } </script> <style> </style> \",\"1669388755027\"]}]},\"/FrontEnd/Vue/vue07.html\":{\"title\":\"打包部署\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"如何发布呢？主要分为2步：\",\"前端工程打包\",\"通过nginx服务器发布前端工程\"]},{\"header\":\"前端工程打包\",\"slug\":\"前端工程打包\",\"contents\":[\"然后会在工程目录下生成一个dist目录，用于存放需要发布的前端资源\"]},{\"header\":\"部署前端工程\",\"slug\":\"部署前端工程\",\"contents\":[]},{\"header\":\"nginx介绍\",\"slug\":\"nginx介绍\",\"contents\":[\"Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 其特点是占有内存少，并发能力强，在各大型互联网公司都有非常广泛的使用。\",\"nginx的解压目录以及目录结构说明：\",\"很明显，如果要发布，直接将资源放入到html目录中。\"]},{\"header\":\"部署\",\"slug\":\"部署\",\"contents\":[\"将之前打包的前端工程dist目录下得内容拷贝到nginx的html目录下\",\"nginx.exe文件来启动nginx\",\"nginx服务器的端口号是80，\",\"PS: 如果80端口被占用，可以通过conf/nginx.conf配置文件来修改端口号\"]}]},\"/Others/BroadBand/\":{\"title\":\"宽带\",\"contents\":[{\"header\":\"1. 网线\",\"slug\":\"_1-网线\",\"contents\":[\"CAT.5\",\"CAT.5E\",\"CAT.6\",\"CAT.6A\",\"CAT.7\",\"CAT.8\",\"传输速率\",\"100Mbps\",\"1000Mbps\",\"1Gbps\",\"10Gbps\",\"10Gbps\",\"25/40Gbps\",\"传输频率\",\"100MHz\",\"100MHz\",\"250MHz\",\"500MHz\",\"600MHz\",\"2000MHz\",\"最大距离\",\"100m\",\"100m\",\"100m\",\"100m\",\"100m\",\"30m\",\"线缆类型\",\"非屏蔽\",\"屏蔽/非屏蔽\",\"屏蔽/非屏蔽\",\"屏蔽/非屏蔽\",\"双层屏蔽\",\"双层屏蔽\",\"(1Gbps = 1024Mbps) *Mbps(Million bits per second)，是一种传输速率单位，指每秒传输的位(比特)数量。 1Mbps代表每秒传输1000000位(bit)，即每秒传输的数据量为: 1000000/8 =125000Byte/s = 125Kb/s = 0.125Mb/s Byte代表字节，8个二进制位为一个字节，即1Byte = 8bit Mbps衡量的是单位时间内线路传输的二进制位的数量\",\"Mhz(Mega Hertz)，兆赫，波动频率单位之一 Hz指的是线缆的频率带宽，代表的是单位时间内线路中电信号的震荡次数\",\"非屏蔽（UTP）、单屏蔽（FTP）、双屏蔽（SFTP） 屏蔽线就是在绝缘层内部增加了一层金属屏蔽层\"]},{\"header\":\"1.1 网线分类\",\"slug\":\"_1-1-网线分类\",\"contents\":[\"目前的网线主要分为：五类、超五类、六类、超六类、七类、八类 在普通家用环境下，超五类，六类也可以支持到万兆。级别越高，万兆支持越稳定。\",\"五类网线：网线外侧有CAT.5标记，最高传输频率为 100MHz，传输速率为 100Mbps，适用于百兆以下的网络，但目前已基本不再使用 超五类网线：网线外侧有CAT.5E ( Enhanced ) 标记，最高传输频率为 100MHz，传输速率为 1000Mbps，适用于千兆网络上。 (目前大部分的网线都是超五类的，尤其是家里自用的)\",\"六类网线：网线外侧有CAT.6标记，最高传输频率为 250MHz，传输速率为 1Gbps，适用于千兆网络。 超六类网线：网线外侧有CAT.6A ( Augmented ) 标记，最高传输频率为 500MHz，传输速率为 10Gbps，适用于万兆网络。\",\"七类网线：网线外侧有CAT.7标记，最高传输频率为 600MHz，传输速率为 10Gbps。 八类网线：网线外侧有CAT.8标记，最高传输频率为 2000MHz，传输速率为 25/40Gbps。 (一般为数据中心、高速和宽带密集型应用)\"]},{\"header\":\"1.2 网线品牌\",\"slug\":\"_1-2-网线品牌\",\"contents\":[\"国际知名的综合布线品牌： TP-LINK、泛达、日线、普天、康普、一舟、天诚、罗格朗，爱谱华顿、大唐电信\",\"国内面向消费者的消费级品牌： 山泽、绿联、秋叶原、万级、飞利浦、普网网联\"]}]},\"/Others/Flim/\":{\"title\":\"电影\",\"contents\":[]},\"/Others/Keyborad/\":{\"title\":\"键盘\",\"contents\":[]},\"/Tools/Git/\":{\"title\":\"Git\",\"contents\":[{\"header\":\"Git是什么\",\"slug\":\"git是什么\",\"contents\":[\"Git 是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本\",\"Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件\",\"官网地址为：https://git-scm.com/\"]},{\"header\":\"Git特点\",\"slug\":\"git特点\",\"contents\":[\"优点\",\"适合分布式开发，强调个体\",\"公共服务器压力和数据量都不会太大\",\"速度快、灵活\",\"任意两个开发者之间可以很容易的解决冲突\",\"离线工作\",\"缺点\",\"代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息\",\"权限控制不友好，如果需要对开发者限制各种权限的建议使用SVN\"]}]},\"/Tools/MarkDown/\":{\"title\":\"Markdown速查表\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"背景\",\"Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。它允许人们 “ 使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档 ”\",\"Markdown 教程Markdown 示例Markdown 增强\"]},{\"header\":\"基本语法\",\"slug\":\"基本语法\",\"contents\":[\"这些是 John Gruber 的原始设计文档中列出的元素。所有 Markdown 应用程序都支持这些元素。\",\"元素\",\"Markdown 语法\",\"标题（Heading）\",\"# H1 ## H2 ### H3\",\"粗体（Bold）\",\"**bold text**\",\"斜体（Italic）\",\"*italicized text*\",\"引用块（Blockquote）\",\"> blockquote\",\"有序列表（Ordered List）\",\"1. First item 2. Second item 3. Third item\",\"无序列表（Unordered List）\",\"- First item - Second item - Third item\",\"代码（Code）\",\"`code`\",\"分隔线（Horizontal Rule）\",\"---\",\"链接（Link）\",\"[title](https://www.example.com)\",\"图片（Image）\",\"![alt text](image.jpg)\"]},{\"header\":\"扩展语法\",\"slug\":\"扩展语法\",\"contents\":[\"这些元素通过添加额外的功能扩展了基本语法。但是，并非所有 Markdown 应用程序都支持这些元素。\",\"元素\",\"Markdown 语法\",\"表格（Table）\",\"| Syntax | Description | | ----------- | ----------- | | Header | Title | | Paragraph | Text |\",\"代码块（Fenced Code Block）\",\"``` { \\\"firstName\\\": \\\"John\\\", \\\"lastName\\\": \\\"Smith\\\", \\\"age\\\": 25 } ```\",\"脚注（Footnote）\",\"Here's a sentence with a footnote. [^1] [^1]: This is the footnote.\",\"标题编号（Heading ID）\",\"### My Great Heading {#custom-id}\",\"定义列表（Definition List）\",\"term : definition\",\"删除线（Strikethrough）\",\"~~The world is flat.~~\",\"任务列表（Task List）\",\"- [x] Write the press release - [ ] Update the website  - [ ] Contact the media\"]}]},\"/Tools/MarkDown/markdown01.html\":{\"title\":\"Markdown方言（Vuepress）\",\"contents\":[{\"header\":\"1 提示信息\",\"slug\":\"_1-提示信息\",\"contents\":[\"info\",\"note\",\"tip\",\"warning\",\"danger\",\"details\"]},{\"header\":\"2 Emoji表情\",\"slug\":\"_2-emoji表情\",\"contents\":[\"经典: :wink: :cry: :laughing: :yum: 简写: 8-) :) :* :( :-) :-( ;)s \",\"效果：\",\"😉 😢 😆 😋\\n😎 😃 😗 😦 😃 😦 😉\"]}]},\"/project/reggietakeout/\":{\"title\":\"瑞吉外卖\",\"contents\":[{\"header\":\"项目地址\",\"slug\":\"项目地址\",\"contents\":[\"https://github.com/simeis147/reggie_take_out/tree/main\"]},{\"header\":\"1. 角色分工\",\"slug\":\"_1-角色分工\",\"contents\":[\"岗位/角色\",\"职责/分工\",\"项目经理\",\"对整个项目负责，任务分配、把控进度\",\"产品经理\",\"进行需求调研，输出需求调研文档、产品原型等\",\"UI设计师\",\"根据产品原型输出界面效果图\",\"架构师\",\"项目整体架构设计、技术选型等\",\"开发工程师\",\"功能代码实现\",\"测试工程师\",\"编写测试用例，输出测试报告\",\"运维工程师\",\"软件环境搭建、项目上线\"]},{\"header\":\"2. 瑞吉外卖项目介绍\",\"slug\":\"_2-瑞吉外卖项目介绍\",\"contents\":[]},{\"header\":\"2.1 项目介绍\",\"slug\":\"_2-1-项目介绍\",\"contents\":[\"瑞吉外卖是专为餐饮企业（餐厅、饭店）定制的一款软件产品，包括 系统管理后台 和 移动端应用 两部分\",\"提示\",\"系统管理后台 主要提供给餐饮企业内部员工使用，可以对餐厅的分类、菜品、套餐、订单、员工等进行管理维护\",\"移动端应用 主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等\"]},{\"header\":\"2.2 产品原型\",\"slug\":\"_2-2-产品原型\",\"contents\":[\"一款产品成型之前，由产品经理绘制一个简单的框架，将页面的排版布局展现出来，使产品的初步构思有一个可视化的展示\"]},{\"header\":\"1. 管理端\",\"slug\":\"_1-管理端\",\"contents\":[\"餐饮企业内部员工使用 主要功能有:\",\"模块\",\"描述\",\"登录/退出\",\"内部员工必须登录后，才可以访问系统管理后台\",\"员工管理\",\"管理员可以在系统后台对员工信息进行管理，包含查询、新增、编辑、禁用等功能\",\"分类管理\",\"主要对当前餐厅经营的 菜品分类 或 套餐分类 进行管理维护，包含查询、新增、修改、删除等功能\",\"菜品管理\",\"主要维护各个分类下的菜品信息，包含查询、新增、修改、删除、启售、停售等功能\",\"套餐管理\",\"主要维护当前餐厅中的套餐信息，包含查询、新增、修改、删除、启售、停售等功能\",\"订单明细\",\"主要维护用户在移动端下的订单信息，包含查询、取消、派送、完成，以及订单报表下载等功能\"]},{\"header\":\"2. 用户端\",\"slug\":\"_2-用户端\",\"contents\":[\"移动端应用主要提供给消费者使用 主要功能有:\",\"模块\",\"描述\",\"登录/退出\",\"在移动端，用户也需要登录后使用APP进行点餐\",\"点餐-菜单\",\"在点餐界面需要展示出菜品分类/套餐分类，并根据当前选择的分类加载其中的菜品信息，供用户查询选择\",\"点餐-购物车\",\"用户选中的菜品就会加入用户的购物车，主要包含 查询购物车、加入购物车、删除购物车、清空购物车等功能\",\"订单支付\",\"用户选完菜品/套餐后，可以对购物车菜品进行结算支付，这时就需要进行订单的支付\",\"个人信息\",\"在个人中心页面中会展示当前用户的基本信息，用户可以管理收货地址，也可以查询历史订单数据\"]},{\"header\":\"2.3 技术选型\",\"slug\":\"_2-3-技术选型\",\"contents\":[]},{\"header\":\"1. 用户层\",\"slug\":\"_1-用户层\",\"contents\":[\"系统管理后台的前端页面，使用 H5、Vue.js、ElementUI 等技术\"]},{\"header\":\"2. 网关层\",\"slug\":\"_2-网关层\",\"contents\":[\"Nginx是一个服务器，主要用来作为Http服务器，部署静态资源，访问性能高\",\"Nginx中还有两个比较重要的作用： 反向代理和负载均衡， 在进行项目部署时，要实现Tomcat的负载均衡，就可以通过Nginx来实现\"]},{\"header\":\"3. 应用层\",\"slug\":\"_3-应用层\",\"contents\":[\"SpringBoot： 快速构建Spring项目，采用 \\\"约定优于配置\\\" 的思想，简化Spring项目的配置开发\",\"Spring：统一管理项目中的各种资源(bean)，在web开发的各层中都会用到\",\"SpringMVC：SpringMVC是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合，可以无缝集成\",\"SpringSession：主要解决在集群环境下的Session共享问题\",\"lombok：能以简单的注解形式来简化java代码，提高开发人员的开发效率，例如开发中经常需要写的javabean，都需要花时间去添加相应的getter/setter，也许还要去写构造器、equals等方法\",\"Swagger： 自动帮助开发人员生成接口文档，并对接口进行测试\"]},{\"header\":\"4. 数据层\",\"slug\":\"_4-数据层\",\"contents\":[\"MySQL： 关系型数据库，本项目的核心业务数据都会采用MySQL进行存储\",\"MybatisPlus： 本项目持久层将会使用MybatisPlus来简化开发，基本的单表增删改查直接调用框架提供的方法即可\",\"Redis： 基于key-value格式存储的内存数据库，访问速度快，经常使用它做缓存(降低数据库访问压力，提供访问效率)，在后面的性能优化中会使用\"]},{\"header\":\"5. 工具\",\"slug\":\"_5-工具\",\"contents\":[\"git: 版本控制工具，在团队协作中，使用该工具对项目中的代码进行管理\",\"maven: 项目构建工具\",\"junit：单元测试工具，开发人员功能实现完毕后，需要通过junit对功能进行单元测试\"]},{\"header\":\"2.4 功能架构\",\"slug\":\"_2-4-功能架构\",\"contents\":[\"1. 移动端前台功能:\",\"手机号登录 ，微信登录 ，收件人地址管理 ，用户历史订单查询 ，菜品规格查询 ，购物车功能 ，下单 ，分类及菜品浏览\",\"2. 系统管理后台功能:\",\"员工登录/退出 ，员工信息管理 ，分类管理 ，菜品管理 ，套餐管理 ，菜品口味管理 ，订单管理\"]},{\"header\":\"2.5 角色\",\"slug\":\"_2-5-角色\",\"contents\":[\"后台系统管理员\",\"后台系统普通员工\",\"C端(移动端)用户\",\"角色\",\"权限操作\",\"后台系统管理员\",\"登录后台管理系统，拥有后台系统中的所有操作权限\",\"后台系统普通员工\",\"登录后台管理系统，对菜品、套餐、订单等进行管理 (不包含员工管理)\",\"C端用户\",\"登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等\"]}]},\"/Database/Basic/Language/\":{\"title\":\"Language\",\"contents\":[]},\"/Database/Basic/Principle/\":{\"title\":\"Principle\",\"contents\":[]},\"/Tools/Git/01Manual/manual01.html\":{\"title\":\"1. 常用Git命令清单\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\",\"几个专用名词的译名\",\"Workspace：工作区\",\"Index / Stage：暂存区\",\"Repository：仓库区（或本地仓库）\",\"Remote：远程仓库\"]},{\"header\":\"1 新建代码库\",\"slug\":\"_1-新建代码库\",\"contents\":[\"# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] \"]},{\"header\":\"2 配置\",\"slug\":\"_2-配置\",\"contents\":[\"Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\",\"# 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \\\"[name]\\\" $ git config [--global] user.email \\\"[email address]\\\" \"]},{\"header\":\"3 增加/删除文件\",\"slug\":\"_3-增加-删除文件\",\"contents\":[\"# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] \"]},{\"header\":\"4 代码提交\",\"slug\":\"_4-代码提交\",\"contents\":[\"# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... \"]},{\"header\":\"5 分支\",\"slug\":\"_5-分支\",\"contents\":[\"# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] \"]},{\"header\":\"6 标签\",\"slug\":\"_6-标签\",\"contents\":[\"# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] \"]},{\"header\":\"7 查看信息\",\"slug\":\"_7-查看信息\",\"contents\":[\"# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\\\"提交说明\\\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \\\"@{0 day ago}\\\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog \"]},{\"header\":\"8 远程同步\",\"slug\":\"_8-远程同步\",\"contents\":[\"# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all \"]},{\"header\":\"9 撤销\",\"slug\":\"_9-撤销\",\"contents\":[\"# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop \"]},{\"header\":\"10 常用操作组合\",\"slug\":\"_10-常用操作组合\",\"contents\":[\"修改本地分支名和远程分支名：\",\"git branch -m old_branch new_branch # 重命名本地分支 git push origin :old_branch # 删除远程旧分支（分支名前有冒号） git push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支 \",\"相关文章：\",\"《如何撤销 Git 操作？》\",\"《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\",\"命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\"]}]},\"/Tools/Git/01Manual/manual02.html\":{\"title\":\"2. Git变基合并\",\"contents\":[{\"header\":\"1 rebase分支合并\",\"slug\":\"_1-rebase分支合并\",\"contents\":[]},{\"header\":\"1.1 说明\",\"slug\":\"_1-1-说明\",\"contents\":[\"以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\",\"当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\",\"# 首先将 v2 push到远程仓库 git add . git commit -m 'xxx' git push origin v2 # 切换到 dev 拉取最新代码 git checkout dev git pull origin dev # 切换到 v2 git checkout v2 git rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev # 切换到 dev git checkout dev git merge v2 # 将 dev分支 快进合并 （此时 (HEAD -> dev, v2) [commit] 两个分支指向同一个提交） # 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面） git log # 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态 # 试运行项目是否有问题 yarn start git status # 查看状态是否有问题 git push origin dev # 推送到远程仓库的 dev \"]},{\"header\":\"1.2 变基要遵守的准则\",\"slug\":\"_1-2-变基要遵守的准则\",\"contents\":[\"几个人同时在一个分支上进行开发和提交时，开发中途请不要私自执行变基，只有在大家都完成工作之后才可以执行变基。\"]},{\"header\":\"1.3 变基的实质\",\"slug\":\"_1-3-变基的实质\",\"contents\":[\"变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\"]},{\"header\":\"2 后悔药\",\"slug\":\"_2-后悔药\",\"contents\":[\"# 查看HEAD指针变动记录 git reflog # 记录示例(当前分支是v2): 07c398f (HEAD -> v2, master) HEAD@{0}: checkout: moving from master to v2 07c398f (HEAD -> v2, master) HEAD@{1}: rebase (finish): returning to refs/heads/master 07c398f (HEAD -> v2, master) HEAD@{2}: rebase (start): checkout v2 15a97d8 HEAD@{3}: reset: moving to 15a97d8 07c398f (HEAD -> v2, master) HEAD@{4}: merge v2: Fast-forward 15a97d8 HEAD@{5}: checkout: moving from v2 to master 07c398f (HEAD -> v2, master) HEAD@{6}: rebase (finish): returning to refs/heads/v2 07c398f (HEAD -> v2, master) HEAD@{7}: rebase (pick): C 15a97d8 HEAD@{8}: rebase (start): checkout master # 首次rebase d278ecd HEAD@{9}: checkout: moving from master to v2 # rebase前的状态 15a97d8 HEAD@{10}: commit: D # 可见，示例中最初的 rebase 操作是 HEAD@{8}，想回退到变基前的状态需让指针指向 HEAD@{9} git reset --hard d278ecd # 重置当前分支的HEAD为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致 # 此时打印 log 查看是否回到之前的状态 git log \",\"注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\"]},{\"header\":\"3 开发期间的rebase操作\",\"slug\":\"_3-开发期间的rebase操作\",\"contents\":[]},{\"header\":\"3.1 背景\",\"slug\":\"_3-1-背景\",\"contents\":[\"有两个分支：\",\"dev *v2 \",\"v2 是基于dev切出来的。\",\"提交记录如下：\",\" dev a - b - c v2 \",\"开发期间，两个分支同时有新的commit ：\",\" dev a - b - c - d - e \\\\ - f - g v2 \",\"当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\",\"需求： 把dev中新的提交同步到v2，且不能影响dev分支。\"]},{\"header\":\"3.2 操作步骤\",\"slug\":\"_3-2-操作步骤\",\"contents\":[\"基于最新的 dev 切一个新的分支 dev-copy\",\"dev-copy 和 dev 两者的 commit ID 一致。\",\"在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\",\"git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2 \",\"删除原v2分支，将dev-copy分支名改为v2\",\"# 当前在 dev-copy 分支 git branch -d v2 # 删除分支 git branch -m dev-copy v2 # 重命名 \"]},{\"header\":\"3 git cherry-pick\",\"slug\":\"_3-git-cherry-pick\",\"contents\":[\"来源：《git cherry-pick 教程》\",\"用于将单个或几个[commit]复制到另一个分支。\"]},{\"header\":\"3.1 基本应用\",\"slug\":\"_3-1-基本应用\",\"contents\":[\"git cherry-pick <commitHash> # 将commitHash应用于当前分支 \",\"上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\",\"git cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\"]},{\"header\":\"3.2 转移多个提交\",\"slug\":\"_3-2-转移多个提交\",\"contents\":[\"Cherry pick 支持一次转移多个提交。\",\"git cherry-pick <HashA> <HashB> # A和B提交 \",\"上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\",\"如果想要转移一系列的连续提交，可以使用下面的简便语法。\",\"git cherry-pick A..B # A到B提交，不包含A \",\"上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。\",\"注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。\",\"git cherry-pick A^..B # A到B提交，包含A \"]}]},\"/Tools/Git/01Manual/manual03.html\":{\"title\":\"3. Git命令思维导图\",\"contents\":[]},\"/Tools/Git/02DocumentNotes/documentnotes01.html\":{\"title\":\"1. Git基础与命令\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"官方文档（中文）：https://git-scm.com/book/zh/v2\"]},{\"header\":\"Git基础\",\"slug\":\"git基础\",\"contents\":[]},{\"header\":\"全局配置\",\"slug\":\"全局配置\",\"contents\":[\"git config --global user.name 'your name' git config --global user.email 'xxx@xx.com' \"]},{\"header\":\"检查配置信息\",\"slug\":\"检查配置信息\",\"contents\":[\"git config --list \"]},{\"header\":\"获取帮助\",\"slug\":\"获取帮助\",\"contents\":[\"# 获取全局帮助手册 git help # 获取特定命令的详细版帮助手册 (两个命令是等价的) git help <某个命令> git <某个命令> --help # 两个横杠 # 获取特定命令的简明版帮助手册 git <某个命令> -h # 一个横杠 \"]},{\"header\":\"初始化仓库\",\"slug\":\"初始化仓库\",\"contents\":[\"# 本地目录初始化仓库 git init \",\"如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\"]},{\"header\":\"克隆远程仓库\",\"slug\":\"克隆远程仓库\",\"contents\":[\"# 克隆 git clone <url> # 克隆同时修改目录名 git clone <url> <name> \",\"初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们\"]},{\"header\":\"检查文件状态\",\"slug\":\"检查文件状态\",\"contents\":[\"# 查看详细状态说明 git status # 查看简明状态说明 git status -s # -s 或 --short M README # 已修改，但未暂存 （M的位置靠右，红色） MM Rakefile # 已修改，暂存后又作了修改（有暂存和未暂存） A lib/git.rb # 新添加到暂存区，未提交 M lib/simplegit.rb # 已修改，已暂存 （M的位置靠左，绿色） ?? LICENSE.txt # 新添加，未跟踪 \",\"git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\",\"参数的一个横杠表示缩写，两个横杠表示全称。\"]},{\"header\":\"加入暂存区 (跟踪文件)\",\"slug\":\"加入暂存区-跟踪文件\",\"contents\":[\"# 文件加入暂存区（跟踪指定文件) git add <files> \",\"git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\",\"add 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\"]},{\"header\":\"忽略文件\",\"slug\":\"忽略文件\",\"contents\":[\"添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\",\"*.[oa] # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现） *~ # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本） \",\"文件 .gitignore 的格式规范如下：\",\"所有空行或者以 # 开头的行都会被 Git 忽略（注释符号）。\",\"可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\",\"glob 模式是指 shell 所使用的简化了的正则表达式\",\"匹配模式可以以（/）开头防止递归。\",\"匹配模式可以以（/）结尾指定目录。\",\"要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\",\"星号（*）匹配零个或多个任意字符\",\"[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\",\"问号（?）只匹配一个任意字符\",\"[0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\",\"使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\",\"# 忽略所有的 .a 文件 *.a # 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件 !lib.a # 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO /TODO # 忽略任何目录下名为 build 的文件夹 build/ # 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt doc/*.txt # 忽略 doc/ 目录及其所有子目录下的 .pdf 文件 doc/**/*.pdf \",\"GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\"]},{\"header\":\"查看修改的具体内容\",\"slug\":\"查看修改的具体内容\",\"contents\":[\"git diff # 比较修改之后还没有暂存起来的变化内容。 git diff --staged # 查看已暂存的将要添加到下次提交里的内容 \",\"git status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\"]},{\"header\":\"提交更新\",\"slug\":\"提交更新\",\"contents\":[\"git commit # 未带参数的会打开默认文本编辑器让你输入提交说明 git commit -m '提交说明' # 带-m参数直接输入提交说明 \",\"使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\"]},{\"header\":\"跳过使用暂存区域\",\"slug\":\"跳过使用暂存区域\",\"contents\":[\"git commit -a -m '提交说明' \",\"添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\",\"注意：这个操作无法提交未跟踪的文件。\"]},{\"header\":\"Git 基础 - 查看提交历史\",\"slug\":\"git-基础-查看提交历史\",\"contents\":[\"git log \",\"不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\",\"此命令打印的数据中有一项是一长串的 SHA-1 校验码。\",\"带入-p或--patch查看提交的具体差异：\",\"git log -p -2 # -p显示差异 -2显示最近的提交次数 \",\"--stat 显示每次提交的差异统计\",\"git log --stat \",\"--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\",\"这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\",\"$ git log --pretty=oneline ca82a6dff817ec66f44342007202690a93763949 changed the version number 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test a11bef06a3f659402fe7563abf99ad00de2209e6 first commit \",\"最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：\",\"$ git log --pretty=format:\\\"%h - %an, %ar : %s\\\" ca82a6d - Scott Chacon, 6 years ago : changed the version number 085bb3b - Scott Chacon, 6 years ago : removed unnecessary test a11bef0 - Scott Chacon, 6 years ago : first commit \",\"git log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\",\"当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：\",\"$ git log --pretty=format:\\\"%h %s\\\" --graph * 2d3acf9 ignore errors from SIGCHLD on trap * 5e3ee11 Merge branch 'master' of git://github.com/dustin/grit |\\\\ | * 420eac9 Added a method for getting the current branch. * | 30e367c timeout code and tests * | 5a09431 add timeout protection to grit * | e1193f8 support for heads with slashes in them |/ * d6016bc require time for xmlschema * 11d191e Merge branch 'defunkt' into local \"]},{\"header\":\"Git 基础 - 撤消操作\",\"slug\":\"git-基础-撤消操作\",\"contents\":[\"你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\",\"git commit -m 'initial commit' git add forgotten_file git commit --amend # 重新提交，且只有一次提交记录 \",\"最终你只会有一个提交——第二次提交将代替第一次提交的结果。\",\"更多撤销操作请了解 reset命令。\"]},{\"header\":\"Git 基础 - 远程仓库的使用\",\"slug\":\"git-基础-远程仓库的使用\",\"contents\":[]},{\"header\":\"查看远程仓库\",\"slug\":\"查看远程仓库\",\"contents\":[\"git remote # 仅显示远程仓库的名称 git remote -v # 显示远程仓库的名称 + 地址 \"]},{\"header\":\"添加远程仓库\",\"slug\":\"添加远程仓库\",\"contents\":[\" git remote add <远程仓库名> <url> \"]},{\"header\":\"从远程仓库中抓取与拉取\",\"slug\":\"从远程仓库中抓取与拉取\",\"contents\":[\"就如刚才所见，从远程仓库中获得数据，可以执行：\",\"git fetch <remote> \",\"这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\",\"注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\",\"git pull \",\"用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\"]},{\"header\":\"推送到远程仓库\",\"slug\":\"推送到远程仓库\",\"contents\":[\"git push <remote> <branch> # git push origin master \"]},{\"header\":\"查看某个远程仓库\",\"slug\":\"查看某个远程仓库\",\"contents\":[\" git remote show <remote> # git remote show origin \",\"查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\"]},{\"header\":\"远程仓库的重命名与移除\",\"slug\":\"远程仓库的重命名与移除\",\"contents\":[\"git remote rename <原名> <新名> # 重命名 git remote remove paul <remote># 移除远程仓库 \"]},{\"header\":\"Git 基础 - 打标签\",\"slug\":\"git-基础-打标签\",\"contents\":[]},{\"header\":\"列出标签\",\"slug\":\"列出标签\",\"contents\":[\"git tag # 完整标签列表 git tag -l \\\"v2.0*\\\" # 只显示包含 v2.0 的标签。 注意加星号(*) \",\"-l 或 --list 都可以。\"]},{\"header\":\"创建标签\",\"slug\":\"创建标签\",\"contents\":[\"Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\",\"轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\",\"而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\"]},{\"header\":\"附注标签\",\"slug\":\"附注标签\",\"contents\":[\"git tag -a v1.4 -m \\\"my version 1.4\\\" # -a表示add， -m 表示附件信息 \",\"通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\",\"git show v1.4 \"]},{\"header\":\"轻量标签\",\"slug\":\"轻量标签\",\"contents\":[\"轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\",\"git tag v1.4-lw # 不需要添加选项 \",\"这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\",\"git show v1.4-lw commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon <schacon@gee-mail.com> Date: Mon Mar 17 21:52:11 2008 -0700 \"]},{\"header\":\"后期打标签\",\"slug\":\"后期打标签\",\"contents\":[\"你也可以对过去的提交打标签。 假设提交历史是这样的：\",\"git log --pretty=oneline 166ae0c4d3f420721acbb115cc33848dfcc2121a started write support 9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile 8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme \",\"现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\",\"git tag -a v1.2 9fceb02 # 打的标签属于附注标签 \"]},{\"header\":\"共享标签\",\"slug\":\"共享标签\",\"contents\":[\"git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\",\"git push origin v1.5 # 显式地推送标签到远程仓库 git push origin --tags # 一次性推送所有不在远程仓库上的标签 \",\"现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\"]},{\"header\":\"删除标签\",\"slug\":\"删除标签\",\"contents\":[\"要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\",\"$ git tag -d v1.4-lw Deleted tag 'v1.4-lw' (was e7d5add) \",\"注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\",\"第一种变体是 git push <remote> :refs/tags/<tagname> ：\",\"$ git push origin :refs/tags/v1.4-lw To /git@github.com:schacon/simplegit.git - [deleted] v1.4-lw \",\"上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\",\"第二种更直观的删除远程标签的方式是：\",\"git push origin --delete <tagname> \"]},{\"header\":\"检出标签\",\"slug\":\"检出标签\",\"contents\":[\"如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：\",\"$ git checkout 2.0.0 Note: checking out '2.0.0'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b <new-branch> HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final git checkout 2.0-beta-0.1 Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final HEAD is now at df3f601... add atlas.json and cover image \",\"在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\",\"git checkout -b version2 v2.0.0 Switched to a new branch 'version2' \",\"如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\"]},{\"header\":\"Git 命令别名\",\"slug\":\"git-命令别名\",\"contents\":[\"Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\",\"git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status \",\"这意味着，当要输入 git commit 时，只需要输入 git ci。\",\"在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：\",\"git config --global alias.unstage 'reset HEAD --' \",\"这会使下面的两个命令等价：\",\"git unstage fileA git reset HEAD -- fileA \",\"这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\",\"git config --global alias.last 'log -1 HEAD' \",\"这样，可以轻松地看到最后一次提交：\",\"git last commit 66938dae3329c7aebe598c2246a8e6af90d04646 Author: Josh Goebel <dreamer3@example.com> Date: Tue Aug 26 19:48:51 2008 +0800 test for current head Signed-off-by: Scott Chacon <schacon@example.com> \",\"可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\",\"git config --global alias.visual '!gitk' \"]}]},\"/Tools/Git/02DocumentNotes/documentnotes02.html\":{\"title\":\"2. Git分支-分支原理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\"]},{\"header\":\"首次提交\",\"slug\":\"首次提交\",\"contents\":[\"在进行提交操作时，Git 会保存一个提交对象（commit object）。\",\"假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\",\"git add README test.rb LICENSE git commit -m 'The initial commit of my project' \",\"当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。\",\"现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\",\"图1. 首次提交对象及其树结构 ▲\",\"小结：\",\"git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\",\"git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\"]},{\"header\":\"再次提交\",\"slug\":\"再次提交\",\"contents\":[\"做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\"]},{\"header\":\"Git 的分支\",\"slug\":\"git-的分支\",\"contents\":[\"Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\",\"Git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\"]},{\"header\":\"创建分支\",\"slug\":\"创建分支\",\"contents\":[\"Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\",\"git branch testing \",\"这会在当前所在的提交对象上创建一个指针。\"]},{\"header\":\"当前分支的指针\",\"slug\":\"当前分支的指针\",\"contents\":[\"Git 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\"]},{\"header\":\"查看当前所在分支\",\"slug\":\"查看当前所在分支\",\"contents\":[\"你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\",\"$ git log --oneline --decorate f30ab (HEAD -> master, testing) add feature # f30ab提交对象 (HEAD当前所在分支 -> master分支，testing 分支) 34ac2 Fixed bug # 34ac2 提交对象 98ca9 The initial commit of my project # 98ca9 提交对象 \",\"正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\"]},{\"header\":\"分支切换\",\"slug\":\"分支切换\",\"contents\":[\"git checkout testing # git checkout <分支名> \",\"这样 HEAD 就指向 testing 分支了。\",\"那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\",\"vim test.rb git commit -a -m 'made a change' \",\"如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\",\"git checkout master \",\"这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\",\"我们不妨再稍微做些修改并提交：\",\"vim test.rb git commit -a -m 'made other changes' \",\"现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\",\"你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\",\"$ git log --oneline --decorate --graph --all * c2b9e (HEAD, master) made other changes | * 87ab2 (testing) made a change |/ * f30ab add feature * 34ac2 fixed bug * 98ca9 initial commit of my project \",\"由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\",\"这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。\"]},{\"header\":\"创建分支同时切换\",\"slug\":\"创建分支同时切换\",\"contents\":[\"通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\",\"git checkout -b <newbranchname> \"]}]},\"/Tools/Git/02DocumentNotes/documentnotes03.html\":{\"title\":\"3. Git分支的新建与合并-分支操作\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"文档：Git 分支 - 分支的新建与合并\"]},{\"header\":\"创建分支并切换\",\"slug\":\"创建分支并切换\",\"contents\":[\"此时有一个需求需要在新的分支iss53上工作：\",\"git checkout -b iss53 # b表示branch \",\"它是下面两条命令的简写：\",\"git branch iss53 git checkout iss53 \"]},{\"header\":\"切换分支\",\"slug\":\"切换分支\",\"contents\":[\"突然有一个紧急问题要解决，需要在原来的master分支进行修复：\",\"git checkout master \",\"在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\",\"注意：切换分支Git 会重置你的工作目录。\",\"checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\",\"接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\",\"$ git checkout -b hotfix # 中间过程在hotfix上修改了代码并提交 $ echo 'test' > ./hotfix.txt $ git add . $ git commit -m 'fixed' \"]},{\"header\":\"合并分支\",\"slug\":\"合并分支\",\"contents\":[\"git checkout master # 首先切回master分支 git merge hotfix # 把 hotfix 分支合并过来 \"]},{\"header\":\"删除分支\",\"slug\":\"删除分支\",\"contents\":[\"$ git branch -d hotfix # d表示delete # 然后切回iss53继续工作 $ git checkout iss53 \",\"注意删除分支是在 branch 命令上\"]},{\"header\":\"多次提交之后合并分支\",\"slug\":\"多次提交之后合并分支\",\"contents\":[\"假设你已经修正了 #53 问题，打算合并到master分支：\",\"git checkout master git merga iss53 \",\"这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\",\"和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\"]},{\"header\":\"遇到冲突时的分支合并\",\"slug\":\"遇到冲突时的分支合并\",\"contents\":[\"如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，就产生了冲突。\",\"合并过程中出现CONFLICT提升，表示有冲突\",\"$ git merge iss53 Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. \",\"使用git status查看未合并状态。\",\"任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\",\"<<<<<<< HEAD:index.html <div id=\\\"footer\\\">contact : email.support@github.com</div> ======= <div id=\\\"footer\\\"> please contact us at support@github.com </div> >>>>>>> iss53:index.html \",\"你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。\",\"如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。\"]}]},\"/Tools/Git/02DocumentNotes/documentnotes04.html\":{\"title\":\"4. Git分支管理-查看分支\",\"contents\":[{\"header\":\"查看分支\",\"slug\":\"查看分支\",\"contents\":[\"$ git branch iss53 * master # 带星号*表示当前所在分支 testing \",\"git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\"]},{\"header\":\"查看每个分支的最后提交\",\"slug\":\"查看每个分支的最后提交\",\"contents\":[\"$ git branch -v iss53 93b412c fix javascript issue * master 7a98805 Merge branch 'iss53' testing 782fd34 test \"]},{\"header\":\"查看已(未)合并的分支\",\"slug\":\"查看已-未-合并的分支\",\"contents\":[\"--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\",\"$ git branch --merged # 查看已合并分支列表 iss53 * master \",\"上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\",\"$ git branch --no-merged # 查看未合并的分支列表 testing \",\"上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\",\"$ git branch -d testing error: The branch 'testing' is not fully merged. If you are sure you want to delete it, run 'git branch -D testing'. \",\"强制删除未合并的分支:\",\"git branch -D testing \"]},{\"header\":\"查看指定分支的已(未)合并的分支\",\"slug\":\"查看指定分支的已-未-合并的分支\",\"contents\":[\"上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\",\"你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\",\"$ git branch --no-merged testing topicA featureB \"]}]},\"/Tools/Git/02DocumentNotes/documentnotes05.html\":{\"title\":\"5. Git分支开发工作流\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"文档：Git分支开发工作流\"]},{\"header\":\"长期分支\",\"slug\":\"长期分支\",\"contents\":[\"因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\",\"许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\",\"dev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\",\"事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\",\"你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\"]},{\"header\":\"主题分支 (短期分支)\",\"slug\":\"主题分支-短期分支\",\"contents\":[\"主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\",\"你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\",\"考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\",\"拥有多个主题分支的提交历史。\",\"现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\",\"合并了 dumbidea 和 iss91v2 分支之后的提交历史。\",\"我们将会在 分布式 Git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\",\"请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。\"]}]},\"/Tools/Git/02DocumentNotes/documentnotes06.html\":{\"title\":\"6. Git分支-远程分支\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"远程引用是对远程仓库的引用（指针），包括分支、标签等等。\",\"远程分支本质上也是一个指针，指向远程地址\"]},{\"header\":\"查看远程引用列表与信息\",\"slug\":\"查看远程引用列表与信息\",\"contents\":[\"git ls-remote <remote> # 远程引用的完整列表 git remote show <remote> # 远程分支的更多信息 \",\"上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\"]},{\"header\":\"远程跟踪分支\",\"slug\":\"远程跟踪分支\",\"contents\":[\"远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\",\"它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\",\"这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\",\"笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\",\"笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\",\"克隆之后的服务器与本地仓库。\",\"如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\",\"本地与远程的工作可以分叉。\",\"如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\",\"git fetch 更新你的远程仓库引用。\",\"笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\",\"为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 URL 的缩写。远程仓库名本质上是远程URL的缩写\",\"添加另一个远程仓库。\",\"现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\",\"远程跟踪分支 teamone/master。\"]},{\"header\":\"推送\",\"slug\":\"推送\",\"contents\":[\"当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\",\"如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\",\"$ git push origin serverfix Counting objects: 24, done. Delta compression using up to 8 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done. Total 24 (delta 2), reused 0 (delta 0) To https://github.com/schacon/simplegit * [new branch] serverfix -> serverfix \",\"这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\"]},{\"header\":\"重命名远程仓库上的分支名\",\"slug\":\"重命名远程仓库上的分支名\",\"contents\":[\"如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\",\"Note\",\"如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config --global credential.helper cache 来设置它。想要了解更多关于不同验证缓存的可用选项，查看 凭证存储。\",\"下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\",\"$ git fetch origin remote: Counting objects: 7, done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 3 (delta 0) Unpacking objects: 100% (3/3), done. From https://github.com/schacon/simplegit * [new branch] serverfix -> origin/serverfix \",\"要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\",\"可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\",\"$ git checkout -b serverfix origin/serverfix Branch serverfix set up to track remote branch serverfix from origin. Switched to a new branch 'serverfix' \",\"这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\"]},{\"header\":\"跟踪分支\",\"slug\":\"跟踪分支\",\"contents\":[\"从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\",\"当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式：\",\"$ git checkout --track origin/serverfix Branch serverfix set up to track remote branch serverfix from origin. Switched to a new branch 'serverfix' \",\"由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：\",\"$ git checkout serverfix Branch serverfix set up to track remote branch serverfix from origin. Switched to a new branch 'serverfix' \",\"如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\",\"$ git checkout -b sf origin/serverfix Branch sf set up to track remote branch serverfix from origin. Switched to a new branch 'sf' \",\"现在，本地分支 sf 会自动从 origin/serverfix 拉取。\",\"设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\",\"$ git branch -u origin/serverfix Branch serverfix set up to track remote branch serverfix from origin. \",\"Note\",\"上游快捷方式当设置好跟踪分支后，可以通过简写 @{upstream} 或 @{u} 来引用它的上游分支。 所以在 master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代 git merge origin/master。\"]},{\"header\":\"查看跟踪分支\",\"slug\":\"查看跟踪分支\",\"contents\":[\"如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\",\"$ git branch -vv iss53 7e424c3 [origin/iss53: ahead 2] forgot the brackets master 1ae2a45 [origin/master] deploying index fix * serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it testing 5ea463a trying something new \",\"这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\",\"需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\",\"git fetch --all; git branch -vv \"]},{\"header\":\"拉取\",\"slug\":\"拉取\",\"contents\":[\"当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\",\"由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\"]},{\"header\":\"删除远程分支\",\"slug\":\"删除远程分支\",\"contents\":[\"假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\",\"$ git push origin --delete serverfix To https://github.com/schacon/simplegit - [deleted] serverfix \",\"基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。\"]}]},\"/Tools/Git/02DocumentNotes/documentnotes07.html\":{\"title\":\"7. Git分支-变基\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\"]},{\"header\":\"变基的基本操作\",\"slug\":\"变基的基本操作\",\"contents\":[\"请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\",\"分叉的提交历史。\",\"之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\",\"通过合并操作来整合分叉了的历史。\"]},{\"header\":\"概念\",\"slug\":\"概念\",\"contents\":[\"变基就是：将某一分支上的所有修改复制到另一分支上\",\"除了merge，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\",\"在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\",\"$ git checkout experiment $ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。） First, rewinding head to replay your work on top of it... Applying: added staged command \",\"它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\"]},{\"header\":\"原理\",\"slug\":\"原理\",\"contents\":[\"找到当前分支和目标分支的最近共同祖先\",\"对比当前分支相对于该共同祖先的历次提交\",\"提取相应的修改并存为临时文件\",\"将当前分支指向目标分支\",\"将之前临时文件的修改依序应用\",\"将 C4 中的修改变基到 C3 上。\",\"现在回到 master 分支，进行一次快进合并。\",\"git checkout master git merge experiment \",\"master 分支的快进合并。\"]},{\"header\":\"步骤\",\"slug\":\"步骤\",\"contents\":[\"先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\",\"# 示意： git checkout <源分支> git (源分支的修改)rebase(到) <目标分支> git checkout <目标分支> git merge <源分支> \",\"此时，C4' 指向的快照就和 the merge example 中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\",\"一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\",\"请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\"]},{\"header\":\"优点\",\"slug\":\"优点\",\"contents\":[\"变基的优点： 使提交记录更加整洁。\"]},{\"header\":\"更有趣的变基例子1\",\"slug\":\"更有趣的变基例子1\",\"contents\":[\"在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\"]},{\"header\":\"更有趣的变基例子2\",\"slug\":\"更有趣的变基例子2\",\"contents\":[\"在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\",\"从一个主题分支里再分出一个主题分支的提交历史。\",\"假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：\",\"git rebase --onto master server client \",\"以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\"]},{\"header\":\"--onto选项\",\"slug\":\"onto选项\",\"contents\":[\"选中C分支中的但不在B分支里的修改，应用到A分支。\",\"截取主题分支上的另一个主题分支，然后变基到其他分支。\",\"现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\",\"git checkout master git merge client \",\"快进合并 master 分支，使之包含来自 client 分支的修改。\"]},{\"header\":\"省去先切换到源分支的步骤\",\"slug\":\"省去先切换到源分支的步骤\",\"contents\":[\"git rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支 git checkout <目标分支> git merge <源分支> \",\"注意：使用这个方法要确保源分支上的代码是最新的。\",\"接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\",\"git rebase master server \",\"如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\",\"将 server 中的修改变基到 master 上。\",\"然后就可以快进合并主分支 master 了：\",\"git checkout master git merge server \",\"至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\",\" git branch -d client git branch -d server \",\"最终的提交历史。\"]},{\"header\":\"变基的风险\",\"slug\":\"变基的风险\",\"contents\":[]},{\"header\":\"金科玉律\",\"slug\":\"金科玉律\",\"contents\":[\"呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\",\"如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\",\"如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\",\"提示\",\"例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\"]},{\"header\":\"变基的实质\",\"slug\":\"变基的实质\",\"contents\":[\"变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\",\"让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\",\"克隆一个仓库，然后在它的基础上进行了一些开发。\",\"然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\",\"抓取别人的提交，合并到自己的开发分支。\",\"接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\",\"有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。\",\"结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\",\"你将相同的内容又合并了一次，生成了一个新的提交。\",\"此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他把这两个提交通过变基丢弃的。\"]},{\"header\":\"用变基解决变基\",\"slug\":\"用变基解决变基\",\"contents\":[\"如果你 真的 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\",\"实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\",\"如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\",\"举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会：\",\"检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）\",\"检查其中哪些提交不是合并操作的结果（C2，C3，C4）\",\"检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）\",\"把查到的这些提交应用在 teamone/master 上面\",\"从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\",\"在一个被变基然后强制推送的分支上再次执行变基。\",\"要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\",\"在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\",\"如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\",\"如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\",\"如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\"]},{\"header\":\"变基 vs. 合并\",\"slug\":\"变基-vs-合并\",\"contents\":[\"至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\",\"有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\",\"另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\",\"现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\",\"总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。\"]}]},\"/Tools/Git/02DocumentNotes/documentnotes08.html\":{\"title\":\"8. Git工具-查看修订版本\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\",\"修订版本指的是：提交\"]},{\"header\":\"单个修订版本\",\"slug\":\"单个修订版本\",\"contents\":[\"你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\"]},{\"header\":\"简短的 SHA-1\",\"slug\":\"简短的-sha-1\",\"contents\":[\"Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\",\"例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\",\"$ git log commit 734713bc047d87bf7eac9674765ae793478c50d3 Author: Scott Chacon <schacon@gmail.com> Date: Fri Jan 2 18:32:33 2009 -0800 fixed refs handling, added gc auto, updated tests commit d921970aadf03b3cf0e71becdaab3147ba71cdef Merge: 1c002dd... 35cfb2b... Author: Scott Chacon <schacon@gmail.com> Date: Thu Dec 11 15:08:43 2008 -0800 Merge commit 'phedders/rdocs' commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b Author: Scott Chacon <schacon@gmail.com> Date: Thu Dec 11 14:58:32 2008 -0800 added some blame and merge stuff \"]},{\"header\":\"查看给定SHA-1值的提交\",\"slug\":\"查看给定sha-1值的提交\",\"contents\":[\"在本例中，假设你想要的提交其 SHA-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\",\" git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b git show 1c002dd4b536e7479f git show 1c002d \",\"Git 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：\",\"$ git log --abbrev-commit --pretty=oneline ca82a6d changed the version number 085bb3b removed unnecessary test code a11bef0 first commit \",\"通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 例如，到 2019 年 2 月为止，Linux 内核这个相当大的 Git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\",\"Note\",\"关于 SHA-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同。 然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 SHA-1 值相同， Git 会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。 如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20 字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 p = (n(n-1)/2) * (1/2^160)) ）。 2^80 是 1.2 x 10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 SHA-1 冲突。 如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 Linux 内核历史（650 万个 Git 对象）的代码， 并将之提交到一个巨大的 Git 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50% 的概率产生一次 SHA-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\"]},{\"header\":\"分支引用\",\"slug\":\"分支引用\",\"contents\":[\"引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。\"]},{\"header\":\"查看最后一次提交\",\"slug\":\"查看最后一次提交\",\"contents\":[\"例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\",\"git show ca82a6dff817ec66f44342007202690a93763949 git show topic1 # topic1是分支名 \",\"如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 rev-parse 的 Git 探测工具。 你可以在 Git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\",\"$ git rev-parse topic1 ca82a6dff817ec66f44342007202690a93763949 \"]},{\"header\":\"引用日志\",\"slug\":\"引用日志\",\"contents\":[]},{\"header\":\"HEAD的指向历史\",\"slug\":\"head的指向历史\",\"contents\":[\"当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。\",\"你可以使用 git reflog 来查看引用日志\",\"$ git reflog 734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy. 1c002dd HEAD@{2}: commit: added some blame and merge stuff 1c36188 HEAD@{3}: rebase -i (squash): updating HEAD 95df984 HEAD@{4}: commit: # This is a combination of two commits. 1c36188 HEAD@{5}: rebase -i (squash): updating HEAD 7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD \",\"每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\",\"git show HEAD@{5} \",\"你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\",\"git show master@{yesterday} \",\"就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\",\"可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\",\"$ git log -g master commit 734713bc047d87bf7eac9674765ae793478c50d3 Reflog: master@{0} (Scott Chacon <schacon@gmail.com>) Reflog message: commit: fixed refs handling, added gc auto, updated Author: Scott Chacon <schacon@gmail.com> Date: Fri Jan 2 18:32:33 2009 -0800 fixed refs handling, added gc auto, updated tests commit d921970aadf03b3cf0e71becdaab3147ba71cdef Reflog: master@{1} (Scott Chacon <schacon@gmail.com>) Reflog message: merge phedders/rdocs: Merge made by recursive. Author: Scott Chacon <schacon@gmail.com> Date: Thu Dec 11 15:08:43 2008 -0800 Merge commit 'phedders/rdocs' \",\"值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show HEAD@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\",\"Tip\",\"将引用日志想作 Git 版的 shell 历史记录如果你有 UNIX 或者 Linux 的背景，不妨将引用日志想作 Git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\"]},{\"header\":\"祖先引用\",\"slug\":\"祖先引用\",\"contents\":[\"祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\",\"$ git log --pretty=format:'%h %s' --graph * 734713b fixed refs handling, added gc auto, updated tests * d921970 Merge commit 'phedders/rdocs' |\\\\ | * 35cfb2b Some rdoc changes * | 1c002dd added some blame and merge stuff |/ * 1c36188 ignore *.gem * 9b29157 add open3_detach to gemspec file list \",\"你可以使用 HEAD^ 来查看上一个提交，也就是 “HEAD 的父提交”：\",\"$ git show HEAD^ commit d921970aadf03b3cf0e71becdaab3147ba71cdef Merge: 1c002dd... 35cfb2b... Author: Scott Chacon <schacon@gmail.com> Date: Thu Dec 11 15:08:43 2008 -0800 Merge commit 'phedders/rdocs' \",\"Note\",\"在 Windows 上转义脱字符在 Windows 的 cmd.exe 中，^ 是一个特殊字符，因此需要区别对待。 你可以双写它或者将提交引用放在引号中：$ git show HEAD^ # 在 Windows 上无法工作 $ git show HEAD^^ # 可以 $ git show \\\"HEAD^\\\" # 可以\",\"你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\",\"$ git show d921970^ commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b Author: Scott Chacon <schacon@gmail.com> Date: Thu Dec 11 14:58:32 2008 -0800 added some blame and merge stuff $ git show d921970^2 commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548 Author: Paul Hedderly <paul+git@mjr.org> Date: Wed Dec 10 22:22:03 2008 +0000 Some rdoc changes \",\"另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的。 而区别在于你在后面加数字的时候。 HEAD~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，HEAD~3 就是\",\"$ git show HEAD~3 commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d Author: Tom Preston-Werner <tom@mojombo.com> Date: Fri Nov 7 13:47:59 2008 -0500 ignore *.gem \",\"也可以写成 HEAD~~~，也是第一父提交的第一父提交的第一父提交：\",\"$ git show HEAD~~~ commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d Author: Tom Preston-Werner <tom@mojombo.com> Date: Fri Nov 7 13:47:59 2008 -0500 ignore *.gem \",\"你也可以组合使用这两个语法——你可以通过 HEAD~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\"]},{\"header\":\"提交区间\",\"slug\":\"提交区间\",\"contents\":[\"你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\"]},{\"header\":\"双点\",\"slug\":\"双点\",\"contents\":[\"最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 Example history for range selection.\",\"Example history for range selection.\",\"Figure 137. Example history for range selection.\",\"你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\",\"$ git log master..experiment D C \",\"反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\",\"$ git log experiment..master F E \"]},{\"header\":\"查看即将推送到远端的内容\",\"slug\":\"查看即将推送到远端的内容\",\"contents\":[\"这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\",\"git log origin/master..HEAD \",\"这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..HEAD 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， Git 会默认为 HEAD。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。\"]},{\"header\":\"多点\",\"slug\":\"多点\",\"contents\":[\"双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\",\"git log refA..refB git log ^refA refB git log refB --not refA \",\"这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交，你可以使用以下任意一个命令：\",\"git log refA refB ^refC git log refA refB --not refC \",\"这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\"]},{\"header\":\"三点\",\"slug\":\"三点\",\"contents\":[\"最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\",\"$ git log master...experiment F E D C \",\"这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\",\"这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\",\"$ git log --left-right master...experiment < F < E > D > C \",\"有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。\"]}]},\"/Tools/Git/02DocumentNotes/documentnotes09.html\":{\"title\":\"9. Git工具-交互式暂存\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\",\"$ git add -i staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> \",\"可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\",\"在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\"]},{\"header\":\"暂存与取消暂存文件\",\"slug\":\"暂存与取消暂存文件\",\"contents\":[\"如果在 What now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\",\"What now> u staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb Update>> \",\"要暂存 TODO 和 index.html 文件，可以输入数字：\",\"Update>> 1,2 staged unstaged path * 1: unchanged +0/-1 TODO * 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb Update>> \",\"每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update>> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：\",\"Update>> updated 2 paths *** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> s staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb \",\"现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 r 或 3（撤消）选项：\",\"*** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> r staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Revert>> 1 staged unstaged path * 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Revert>> [enter] reverted one path \",\"再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：\",\"*** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> s staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb \",\"如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\",\"*** Commands *** 1: [s]tatus 2: [u]pdate 3: [r]evert 4: [a]dd untracked 5: [p]atch 6: [d]iff 7: [q]uit 8: [h]elp What now> d staged unstaged path 1: +1/-1 nothing index.html Review diff>> 1 diff --git a/index.html b/index.html index 4d07108..4335f49 100644 --- a/index.html +++ b/index.html @@ -16,7 +16,7 @@ Date Finder <p id=\\\"out\\\">...</p> -<div id=\\\"footer\\\">contact : support@github.com</div> +<div id=\\\"footer\\\">contact : email.support@github.com</div> <script type=\\\"text/javascript\\\"> \",\"通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\"]},{\"header\":\"暂存补丁\",\"slug\":\"暂存补丁\",\"contents\":[\"Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\",\"diff --git a/lib/simplegit.rb b/lib/simplegit.rb index dd5ecc4..57399e0 100644 --- a/lib/simplegit.rb +++ b/lib/simplegit.rb @@ -22,7 +22,7 @@ class SimpleGit end def log(treeish = 'master') - command(\\\"git log -n 25 #{treeish}\\\") + command(\\\"git log -n 30 #{treeish}\\\") end def blame(path) Stage this hunk [y,n,a,d,/,j,J,g,e,?]? \",\"这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\",\"Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ? y - stage this hunk n - do not stage this hunk a - stage this and all the remaining hunks in the file d - do not stage this hunk nor any of the remaining hunks in the file g - select a hunk to go to / - search for a hunk matching the given regex j - leave this hunk undecided, see next undecided hunk J - leave this hunk undecided, see next hunk k - leave this hunk undecided, see previous undecided hunk K - leave this hunk undecided, see previous hunk s - split the current hunk into smaller hunks e - manually edit the current hunk ? - print help \",\"通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\",\"What now> 1 staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: +1/-1 +4/-0 lib/simplegit.rb \",\"simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\",\"也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\",\"更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。\"]}]},\"/Tools/Git/02DocumentNotes/documentnotes10.html\":{\"title\":\"10. Git工具-重写历史\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\",\"在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\",\"Note\",\"在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。 然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。 简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\"]},{\"header\":\"修改最后一次提交\",\"slug\":\"修改最后一次提交\",\"contents\":[\"修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\"]},{\"header\":\"修改提交信息\",\"slug\":\"修改提交信息\",\"contents\":[\"如果，你只是想修改最近一次提交的提交信息，那么很简单：\",\"git commit --amend \",\"上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\"]},{\"header\":\"修改实际内容\",\"slug\":\"修改实际内容\",\"contents\":[\"另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\",\"使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\",\"Tip\",\"修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。 如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件）， 那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ git commit --amend --no-edit\"]},{\"header\":\"修改多个提交信息\",\"slug\":\"修改多个提交信息\",\"contents\":[\"为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\",\"例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 HEAD~2^ 或 HEAD~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\",\"git rebase -i HEAD~3 \",\"再次记住这是一个变基命令——在 HEAD~3..HEAD 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\",\"运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\",\"pick f7f3f6d changed my name a bit pick 310154e updated README formatting and added blame pick a5f4a0d added cat-file # Rebase 710f0f8..a5f4a0d onto 710f0f8 # # Commands: # p, pick <commit> = use commit # r, reword <commit> = use commit, but edit the commit message # e, edit <commit> = use commit, but stop for amending # s, squash <commit> = use commit, but meld into previous commit # f, fixup <commit> = like \\\"squash\\\", but discard this commit's log message # x, exec <command> = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop <commit> = remove commit # l, label <label> = label current HEAD with a name # t, reset <label> = reset HEAD to a label # m, merge [-C <commit> | -c <commit>] <label> [# <oneline>] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c <commit> to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out \",\"需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\",\"$ git log --pretty=format:\\\"%h %s\\\" HEAD~3..HEAD a5f4a0d added cat-file 310154e updated README formatting and added blame f7f3f6d changed my name a bit \",\"注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（HEAD~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\",\"你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\",\"edit f7f3f6d changed my name a bit pick 310154e updated README formatting and added blame pick a5f4a0d added cat-file \",\"当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\",\"$ git rebase -i HEAD~3 Stopped at f7f3f6d... changed my name a bit You can amend the commit now, with git commit --amend Once you're satisfied with your changes, run git rebase --continue \",\"这些指令准确地告诉你该做什么。 输入\",\"git commit --amend \",\"修改提交信息，然后退出编辑器。 然后，运行\",\"git rebase --continue \",\"这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。\"]},{\"header\":\"重新排序提交\",\"slug\":\"重新排序提交\",\"contents\":[\"也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\",\"pick f7f3f6d changed my name a bit pick 310154e updated README formatting and added blame pick a5f4a0d added cat-file \",\"改为这样：\",\"pick 310154e updated README formatting and added blame pick f7f3f6d changed my name a bit \",\"当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\"]},{\"header\":\"压缩提交\",\"slug\":\"压缩提交\",\"contents\":[\"通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\",\"# # Commands: # p, pick <commit> = use commit # r, reword <commit> = use commit, but edit the commit message # e, edit <commit> = use commit, but stop for amending # s, squash <commit> = use commit, but meld into previous commit # f, fixup <commit> = like \\\"squash\\\", but discard this commit's log message # x, exec <command> = run command (the rest of the line) using shell # b, break = stop here (continue rebase later with 'git rebase --continue') # d, drop <commit> = remove commit # l, label <label> = label current HEAD with a name # t, reset <label> = reset HEAD to a label # m, merge [-C <commit> | -c <commit>] <label> [# <oneline>] # . create a merge commit using the original merge commit's # . message (or the oneline, if no original merge commit was # . specified). Use -c <commit> to reword the commit message. # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out \",\"如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\",\"pick f7f3f6d changed my name a bit squash 310154e updated README formatting and added blame squash a5f4a0d added cat-file \",\"当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\",\"# This is a combination of 3 commits. # The first commit's message is: changed my name a bit # This is the 2nd commit message: updated README formatting and added blame # This is the 3rd commit message: added cat-file \",\"当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\"]},{\"header\":\"拆分提交\",\"slug\":\"拆分提交\",\"contents\":[\"拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\",\"pick f7f3f6d changed my name a bit edit 310154e updated README formatting and added blame pick a5f4a0d added cat-file \",\"然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset HEAD^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\",\"git reset HEAD^ git add README git commit -m 'updated README formatting' git add lib/simplegit.rb git commit -m 'added blame' git rebase --continue \",\"Git 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\",\"$ git log -4 --pretty=format:\\\"%h %s\\\" 1c002dd added cat-file 9b29157 added blame 35cfb2b updated README formatting f3cc40e changed my name a bit \",\"再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\"]},{\"header\":\"核武器级选项：filter-branch\",\"slug\":\"核武器级选项-filter-branch\",\"contents\":[\"有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\",\"Caution\",\"git filter-branch 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用 git-filter-repo，它是一个 Python 脚本，相比大多数使用 filter-branch 的应用来说，它做得要更好。它的文档和源码可访问 https://github.com/newren/git-filter-repo 获取。\"]},{\"header\":\"从每一个提交中移除一个文件\",\"slug\":\"从每一个提交中移除一个文件\",\"contents\":[\"这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\",\"$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21) Ref 'refs/heads/master' was rewritten \",\"--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' HEAD 的命令。\",\"最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\"]},{\"header\":\"使一个子目录做为新的根目录\",\"slug\":\"使一个子目录做为新的根目录\",\"contents\":[\"假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\",\"$ git filter-branch --subdirectory-filter trunk HEAD Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12) Ref 'refs/heads/master' was rewritten \",\"现在新项目根目录是 trunk 子目录了。 Git 会自动移除所有不影响子目录的提交。\"]},{\"header\":\"全局修改邮箱地址\",\"slug\":\"全局修改邮箱地址\",\"contents\":[\"另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\",\"$ git filter-branch --commit-filter ' if [ \\\"$GIT_AUTHOR_EMAIL\\\" = \\\"schacon@localhost\\\" ]; then GIT_AUTHOR_NAME=\\\"Scott Chacon\\\"; GIT_AUTHOR_EMAIL=\\\"schacon@example.com\\\"; git commit-tree \\\"$@\\\"; else git commit-tree \\\"$@\\\"; fi' HEAD \",\"这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。\"]}]},\"/Tools/Git/02DocumentNotes/documentnotes11.html\":{\"title\":\"11. Git工具-重置揭密\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"在继续了解更专业的工具前，我们先探讨一下 Git 的 reset 和 checkout 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\"]},{\"header\":\"三棵树\",\"slug\":\"三棵树\",\"contents\":[\"理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\",\"Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\",\"树\",\"用途\",\"HEAD\",\"上一次提交的快照，下一次提交的父结点\",\"Index\",\"预期的下一次提交的快照\",\"Working Directory\",\"沙盒\"]},{\"header\":\"HEAD\",\"slug\":\"head\",\"contents\":[\"HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\",\"其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：\",\"$ git cat-file -p HEAD tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf author Scott Chacon 1301511835 -0700 committer Scott Chacon 1301511835 -0700 initial commit $ git ls-tree -r HEAD 100644 blob a906cb2a4a904a152... README 100644 blob 8f94139338f9404f2... Rakefile 040000 tree 99f1a6d12cb4b6f19... lib \",\"Git 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\"]},{\"header\":\"索引\",\"slug\":\"索引\",\"contents\":[\"索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 git commit 时 Git 看起来的样子。\",\"Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\",\"$ git ls-files -s 100644 a906cb2a4a904a152e80877d4088654daad0c859 0 README 100644 8f94139338f9404f26296befa88755fc2598c289 0 Rakefile 100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0 lib/simplegit.rb \",\"再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\",\"确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\"]},{\"header\":\"工作目录\",\"slug\":\"工作目录\",\"contents\":[\"最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\",\"$ tree . ├── README ├── Rakefile └── lib └── simplegit.rb 1 directory, 3 files \"]},{\"header\":\"工作流程\",\"slug\":\"工作流程\",\"contents\":[\"经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\",\"reset workflow\",\"让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 master 分支。\",\"reset ex1\",\"此时，只有工作目录有内容。\",\"现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\",\"reset ex2\",\"接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\",\"reset ex3\",\"此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\",\"现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\",\"reset ex4\",\"如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\",\"reset ex5\",\"此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\",\"reset ex6\",\"现在运行 git status 会没有输出，因为三棵树又变得相同了。\",\"切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\"]},{\"header\":\"重置的作用\",\"slug\":\"重置的作用\",\"contents\":[\"在以下情景中观察 reset 命令会更有意义。\",\"为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\",\"reset start\",\"让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\"]},{\"header\":\"第 1 步：移动 HEAD\",\"slug\":\"第-1-步-移动-head\",\"contents\":[\"reset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\",\"reset soft\",\"无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\",\"现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\"]},{\"header\":\"第 2 步：更新索引（--mixed）\",\"slug\":\"第-2-步-更新索引-mixed\",\"contents\":[\"注意，如果你现在运行 git status 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。\",\"接下来，reset 会用 HEAD 指向的当前快照的内容来更新索引。\",\"reset mixed\",\"如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset HEAD~），这就是命令将会停止的地方。\",\"现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\"]},{\"header\":\"第 3 步：更新工作目录（--hard）\",\"slug\":\"第-3-步-更新工作目录-hard\",\"contents\":[\"reset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\",\"reset hard\",\"现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\",\"必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。\"]},{\"header\":\"回顾\",\"slug\":\"回顾\",\"contents\":[\"reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\",\"移动 HEAD 分支的指向 （若指定了 --soft，则到此停止）\",\"使索引看起来像 HEAD （若未指定 --hard，则到此停止）\",\"使工作目录看起来像索引\"]},{\"header\":\"通过路径来重置\",\"slug\":\"通过路径来重置\",\"contents\":[\"前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\",\"现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed HEAD file.txt 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard），它会：\",\"移动 HEAD 分支的指向 （已跳过）\",\"让索引看起来像 HEAD （到此处停止）\",\"所以它本质上只是将 file.txt 从 HEAD 复制到索引中。\",\"reset path1\",\"它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\",\"reset path2\",\"这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\",\"我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\",\"reset path3\",\"它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\",\"还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\"]},{\"header\":\"压缩\",\"slug\":\"压缩\",\"contents\":[\"我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\",\"假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\",\"假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\",\"reset squash r1\",\"那么可以运行 git reset --soft HEAD~2 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\",\"reset squash r2\",\"然后只需再次运行 git commit：\",\"reset squash r3\",\"现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\"]},{\"header\":\"检出\",\"slug\":\"检出\",\"contents\":[\"最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\"]},{\"header\":\"不带路径\",\"slug\":\"不带路径\",\"contents\":[\"运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\",\"首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\",\"第二个重要的区别是 checkout 如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。\",\"例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。\",\"所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。\",\"reset checkout\"]},{\"header\":\"带路径\",\"slug\":\"带路径\",\"contents\":[\"运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。\",\"此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\",\"下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。\",\"HEAD\",\"Index\",\"Workdir\",\"WD Safe?\",\"Commit Level\",\"reset --soft [commit]\",\"REF\",\"NO\",\"NO\",\"YES\",\"reset [commit]\",\"REF\",\"YES\",\"NO\",\"YES\",\"reset --hard [commit]\",\"REF\",\"YES\",\"YES\",\"NO\",\"checkout <commit>\",\"HEAD\",\"YES\",\"YES\",\"YES\",\"File Level\",\"reset [commit] <paths>\",\"NO\",\"YES\",\"NO\",\"YES\",\"checkout [commit] <paths>\",\"NO\",\"YES\",\"YES\",\"NO\"]}]},\"/project/reggietakeout/01projectbasic/day01.html\":{\"title\":\"瑞吉外卖基础-Day01\",\"contents\":[{\"header\":\"1. 开发环境搭建\",\"slug\":\"_1-开发环境搭建\",\"contents\":[]},{\"header\":\"1.1 数据库环境搭建\",\"slug\":\"_1-1-数据库环境搭建\",\"contents\":[]},{\"header\":\"1.1.1 创建数据库\",\"slug\":\"_1-1-1-创建数据库\",\"contents\":[\"通过以下两种方式中的任意一种，创建项目的数据库\",\"1.图形界面\",\"注意: 本项目数据库的字符串，选择 utf8mb4\",\"2.命令行\"]},{\"header\":\"1.1.2 数据库表导入\",\"slug\":\"_1-1-2-数据库表导入\",\"contents\":[\"直接将 db_reggie.sql 导入到数据库中\",\"1.图形界面\",\"2.命令行\"]},{\"header\":\"1.1.3 数据库表介绍\",\"slug\":\"_1-1-3-数据库表介绍\",\"contents\":[\"序号\",\"表名\",\"说明\",\"1\",\"employee\",\"员工表\",\"2\",\"category\",\"菜品和套餐分类表\",\"3\",\"dish\",\"菜品表\",\"4\",\"setmeal\",\"套餐表\",\"5\",\"setmeal_dish\",\"套餐菜品关系表\",\"6\",\"dish_flavor\",\"菜品口味关系表\",\"7\",\"user\",\"用户表（C端）\",\"8\",\"address_book\",\"地址簿表\",\"9\",\"shopping_cart\",\"购物车表\",\"10\",\"orders\",\"订单表\",\"11\",\"order_detail\",\"订单明细表\"]},{\"header\":\"1.2 Maven项目搭建\",\"slug\":\"_1-2-maven项目搭建\",\"contents\":[]},{\"header\":\"1.2.1 创建maven项目\",\"slug\":\"_1-2-1-创建maven项目\",\"contents\":[\"1.在idea中创建maven project，项目名称 reggie_take_out\",\"2.检查项目编码\",\"3.检查maven配置\",\"4.检查JDK版本\"]},{\"header\":\"1.2.2 搭建基础环境\",\"slug\":\"_1-2-2-搭建基础环境\",\"contents\":[\"1.在pom.xml中导入依赖\",\"详情\",\"<properties> <java.version>1.8</java.version> </properties> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.4.5</version> <relativePath/> <!-- lookup parent from repository --> </parent> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> <scope>compile</scope> </dependency> <dependency> <groupId>com.baomidou</groupId> <artifactId>mybatis-plus-boot-starter</artifactId> <version>3.4.2</version> </dependency> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> <version>1.18.20</version> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>fastjson</artifactId> <version>1.2.76</version> </dependency> <dependency> <groupId>commons-lang</groupId> <artifactId>commons-lang</artifactId> <version>2.6</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>com.alibaba</groupId> <artifactId>druid-spring-boot-starter</artifactId> <version>1.1.23</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> <version>2.4.5</version> </plugin> </plugins> </build> \",\"2.在工程的resources目录下创建application.yml文件,并引入配置\",\"详情\",\"server: port: 8080 spring: application: #应用名称 ，可选 name: reggie_take_out datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true username: root password: root mybatis-plus: configuration: #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射 address_book ---> AddressBook map-underscore-to-camel-case: true #日志输出 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: id-type: ASSIGN_ID \",\"3.创建包 com.itheima.reggie，并编写启动类\",\"import lombok.extern.slf4j.Slf4j; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @Slf4j @SpringBootApplication public class ReggieApplication { public static void main(String[] args) { SpringApplication.run(ReggieApplication.class,args); log.info(\\\"项目启动成功...\\\"); } } \",\"@Slf4j：是lombok中提供的注解，通过slf4j记录日志\"]},{\"header\":\"1.2.3 前端静态资源导入\",\"slug\":\"_1-2-3-前端静态资源导入\",\"contents\":[\"1.导入静态资源\",\"将 资料/前端资源 两个目录中的静态资源文件，导入到项目的resources目录下\",\"2.创建配置类WebMvcConfig，设置静态资源映射\",\"默认静态资源的存放目录为\",\"\\\"classpath:/resources/\\\"\",\"\\\"classpath:/static/\\\"\",\"\\\"classpath:/public/\\\"\",\"该项目静态资源存放在backend，front目录中，想要访问到静态资源就需要设置静态资源映射\",\"import lombok.extern.slf4j.Slf4j; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport; @Slf4j @Configuration public class WebMvcConfig extends WebMvcConfigurationSupport { /** * 设置静态资源映射 * @param registry */ @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { log.info(\\\"开始进行静态资源映射...\\\"); registry.addResourceHandler(\\\"/backend/**\\\").addResourceLocations(\\\"classpath:/backend/\\\"); registry.addResourceHandler(\\\"/front/**\\\").addResourceLocations(\\\"classpath:/front/\\\"); } } \",\"3.访问测试\",\"http://localhost:8080/backend/index.html\"]},{\"header\":\"2. 后台系统登录功能\",\"slug\":\"_2-后台系统登录功能\",\"contents\":[]},{\"header\":\"2.1 需求分析\",\"slug\":\"_2-1-需求分析\",\"contents\":[\"1.页面原型展示\",\"2.登录页面成品展示\",\"登录页面存放目录 /resources/backend/page/login/login.html\",\"3.查看登录请求\",\"通过浏览器调试工具(F12)，点击登录按钮时，页面会发送请求\",\"请求地址为 http://localhost:8080/employee/login\",\"并提交参数 username 和 password\",\"请求参数为 json 格式数据 {\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"123456\\\"}\",\"此时报404，因为后台系统还没有响应此请求的处理器 \",\"4.数据模型(employee表)\",\"5.前端页面分析\",\"点击 \\\"登录\\\" 按钮，会触发Vue中定义的 handleLogin 方法\",\"发送登录的异步请求之后，获取到响应结果，响应结果中至少包含三个属性: code、data、msg\",\"用户登录成功之后，服务端会返回用户信息，前端将这些用户信息存储在客户端的 localStorage 中了\",\"localStorage.setItem('userInfo',JSON.stringify(res.data)) \"]},{\"header\":\"2.2 代码开发\",\"slug\":\"_2-2-代码开发\",\"contents\":[]},{\"header\":\"2.2.1 基础准备工作\",\"slug\":\"_2-2-1-基础准备工作\",\"contents\":[\"首先在工程下创建包结构\",\"1.创建实体类Employee\",\"该实体类主要用于员工表 employee 进行映射\",\"所属包: com.itheima.reggie.entity\",\"import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import lombok.Data; import java.io.Serializable; import java.time.LocalDateTime; @Data public class Employee implements Serializable { private static final long serialVersionUID = 1L; private Long id; private String username; private String name; private String password; private String phone; private String sex; private String idNumber; //驼峰命名法 ---> 映射的字段名为 id_number private Integer status; private LocalDateTime createTime; private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; } \",\"2.定义Mapper接口\",\"在MybatisPlus中，自定义的Mapper接口，需要继承自 BaseMapper\",\"所属包: com.itheima.reggie.mapper\",\"@Mapper public interface EmployeeMapper extends BaseMapper<Employee>{ } \",\"3.Service接口\",\"本项目的Service接口，在定义时需要继承自MybatisPlus提供的Service层接口 IService，这样就可以直接调用父接口的方法直接执行业务操作，简化业务层代码实现\",\"所属包: com.itheima.reggie.service\",\"public interface EmployeeService extends IService<Employee> { } \",\"4.Service实现类\",\"所属包: com.itheima.reggie.service.impl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.Employee; import com.itheima.reggie.mapper.EmployeeMapper; import com.itheima.reggie.service.EmployeeService; import org.springframework.stereotype.Service; @Service public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper,Employee> implements EmployeeService{ } \",\"5.Controller基础代码\",\"所属包: com.itheima.reggie.controller\",\"import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @Slf4j @RestController @RequestMapping(\\\"/employee\\\") public class EmployeeController { @Autowired private EmployeeService employeeService; } \",\"6.导入通用结果类R\",\"此类是一个通用结果类，服务端响应的所有结果最终都会包装成此种类型返回给前端页面\",\"所属包: com.itheima.reggie.common\",\"import lombok.Data; import java.util.HashMap; import java.util.Map; /** * 通用返回结果，服务端响应的数据最终都会封装成此对象 * @param <T> */ @Data public class R<T> { private Integer code; //编码：1成功，0和其它数字为失败 private String msg; //错误信息 private T data; //数据 private Map map = new HashMap(); //动态数据 public static <T> R<T> success(T object) { R<T> r = new R<T>(); r.data = object; r.code = 1; return r; } public static <T> R<T> error(String msg) { R r = new R(); r.msg = msg; r.code = 0; return r; } public R<T> add(String key, Object value) { this.map.put(key, value); return this; } } \",\"如果业务执行结果为成功，构建R对象时，只需要调用 success 方法 如果需要返回数据，传递 object 参数； 如果无需返回，可以直接传递null\",\"如果业务执行结果为失败，构建R对象时，只需要调用 error 方法，传递错误提示信息即可\"]},{\"header\":\"2.2.2 登录逻辑分析\",\"slug\":\"_2-2-2-登录逻辑分析\",\"contents\":[\"处理逻辑\",\"将页面提交的密码password进行md5加密处理，得到加密后的字符串\",\"根据页面提交的用户名username查询数据库中员工数据信息\",\"如果没有查询到，则返回登录失败结果\",\"密码比对，如果不一致，则返回登录失败结果\",\"查看员工状态，如果为已禁用状态，则返回员工已禁用结果\",\"登录成功，将员工id存入Session，并返回登录成功结果\"]},{\"header\":\"2.2.3 代码实现\",\"slug\":\"_2-2-3-代码实现\",\"contents\":[\"技术点说明: :\",\"A. 前端发起的请求为post请求，所以服务端需要使用注解 @PostMapping\",\"B. 前端传递的请求参数为json格式的数据，这里使用Employee对象接收，但是将json格式数据封装到实体类中，在形参前需要加注解@RequestBody\",\"/** * 员工登录 * @param request * @param employee * @return */ @PostMapping(\\\"/login\\\") public R<Employee> login(HttpServletRequest request,@RequestBody Employee employee){ //1、将页面提交的密码password进行md5加密处理 String password = employee.getPassword(); password = DigestUtils.md5DigestAsHex(password.getBytes()); //2、根据页面提交的用户名username查询数据库 LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(Employee::getUsername,employee.getUsername()); Employee emp = employeeService.getOne(queryWrapper); //3、如果没有查询到则返回登录失败结果 if(emp == null){ return R.error(\\\"登录失败\\\"); } //4、密码比对，如果不一致则返回登录失败结果 if(!emp.getPassword().equals(password)){ return R.error(\\\"登录失败\\\"); } //5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果 if(emp.getStatus() == 0){ return R.error(\\\"账号已禁用\\\"); } //6、登录成功，将员工id存入Session并返回登录成功结果 request.getSession().setAttribute(\\\"employee\\\",emp.getId()); return R.success(emp); } \"]},{\"header\":\"2.3 功能测试\",\"slug\":\"_2-3-功能测试\",\"contents\":[\"启动项目，访问url: http://localhost:8080/backend/page/login/login.html\",\"在测试过程中，可以通过debug断点调试的方式来跟踪程序的执行过程，并且可以查看程序运行时各个对象的具体赋值情况，而且需要注意，在测试过程中，需要将所有的情况都覆盖到\",\"1.问题说明\",\"进行debug断点调试时，前端可能会出现如下问题: 前端页面的控制台报出错误-超时\",\"2.解决方案\",\"前端进行异步请求时，默认超时10000ms，可以调大一些\",\"由于修改了JS文件，需要手动清理一下浏览器缓存，避免缓存影响，JS不能及时生效\"]},{\"header\":\"3. 后台系统退出功能\",\"slug\":\"_3-后台系统退出功能\",\"contents\":[]},{\"header\":\"3.1 需求分析\",\"slug\":\"_3-1-需求分析\",\"contents\":[\"页面跳转到后台系统首页面(backend/index.html)，此时会在系统的右上角显示当前登录用户的姓名\",\"1.退出页面展示\",\"2.前端页面分析\",\"点击 将会调用一个js方法logout，在logout的方法中执行如下逻辑\",\"发起post请求，调用服务端接口 /employee/logout 执行退出操作\",\"删除客户端 localStorage 中存储的用户登录信息，跳转至登录页面\"]},{\"header\":\"3.2 代码实现\",\"slug\":\"_3-2-代码实现\",\"contents\":[\"Controller中接收页面发送的POST请求 /employee/logout，具体的处理逻辑\",\"清理Session中的用户id\",\"返回结果\",\"/** * 员工退出 * @param request * @return */ @PostMapping(\\\"/logout\\\") public R<String> logout(HttpServletRequest request){ //清理Session中保存的当前登录员工的id request.getSession().removeAttribute(\\\"employee\\\"); return R.success(\\\"退出成功\\\"); } \"]},{\"header\":\"3.3 功能测试\",\"slug\":\"_3-3-功能测试\",\"contents\":[\"重启服务，访问登录界面 http://localhost:8080/backend/page/login/login.html\",\"登录完成之后，进入到系统首页 backend/index.html，点击右上角 按钮执行退出操作，完成后看看是否可以跳转到登录页面 ，并检查localStorage\"]}]},\"/project/reggietakeout/01projectbasic/day02.html\":{\"title\":\"瑞吉外卖基础-Day02\",\"contents\":[{\"header\":\"1. 完善登录功能\",\"slug\":\"_1-完善登录功能\",\"contents\":[]},{\"header\":\"1.1 问题分析\",\"slug\":\"_1-1-问题分析\",\"contents\":[\"1.目前现状\",\"用户如果不登录直接访问系统首页面，照样可以正常访问\",\"2.理想效果\",\"上述这种设计并不合理，只有登录成功后才可以访问系统中的页面，如果没有登录，访问系统中的任何界面都直接跳转到登录页面\",\"3.具体应该怎么实现呢？\",\"可以使用过滤器、拦截器来实现，在过滤器、拦截器中拦截前端发起的请求，判断用户是否已经完成登录，如果没有登录则返回提示信息，跳转到登录页面\"]},{\"header\":\"1.2 思路分析\",\"slug\":\"_1-2-思路分析\",\"contents\":[\"过滤器具体的处理逻辑\",\"获取本次请求的URI\",\"判断本次请求，是否需要登录，登录才可以访问\",\"如果不需要，则直接放行\",\"判断登录状态，如果已登录，则直接放行\",\"如果未登录，则返回未登录结果\",\"如果未登录，需要给前端返回什么样的结果呢?\"]},{\"header\":\"1.3 代码实现\",\"slug\":\"_1-3-代码实现\",\"contents\":[\"1.定义登录校验过滤器\",\"自定义一个过滤器 LoginCheckFilter 并实现 Filter 接口，在doFilter方法中完成校验的逻辑\",\"所属包: com.itheima.reggie.filter\",\"import com.alibaba.fastjson.JSON; import com.itheima.reggie.common.R; import lombok.extern.slf4j.Slf4j; import org.springframework.util.AntPathMatcher; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * 检查用户是否已经完成登录 */ @WebFilter(filterName = \\\"loginCheckFilter\\\",urlPatterns = \\\"/*\\\") @Slf4j public class LoginCheckFilter implements Filter{ //路径匹配器，支持通配符 public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher(); @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; //1、获取本次请求的URI String requestURI = request.getRequestURI();// /backend/index.html log.info(\\\"拦截到请求：{}\\\",requestURI); //定义不需要处理的请求路径 String[] urls = new String[]{ \\\"/employee/login\\\", \\\"/employee/logout\\\", \\\"/backend/**\\\", \\\"/front/**\\\" }; //2、判断本次请求是否需要处理 boolean check = check(urls, requestURI); //3、如果不需要处理，则直接放行 if(check){ log.info(\\\"本次请求{}不需要处理\\\",requestURI); filterChain.doFilter(request,response); return; } //4、判断登录状态，如果已登录，则直接放行 if(request.getSession().getAttribute(\\\"employee\\\") != null){ log.info(\\\"用户已登录，用户id为：{}\\\",request.getSession().getAttribute(\\\"employee\\\")); filterChain.doFilter(request,response); return; } log.info(\\\"用户未登录\\\"); //5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据 response.getWriter().write(JSON.toJSONString(R.error(\\\"NOTLOGIN\\\"))); return; } /** * 路径匹配，检查本次请求是否需要放行 * @param urls * @param requestURI * @return */ public boolean check(String[] urls,String requestURI){ for (String url : urls) { boolean match = PATH_MATCHER.match(url, requestURI); if(match){ return true; } } return false; } } \",\"AntPathMatcher：Spring中提供的路径匹配器\",\"通配符规则\",\"符号\",\"含义\",\"?\",\"匹配一个字符\",\"*\",\"匹配0个或多个字符\",\"**\",\"匹配0个或多个目录/字符\",\"2.开启组件扫描\",\"需要在引导类加上Servlet组件扫描的注解，来扫描过滤器配置的@WebFilter注解，扫描上之后，过滤器在运行时就生效了\",\"@Slf4j @SpringBootApplication @ServletComponentScan public class ReggieApplication { public static void main(String[] args) { SpringApplication.run(ReggieApplication.class,args); log.info(\\\"项目启动成功...\\\"); } } \",\"@ServletComponentScan 的作用: ​在SpringBoot项目中，在引导类/配置类上加了该注解后，会自动扫描项目中(当前包及其子包下)的@WebServlet ，@WebFilter ，@WebListener 注解，自动注册Servlet的相关组件\"]},{\"header\":\"1.4 功能测试\",\"slug\":\"_1-4-功能测试\",\"contents\":[\"重启工程，在浏览器地址栏直接输入系统管理后台首页，看看是否可以跳转到登录页面即可，也可以通过debug的形式来跟踪一下代码执行的过程\",\"前端也可以进行debug调试，F12打开浏览器调试工具，找到request.js，在request.js的响应拦截器位置打上断点\"]},{\"header\":\"2. 新增员工\",\"slug\":\"_2-新增员工\",\"contents\":[]},{\"header\":\"2.1 需求分析\",\"slug\":\"_2-1-需求分析\",\"contents\":[\"后台系统中可以管理员工信息，通过新增员工来添加后台系统用户，点击添加员工按钮跳转到新增页面\",\"当填写完表单信息，点击\\\"保存\\\"按钮后，会提交该表单的数据到服务端，在服务端中需要接受数据，然后将数据保存至数据库中\"]},{\"header\":\"2.2 数据模型\",\"slug\":\"_2-2-数据模型\",\"contents\":[\"新增员工，其实就是将新增页面录入的员工数据插入到employee表 employee表中的status字段已经设置了默认值1，表示状态正常\",\"需要注意，employee表中对username字段加入了唯一约束，因为username是员工的登录账号，必须是唯一的\"]},{\"header\":\"2.3 程序执行流程\",\"slug\":\"_2-3-程序执行流程\",\"contents\":[\"在开发代码之前，需要结合着前端页面发起的请求，梳理一下整个程序的执行过程\",\"点击\\\"保存\\\"按钮，页面发送ajax请求，将新增员工页面中输入的数据以json的形式提交到服务端，请求方式POST，请求路径 /employee\",\"服务端Controller接收页面提交的数据并调用Service将数据进行保存\",\"Service调用Mapper操作数据库，保存数据\"]},{\"header\":\"2.4 代码实现\",\"slug\":\"_2-4-代码实现\",\"contents\":[\"在Controller中增加save方法，用于保存用户员工信息\",\"在新增员工时，按钮页面原型中的需求描述，需要给员工设置初始默认密码 123456，并对密码进行MD5加密\",\"在组装员工信息时，还需要封装创建时间、修改时间，创建人、修改人信息(从session中获取当前登录用户)\",\"/** * 新增员工 * @param employee * @return */ @PostMapping public R<String> save(HttpServletRequest request,@RequestBody Employee employee){ log.info(\\\"新增员工，员工信息：{}\\\",employee.toString()); //设置初始密码123456，需要进行md5加密处理 employee.setPassword(DigestUtils.md5DigestAsHex(\\\"123456\\\".getBytes())); employee.setCreateTime(LocalDateTime.now()); employee.setUpdateTime(LocalDateTime.now()); //获得当前登录用户的id Long empId = (Long) request.getSession().getAttribute(\\\"employee\\\"); employee.setCreateUser(empId); employee.setUpdateUser(empId); employeeService.save(employee); return R.success(\\\"新增员工成功\\\"); } \"]},{\"header\":\"2.5 功能测试\",\"slug\":\"_2-5-功能测试\",\"contents\":[\"当在测试中，添加用户时输入了一个已存在的用户名时，前端界面出现错误提示信息\",\"此时，服务端报错信息\",\"出现上述的错误，主要就是因为在 employee 表结构中，针对于username字段，建立了唯一索引，添加重复的username数据时，违背该约束，就会报错 但是此时前端提示的信息并不具体，用户并不知道是因为什么原因造成的该异常，需要给用户提示详细的错误信息\"]},{\"header\":\"2.6 全局异常处理\",\"slug\":\"_2-6-全局异常处理\",\"contents\":[]},{\"header\":\"2.6.1 思路分析\",\"slug\":\"_2-6-1-思路分析\",\"contents\":[\"想解决上述测试中存在的问题，需要对程序中可能出现的异常进行捕获，通常有两种处理方式：\",\"在Controller方法中加入 try...catch 进行异常捕获\",\"如果采用这种方式，虽然可以解决，但是存在弊端，需要在保存其他业务数据时，也需要在Controller方法中加上try...catch进行处理，代码冗余，不通用\",\"使用异常处理器进行全局异常捕获\",\"采用这种方式来实现，只需要在项目中定义一个通用的全局异常处理器，就可以解决本项目的所有异常\"]},{\"header\":\"2.6.2 全局异常处理器\",\"slug\":\"_2-6-2-全局异常处理器\",\"contents\":[\"在项目中自定义一个全局异常处理器，在异常处理器上加上注解 @ControllerAdvice，可以通过属性annotations指定拦截哪一类的Controller方法 并在异常处理器的方法上加上注解 @ExceptionHandler 来指定拦截的是那一类型的异常\",\"异常处理方法逻辑:\",\"指定捕获的异常类型为 SQLIntegrityConstraintViolationException\",\"解析异常的提示信息，获取出是那个值违背了唯一约束\",\"组装错误信息并返回\",\"所属包: com.itheima.reggie.common\",\"import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.RestController; import java.sql.SQLIntegrityConstraintViolationException; /** * 全局异常处理 */ @ControllerAdvice(annotations = {RestController.class, Controller.class}) @ResponseBody @Slf4j public class GlobalExceptionHandler { /** * 异常处理方法 * @return */ @ExceptionHandler(SQLIntegrityConstraintViolationException.class) public R<String> exceptionHandler(SQLIntegrityConstraintViolationException ex){ log.error(ex.getMessage()); if(ex.getMessage().contains(\\\"Duplicate entry\\\")){ String[] split = ex.getMessage().split(\\\" \\\"); String msg = split[2] + \\\"已存在\\\"; return R.error(msg); } return R.error(\\\"未知错误\\\"); } } \",\"注解说明: ​上述的全局异常处理器上使用了的两个注解 @ControllerAdvice ，@ResponseBody\",\"​@ControllerAdvice : 指定拦截那些类型的控制器 ​@ResponseBody: 将方法的返回值 R 对象转换为json格式的数据，响应给页面\",\"​上述使用的两个注解，也可以合并成为一个注解 @RestControllerAdvice \"]},{\"header\":\"2.6.3 测试\",\"slug\":\"_2-6-3-测试\",\"contents\":[\"输入一个已存在的用户名时，前端界面出现如下错误提示信息\"]},{\"header\":\"3. 员工分页查询\",\"slug\":\"_3-员工分页查询\",\"contents\":[]},{\"header\":\"3.1 需求分析\",\"slug\":\"_3-1-需求分析\",\"contents\":[\"分页查询页面中，除了分页条件以外，还有一个查询条件 \\\"员工姓名\\\"\",\"请求参数\",\"搜索条件： 员工姓名(模糊查询)\",\"分页条件： 每页展示条数 ，页码\",\"响应数据\",\"总记录数\",\"结果列表\"]},{\"header\":\"3.2 程序执行流程\",\"slug\":\"_3-2-程序执行流程\",\"contents\":[]},{\"header\":\"3.2.1 页面流程分析\",\"slug\":\"_3-2-1-页面流程分析\",\"contents\":[\"A. 点击菜单，打开员工管理页面时，执行查询：\",\"B. 搜索栏输入员工姓名，回车，执行查询:\",\"页面发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端\",\"服务端Controller接收页面提交的数据，并组装条件调用Service查询数据\",\"Service调用Mapper操作数据库，查询分页数据\",\"Controller将查询到的分页数据，响应给前端页面\",\"页面接收到分页数据，并通过ElementUI的Table组件展示到页面上\"]},{\"header\":\"3.2.2 前端代码介绍\",\"slug\":\"_3-2-2-前端代码介绍\",\"contents\":[\"访问员工列表页面/member/list.html时，会触发Vuejs中的钩子方法，在页面初始化时调用created方法\",\"从上述的前端代码中可以看到，执行完分页查询，需要给前端返回的信息中需要包含两项 : records中封装结果列表，total中封装总记录数\",\"而在组装请求参数时，page、pageSize 都是前端分页插件渲染时的参数\",\"在getMemberList方法中，通过axios发起异步请求\",\"axios发起的异步请求会被声明在 request.js 中的request拦截器拦截，在其中对get请求进行进一步的封装处理\",\"最终发送给服务端的请求为 GET请求，请求链接 /employee/page?page=1&pageSize=10&name=xxx\"]},{\"header\":\"3.3 代码实现\",\"slug\":\"_3-3-代码实现\",\"contents\":[]},{\"header\":\"3.3.1 分页插件配置\",\"slug\":\"_3-3-1-分页插件配置\",\"contents\":[\"MybatisPlus要实现分页功能，就需要用到MybatisPlus中提供的分页插件，要使用分页插件，就要在配置类中声明分页插件的bean对象\",\"所属包: com.itheima.reggie.config\",\"import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * 配置MP的分页插件 */ @Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; } } \"]},{\"header\":\"3.3.2 分页查询实现\",\"slug\":\"_3-3-2-分页查询实现\",\"contents\":[\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/employee/page\",\"请求参数\",\"page ，pageSize ，name\",\"查询完毕后需要给前端返回什么样的结果呢?\",\"查询返回的结果数据data中应该封装两项信息，分别为\",\"records 封装分页列表数据\",\"total 封装符合条件的总记录数\",\"在定义controller方法的返回值类型R时，可以直接将 MybatisPlus 分页查询的结果 Page 直接封装返回，因为Page中的属性如下:\",\"具体的逻辑如下:\",\"A. 构造分页条件\",\"B. 构建搜索条件 - name进行模糊匹配\",\"C. 构建排序条件 - 更新时间倒序排序\",\"D. 执行查询\",\"E. 组装结果并返回\",\"具体的代码实现如下:\",\"/** * 员工信息分页查询 * @param page 当前查询页码 * @param pageSize 每页展示记录数 * @param name 员工姓名 - 可选参数 * @return */ @GetMapping(\\\"/page\\\") public R<Page> page(int page,int pageSize,String name){ log.info(\\\"page = {},pageSize = {},name = {}\\\" ,page,pageSize,name); //构造分页构造器 Page pageInfo = new Page(page,pageSize); //构造条件构造器 LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper(); //添加过滤条件 queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name); //添加排序条件 queryWrapper.orderByDesc(Employee::getUpdateTime); //执行查询 employeeService.page(pageInfo,queryWrapper); return R.success(pageInfo); } \"]},{\"header\":\"3.4 功能测试\",\"slug\":\"_3-4-功能测试\",\"contents\":[\"进行测试时，可以使用浏览器的监控工具查看页面和服务端的数据交互细节\",\"测试过程中可以发现，对于员工状态字段（status）服务端返回的是状态码（1或者0），但是页面上显示的则是“正常”或者“已禁用”，这是因为页面中在展示数据时进行了处理\"]},{\"header\":\"4. 启用/禁用员工账号\",\"slug\":\"_4-启用-禁用员工账号\",\"contents\":[]},{\"header\":\"4.1 需求分析\",\"slug\":\"_4-1-需求分析\",\"contents\":[\"在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作\",\"账号禁用的员工不能登录系统，启用后的员工可以正常登录\",\"如果某个员工账号状态为正常，则按钮显示为 \\\"禁用\\\"，如果员工账号状态为已禁用，则按钮显示为\\\"启用\\\"\",\"需要注意，只有管理员（admin用户）可以对其他普通用户进行启用、禁用操作\",\"A.admin 管理员登录\",\"B.普通用户登录\"]},{\"header\":\"4.2 程序执行流程\",\"slug\":\"_4-2-程序执行流程\",\"contents\":[]},{\"header\":\"4.2.1 页面按钮动态展示\",\"slug\":\"_4-2-1-页面按钮动态展示\",\"contents\":[\"页面中是怎么做到只有管理员admin能够看到启用、禁用按钮的？\",\"在列表页面(list.html)加载时，触发钩子函数created，在钩子函数中，会从localStorage中获取到用户登录信息，然后获取到用户名\",\"在页面中，通过Vue指令v-if进行判断，如果登录用户为admin将展示启用/禁用按钮，否则不展示\"]},{\"header\":\"4.2.2 执行流程分析\",\"slug\":\"_4-2-2-执行流程分析\",\"contents\":[\"当管理员admin点击 \\\"启用\\\" 或 \\\"禁用\\\" 按钮时，调用方法statusHandle\",\"scope.row : 获取到的是这一行的数据信息\",\"statusHandle方法中进行二次确认，然后发起ajax请求，传递id、status参数\",\"最终发起异步请求，请求服务端，请求信息如下：\",\"请求\",\"说明\",\"请求方式\",\"PUT\",\"请求路径\",\"/employee\",\"请求参数\",\"{\\\"id\\\":xxx，\\\"status\\\":xxx}\",\"{...params} : 三点是ES6中出现的扩展运算符 作用是遍历当前使用的对象能够访问到的所有属性，并将属性放入当前对象中\"]},{\"header\":\"4.3 代码实现\",\"slug\":\"_4-3-代码实现\",\"contents\":[\"梳理一下整个程序的执行过程\",\"页面发送ajax请求，将参数(id、status)提交到服务端\",\"服务端Controller接收页面提交的数据并调用Service更新数据\",\"Service调用Mapper操作数据库\",\"启用、禁用员工账号，本质上是一个更新操作，也就是对status状态字段进行操作，在Controller中创建update方法，此方法是一个通用的修改员工信息的方法\",\"/** * 根据id修改员工信息 * @param employee * @return */ @PutMapping public R<String> update(HttpServletRequest request,@RequestBody Employee employee){ log.info(employee.toString()); Long empId = (Long)request.getSession().getAttribute(\\\"employee\\\"); employee.setUpdateTime(LocalDateTime.now()); employee.setUpdateUser(empId); employeeService.updateById(employee); return R.success(\\\"员工信息修改成功\\\"); } \"]},{\"header\":\"4.4 功能测试\",\"slug\":\"_4-4-功能测试\",\"contents\":[\"测试过程中没有报错，但是功能并没有实现，查看数据库中的数据也没有变化，但是从控制台输出的日志，可以看出确实没有更新成功\",\"而在的数据库表结构中，并不存在该ID，数据库中风清扬对应的ID为 1420038345634918401\"]},{\"header\":\"4.5 代码修复\",\"slug\":\"_4-5-代码修复\",\"contents\":[]},{\"header\":\"4.5.1 原因分析\",\"slug\":\"_4-5-1-原因分析\",\"contents\":[\"通过观察控制台输出的SQL发现页面传递过来的员工id的值和数据库中的id值不一致，怎么回事？\",\"在分页查询时，服务端会将返回的R对象进行json序列化，转换为json格式的数据，而员工的ID是一个Long类型的数据，而且是一个长度为 19 位的长整型数据，该数据返回给前端是没有问题的\",\"那么具体的问题出现在哪儿呢？\",\"问题实际上，就出现在前端JS中，js在对长度较长的长整型数据进行处理时，会损失精度，从而导致提交的id和数据库中的id不一致\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>Title</title> <script> alert(1420038345634918401); </script> </head> <body> </body> </html> \"]},{\"header\":\"4.5.2 解决方案\",\"slug\":\"_4-5-2-解决方案\",\"contents\":[\"只需要让js处理的ID数据类型为字符串类型即可\",\"<!DOCTYPE html> <html lang=\\\"en\\\"> <head> <meta charset=\\\"UTF-8\\\"> <title>Title</title> <script> alert(\\\"1420038345634918401\\\"); </script> </head> <body> </body> </html> \",\"那么在的业务中，只需要让分页查询返回的json格式数据库中，long类型的属性，不直接转换为数字类型，转换为字符串类型就可以解决这个问题了\"]},{\"header\":\"4.5.3 代码修复\",\"slug\":\"_4-5-3-代码修复\",\"contents\":[\"由于在SpringMVC中，将Controller方法返回值转换为json对象，是通过jackson来实现的，涉及到SpringMVC中的一个消息转换器MappingJackson2HttpMessageConverter，所以要解决这个问题，就需要对该消息转换器的功能进行拓展\",\"具体实现步骤：\",\"提供对象转换器JacksonObjectMapper，基于Jackson进行Java对象到json数据的转换（直接复制到项目中使用）\",\"在WebMvcConfig配置类中扩展Spring mvc的消息转换器，在此消息转换器中使用提供的对象转换器进行Java对象到json数据的转换\",\"1.引入JacksonObjectMapper\",\"import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer; import java.math.BigInteger; import java.time.LocalDate; import java.time.LocalDateTime; import java.time.LocalTime; import java.time.format.DateTimeFormatter; import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES; /** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */ public class JacksonObjectMapper extends ObjectMapper { public static final String DEFAULT_DATE_FORMAT = \\\"yyyy-MM-dd\\\"; public static final String DEFAULT_DATE_TIME_FORMAT = \\\"yyyy-MM-dd HH:mm:ss\\\"; public static final String DEFAULT_TIME_FORMAT = \\\"HH:mm:ss\\\"; public JacksonObjectMapper() { super(); //收到未知属性时不报异常 this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); //反序列化时，属性不存在的兼容处理 this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); SimpleModule simpleModule = new SimpleModule() .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))) .addSerializer(BigInteger.class, ToStringSerializer.instance) .addSerializer(Long.class, ToStringSerializer.instance) .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); //注册功能模块 例如，可以添加自定义序列化器和反序列化器 this.registerModule(simpleModule); } } \",\"该自定义的对象转换器，主要指定了，在进行json数据序列化及反序列化时，LocalDateTime、LocalDate、LocalTime的处理方式，以及BigInteger及Long类型数据，直接转换为字符串\",\"2.在WebMvcConfig中重写方法extendMessageConverters\",\"/** * 扩展mvc框架的消息转换器 * @param converters */ @Override protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) { log.info(\\\"扩展消息转换器...\\\"); //创建消息转换器对象 MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter(); //设置对象转换器，底层使用Jackson将Java对象转为json messageConverter.setObjectMapper(new JacksonObjectMapper()); //将上面的消息转换器对象追加到mvc框架的转换器集合中 converters.add(0,messageConverter); } \"]},{\"header\":\"5. 编辑员工信息\",\"slug\":\"_5-编辑员工信息\",\"contents\":[]},{\"header\":\"5.1 需求分析\",\"slug\":\"_5-1-需求分析\",\"contents\":[\"需要实现两个方法:\",\"根据ID查询，用于页面数据回显\",\"保存修改\"]},{\"header\":\"5.2 程序执行流程\",\"slug\":\"_5-2-程序执行流程\",\"contents\":[\"点击编辑按钮时，页面跳转到add.html，并在url中携带参数[员工id]\",\"在add.html页面获取url中的参数[员工id]\",\"发送ajax请求，请求服务端，同时提交员工id参数\",\"服务端接收请求，根据员工id查询员工信息，将员工信息以json形式响应给页面\",\"页面接收服务端响应的json数据，通过VUE的数据绑定进行员工信息回显\",\"点击保存按钮，发送ajax请求，将页面中的员工信息以json方式提交给服务端\",\"服务端接收员工信息，并进行处理，完成后给页面响应\",\"页面接收到服务端响应信息后进行相应处理\",\"注意：add.html页面为公共页面，新增员工和编辑员工都是在此页面操作\"]},{\"header\":\"5.3 代码实现\",\"slug\":\"_5-3-代码实现\",\"contents\":[]},{\"header\":\"5.3.1 根据ID查询\",\"slug\":\"_5-3-1-根据id查询\",\"contents\":[\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/employee/\",\"在EmployeeController中增加方法，根据ID查询员工信息\",\"/** * 根据id查询员工信息 * @param id * @return */ @GetMapping(\\\"/{id}\\\") public R<Employee> getById(@PathVariable Long id){ log.info(\\\"根据id查询员工信息...\\\"); Employee employee = employeeService.getById(id); if(employee != null){ return R.success(employee); } return R.error(\\\"没有查询到对应员工信息\\\"); } \"]},{\"header\":\"5.3.2 修改员工\",\"slug\":\"_5-3-2-修改员工\",\"contents\":[\"请求\",\"说明\",\"请求方式\",\"PUT\",\"请求路径\",\"/employee\",\"请求参数\",\"{.......} json格式数据\",\"在EmployeeController中增加方法，根据ID更新员工信息\",\"/** * 根据id修改员工信息 * @param employee * @return */ @PutMapping public R<String> update(HttpServletRequest request,@RequestBody Employee employee){ log.info(employee.toString()); Long empId = (Long)request.getSession().getAttribute(\\\"employee\\\"); employee.setUpdateTime(LocalDateTime.now()); employee.setUpdateUser(empId); employeeService.updateById(employee); return R.success(\\\"员工信息修改成功\\\"); } \"]},{\"header\":\"5.4 功能测试\",\"slug\":\"_5-4-功能测试\",\"contents\":[\"重启工程，访问前端页面，按照前面分析的操作流程进行测试，查看数据是否正常修改即可\"]}]},\"/project/reggietakeout/01projectbasic/day03.html\":{\"title\":\"瑞吉外卖基础-Day03\",\"contents\":[{\"header\":\"1. 公共字段自动填充\",\"slug\":\"_1-公共字段自动填充\",\"contents\":[]},{\"header\":\"1.1 问题分析\",\"slug\":\"_1-1-问题分析\",\"contents\":[\"公共字段，也就是很多表中都会有这些字段\",\"在新增数据时，将 createTime、updateTime 设置为当前时间，createUser、updateUser设置为当前登录用户ID\",\"在更新数据时，将 updateTime 设置为当前时间，updateUser 设置为当前登录用户ID\",\"目前项目中处理这些字段都是在每一个业务方法中进行赋值操作\",\"能不能对于这些公共字段在某个地方统一处理，来简化开发呢？\",\"答案是可以的，Mybatis Plus有提供的公共字段自动填充功能\"]},{\"header\":\"1.2 基本功能实现\",\"slug\":\"_1-2-基本功能实现\",\"contents\":[]},{\"header\":\"1.2.1 思路分析\",\"slug\":\"_1-2-1-思路分析\",\"contents\":[\"Mybatis Plus公共字段自动填充，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码\",\"字段名\",\"赋值时机\",\"说明\",\"createTime\",\"插入(INSERT)\",\"当前时间\",\"updateTime\",\"插入(INSERT) ，更新(UPDATE)\",\"当前时间\",\"createUser\",\"插入(INSERT)\",\"当前登录用户ID\",\"updateUser\",\"插入(INSERT) ，更新(UPDATE)\",\"当前登录用户ID\",\"实现步骤：\",\"在实体类的属性上加入@TableField注解，指定自动填充的策略\",\"按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口\"]},{\"header\":\"1.2.2 代码实现\",\"slug\":\"_1-2-2-代码实现\",\"contents\":[\"1.实体类的属性上加入@TableField注解，指定自动填充的策略\",\"FieldFill.INSERT: 插入时填充该属性值\",\"FieldFill.INSERT_UPDATE: 插入/更新时填充该属性值\",\"2.按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口\",\"所属包: com.itheima.reggie.common\",\"import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.time.LocalDateTime; /** * 自定义元数据对象处理器 */ @Component @Slf4j public class MyMetaObjecthandler implements MetaObjectHandler { /** * 插入操作，自动填充 * @param metaObject */ @Override public void insertFill(MetaObject metaObject) { log.info(\\\"公共字段自动填充[insert]...\\\"); log.info(metaObject.toString()); metaObject.setValue(\\\"createTime\\\",LocalDateTime.now()); metaObject.setValue(\\\"updateTime\\\",LocalDateTime.now()); metaObject.setValue(\\\"createUser\\\",new Long(1)); metaObject.setValue(\\\"updateUser\\\",new Long(1)); } /** * 更新操作，自动填充 * @param metaObject */ @Override public void updateFill(MetaObject metaObject) { log.info(\\\"公共字段自动填充[update]...\\\"); log.info(metaObject.toString()); metaObject.setValue(\\\"updateTime\\\",LocalDateTime.now()); metaObject.setValue(\\\"updateUser\\\",new Long(1)); } } \"]},{\"header\":\"1.2.3 功能测试\",\"slug\":\"_1-2-3-功能测试\",\"contents\":[\"将之前在新增和修改方法中手动赋值的代码删除或注释掉\",\"启动项目，在员工管理模块中，测试增加/更新员工信息功能，然后通过debug或者直接查询数据库数据变更的形式，看看是否能够完成自动填充\"]},{\"header\":\"1.3 功能完善\",\"slug\":\"_1-3-功能完善\",\"contents\":[]},{\"header\":\"1.3.1 思路分析\",\"slug\":\"_1-3-1-思路分析\",\"contents\":[\"自动填充createUser和updateUser时设置的用户id是固定值，现在需要改成动态获取当前登录用户的id\",\"大家可能想到，用户登录成功后，将用户id存入了HttpSession中，从HttpSession中获取不就行了？\",\"注意，MyMetaObjectHandler类中是不能直接获得HttpSession对象的\",\"在修改员工信息时，业务的执行流程\",\"客户端发送的每次http请求，对应的在服务端都会分配一个新的线程来处理，在处理过程中涉及到下面类中的方法都属于相同的一个线程\",\"LoginCheckFilter的 doFilter 方法\",\"EmployeeController的 update 方法\",\"MyMetaObjectHandler的 updateFill 方法\",\"可以在上述类的方法中加入如下代码(获取当前线程ID，并输出)\",\"long id = Thread.currentThread().getId(); log.info(\\\"线程id为：{}\\\",id); \",\"经过上述分析，发现可以使用JDK提供的一个类，来解决此问题，它是JDK中提供的ThreadLocal\"]},{\"header\":\"1.3.2 ThreadLocal\",\"slug\":\"_1-3-2-threadlocal\",\"contents\":[\"ThreadLocal并不是一个Thread，而是Thread的局部变量\",\"当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本\",\"ThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问当前线程对应的值\",\"ThreadLocal常用方法\",\"public void set(T value) : 设置当前线程的线程局部变量的值\",\"public T get() : 返回当前线程所对应的线程局部变量的值\",\"public void remove() : 删除当前线程所对应的线程局部变量的值\",\"可以在LoginCheckFilter的doFilter方法中获取当前登录用户id，并调用ThreadLocal的set方法来设置当前线程的线程局部变量的值（用户id），然后在MyMetaObjectHandler的updateFill方法中调用ThreadLocal的get方法来获得当前线程所对应的线程局部变量的值（用户id） 如果在后续的操作中， 需要在Controller / Service中要使用当前登录用户的ID，可以直接从ThreadLocal直接获取\"]},{\"header\":\"1.3.3 操作步骤\",\"slug\":\"_1-3-3-操作步骤\",\"contents\":[\"编写BaseContext工具类，基于ThreadLocal封装的工具类\",\"在LoginCheckFilter的doFilter方法中调用BaseContext来设置当前登录用户的id\",\"在MyMetaObjectHandler的方法中调用BaseContext获取登录用户的id\"]},{\"header\":\"1.3.4 代码实现\",\"slug\":\"_1-3-4-代码实现\",\"contents\":[\"1.BaseContext工具类\",\"所属包: com.itheima.reggie.common\",\"/** * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户id */ public class BaseContext { private static ThreadLocal<Long> threadLocal = new ThreadLocal<>(); /** * 设置值 * @param id */ public static void setCurrentId(Long id){ threadLocal.set(id); } /** * 获取值 * @return */ public static Long getCurrentId(){ return threadLocal.get(); } } \",\"2.LoginCheckFilter中存放当前登录用户到ThreadLocal\",\"在doFilter方法中，判定用户是否登录，如果用户登录，在放行之前，获取HttpSession中的登录用户信息，调用BaseContext的setCurrentId方法将当前登录用户ID存入ThreadLocal\",\"Long empId = (Long) request.getSession().getAttribute(\\\"employee\\\"); BaseContext.setCurrentId(empId); \",\"3.MyMetaObjectHandler中从ThreadLocal中获取\",\"将之前在代码中固定的当前登录用户1， 修改为动态调用BaseContext中的getCurrentId方法获取当前登录用户ID\"]},{\"header\":\"1.3.5 功能测试\",\"slug\":\"_1-3-5-功能测试\",\"contents\":[\"重启项目，在员工管理模块中，测试增加/更新员工信息功能，直接查询数据库数据变更，查看这些公共字段数据是否能够完成自动填充，并且看看填充的create_user 及 update_user字段值是不是本地登录用户的ID\"]},{\"header\":\"2. 新增分类\",\"slug\":\"_2-新增分类\",\"contents\":[]},{\"header\":\"2.1 需求分析\",\"slug\":\"_2-1-需求分析\",\"contents\":[\"后台系统中可以管理分类信息，分类包括两种类型，分别是 菜品分类 和 套餐分类 在后台系统中添加菜品时需要选择一个菜品分类，移动端会按照菜品分类和套餐分类来展示对应的菜品和套餐\",\"在分类管理中，新增分类时，可以选择新增菜品分类(川菜、湘菜、粤菜...)，也可以选择新增套餐分类(营养早餐、超值午餐...) 在添加套餐的时候，输入的排序字段，控制的是移动端套餐列表的展示顺序\"]},{\"header\":\"2.2 数据模型\",\"slug\":\"_2-2-数据模型\",\"contents\":[\"新增分类，其实就是将新增窗口录入的分类数据，插入到category表\",\"添加的套餐名称，是唯一的，不能够重复的\"]},{\"header\":\"2.3 前端页面分析\",\"slug\":\"_2-3-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下整个程序的执行过程：\",\"在页面(backend/page/category/list.html)的新增分类表单中填写数据，点击 \\\"确定\\\" 发送ajax请求，将新增分类窗口输入的数据以json形式提交到服务端\",\"服务端Controller接收页面提交的数据并调用Service将数据进行保存\",\"Service调用Mapper操作数据库，保存数据\",\"可以看到新增菜品分类和新增套餐分类请求的服务端地址和提交的json数据结构相同，所以服务端只需要提供一个方法统一处理即可\",\"请求\",\"说明\",\"请求方式\",\"POST\",\"请求路径\",\"/category\",\"请求参数\",\"json格式 - {\\\"name\\\":\\\"川菜\\\", \\\"type\\\":\\\"1\\\", \\\"sort\\\":2}\"]},{\"header\":\"2.4 代码实现\",\"slug\":\"_2-4-代码实现\",\"contents\":[\"代码实现的具体步骤如下\",\"实体类Category\",\"Mapper接口CategoryMapper\",\"业务层接口CategoryService\",\"业务层实现类CategoryServiceImpl\",\"控制层CategoryController\",\"1.实体类Category\",\"所属包: com.itheima.reggie.entity\",\"import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import lombok.Data; import java.io.Serializable; import java.time.LocalDateTime; /** * 分类 */ @Data public class Category implements Serializable { private static final long serialVersionUID = 1L; private Long id; //类型 1 菜品分类 2 套餐分类 private Integer type; //分类名称 private String name; //顺序 private Integer sort; //创建时间 @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; //更新时间 @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; //创建人 @TableField(fill = FieldFill.INSERT) private Long createUser; //修改人 @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; } \",\"2.Mapper接口CategoryMapper\",\"所属包: com.itheima.reggie.mapper\",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.Category; import org.apache.ibatis.annotations.Mapper; @Mapper public interface CategoryMapper extends BaseMapper<Category> { } \",\"3.业务层接口CategoryService\",\"所属包: com.itheima.reggie.service\",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.Category; public interface CategoryService extends IService<Category> { } \",\"4.业务层实现类CategoryServiceImpl\",\"所属包: com.itheima.reggie.service.impl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.Category; import com.itheima.reggie.mapper.CategoryMapper; import com.itheima.reggie.service.CategoryService; import org.springframework.stereotype.Service; @Service public class CategoryServiceImpl extends ServiceImpl<CategoryMapper,Category> implements CategoryService{ } \",\"5.控制层CategoryController\",\"import com.itheima.reggie.common.R; import com.itheima.reggie.entity.Category; import com.itheima.reggie.service.CategoryService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * 分类管理 */ @RestController @RequestMapping(\\\"/category\\\") @Slf4j public class CategoryController { @Autowired private CategoryService categoryService; /** * 新增分类 * @param category * @return */ @PostMapping public R<String> save(@RequestBody Category category){ log.info(\\\"category:{}\\\",category); categoryService.save(category); return R.success(\\\"新增分类成功\\\"); } } \"]},{\"header\":\"2.5 功能测试\",\"slug\":\"_2-5-功能测试\",\"contents\":[\"进入管理系统访问分类管理，然后进行新增分类测试，需要将所有情况都覆盖全\",\"输入的分类名称不存在\",\"输入已存在的分类名称\",\"新增菜品分类\",\"新增套餐分类\"]},{\"header\":\"3. 分类信息分页查询\",\"slug\":\"_3-分类信息分页查询\",\"contents\":[]},{\"header\":\"3.1 需求分析\",\"slug\":\"_3-1-需求分析\",\"contents\":[\"一般的系统中都会以分页的方式来展示列表数据\"]},{\"header\":\"3.2 前端页面分析\",\"slug\":\"_3-2-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下整个程序的执行过程：\",\"页面发送ajax请求，将分页查询参数(page、pageSize)提交到服务端\",\"服务端Controller接收页面提交的数据并调用Service查询数据\",\"Service调用Mapper操作数据库，查询分页数据\",\"Controller将查询到的分页数据响应给页面\",\"页面接收到分页数据并通过ElementUI的Table组件展示到页面上\",\"页面加载时，就会触发Vue声明周期的钩子方法，然后执行分页查询，发送异步请求到服务端\",\"页面中使用的是ElementUI提供的分页组件进行分页条的展示\",\"通过浏览器，也可以抓取到分页查询的请求信息\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/category/page\",\"请求参数\",\"?page=1&pageSize=10\"]},{\"header\":\"3.3 代码实现\",\"slug\":\"_3-3-代码实现\",\"contents\":[\"/** * 分页查询 * @param page * @param pageSize * @return */ @GetMapping(\\\"/page\\\") public R<Page> page(int page,int pageSize){ //分页构造器 Page<Category> pageInfo = new Page<>(page,pageSize); //条件构造器 LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>(); //添加排序条件，根据sort进行排序 queryWrapper.orderByAsc(Category::getSort); //分页查询 categoryService.page(pageInfo,queryWrapper); return R.success(pageInfo); } \"]},{\"header\":\"3.4 功能测试\",\"slug\":\"_3-4-功能测试\",\"contents\":[\"点击分类管理，查询分类列表是否可以正常展示，测试过程中可以使用浏览器的监控工具查看页面和服务端的数据交互细节\",\"测试完毕后，会发现查询数据库返回的类型为 1 或者 2，但是实际展示到页面上的却是 \\\"菜品分类\\\" 或 \\\"套餐分类\\\"，这一块是在前端页面中进行处理的，处理代码如下\"]},{\"header\":\"4. 删除分类\",\"slug\":\"_4-删除分类\",\"contents\":[]},{\"header\":\"4.1 需求分析\",\"slug\":\"_4-1-需求分析\",\"contents\":[\"在分类管理列表页面，可以对某个分类进行删除操作 需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除\"]},{\"header\":\"4.2 前端页面分析\",\"slug\":\"_4-2-前端页面分析\",\"contents\":[\"在前端页面中，点击 \\\"删除\\\" 按钮，就会触发定义的方法，然后往服务端发送异步请求，并传递参数id，执行删除分类操作\",\"删除操作的具体执行流程如下\",\"点击删除，页面发送ajax请求，将参数(id)提交到服务端\",\"服务端Controller接收页面提交的数据并调用Service删除数据\",\"Service调用Mapper操作数据库\",\"请求\",\"说明\",\"请求方式\",\"DELETE\",\"请求路径\",\"/category\",\"请求参数\",\"?id=1395291114922618881\"]},{\"header\":\"4.3 代码实现\",\"slug\":\"_4-3-代码实现\",\"contents\":[\"在CategoryController中增加根据ID删除的方法，在方法中接收页面传递参数id，然后执行删除操作\",\"/** * 根据id删除分类 * @param id * @return */ @DeleteMapping public R<String> delete(Long id){ log.info(\\\"删除分类，id为：{}\\\",id); categoryService.removeById(id); return R.success(\\\"分类信息删除成功\\\"); } \"]},{\"header\":\"4.4 功能测试\",\"slug\":\"_4-4-功能测试\",\"contents\":[\"重启项目，可以通过debug断点调试进行测试，同时结合浏览器监控工具查看请求和响应的具体数据\"]},{\"header\":\"4.5 功能完善\",\"slug\":\"_4-5-功能完善\",\"contents\":[]},{\"header\":\"4.5.1 思路分析\",\"slug\":\"_4-5-1-思路分析\",\"contents\":[\"上述测试中，看到分类数据是可以正常删除的，但是并没有检查删除的分类是否关联了菜品或者套餐，所以需要进行功能完善，完善后的逻辑为\",\"根据当前分类的ID，查询该分类下是否存在菜品，如果存在，则提示错误信息\",\"根据当前分类的ID，查询该分类下是否存在套餐，如果存在，则提示错误信息\",\"执行正常的删除分类操作\",\"那么在这里又涉及到后面要用到的两张表结构 dish(菜品表) 和 setmeal(套餐表) 具体的表结构\"]},{\"header\":\"4.5.2 准备工作\",\"slug\":\"_4-5-2-准备工作\",\"contents\":[\"1.准备菜品(Dish)及套餐(Setmeal)实体类(课程资料中直接拷贝)\",\"所属包: com.itheima.reggie.entity\",\"import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import lombok.Data; import java.io.Serializable; import java.math.BigDecimal; import java.time.LocalDateTime; /** 菜品 */ @Data public class Dish implements Serializable { private static final long serialVersionUID = 1L; private Long id; //菜品名称 private String name; //菜品分类id private Long categoryId; //菜品价格 private BigDecimal price; //商品码 private String code; //图片 private String image; //描述信息 private String description; //0 停售 1 起售 private Integer status; //顺序 private Integer sort; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; } \",\"import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import lombok.Data; import java.io.Serializable; import java.math.BigDecimal; import java.time.LocalDateTime; /** * 套餐 */ @Data public class Setmeal implements Serializable { private static final long serialVersionUID = 1L; private Long id; //分类id private Long categoryId; //套餐名称 private String name; //套餐价格 private BigDecimal price; //状态 0:停用 1:启用 private Integer status; //编码 private String code; //描述信息 private String description; //图片 private String image; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; } \",\"2.Mapper接口DishMapper和SetmealMapper\",\"所属包: com.itheima.reggie.mapper\",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.Dish; import org.apache.ibatis.annotations.Mapper; @Mapper public interface DishMapper extends BaseMapper<Dish> { } \",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.Setmeal; import org.apache.ibatis.annotations.Mapper; @Mapper public interface SetmealMapper extends BaseMapper<Setmeal> { } \",\"3.Service接口DishService和SetmealService\",\"所属包: com.itheima.reggie.service\",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.Dish; public interface DishService extends IService<Dish> { } \",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.Setmeal; public interface SetmealService extends IService<Setmeal> { } \",\"4.Service实现类DishServiceImpl和SetmealServiceImpl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.Dish; import com.itheima.reggie.mapper.DishMapper; import com.itheima.reggie.service.DishService; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; @Service @Slf4j public class DishServiceImpl extends ServiceImpl<DishMapper,Dish> implements DishService { } \",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.Setmeal; import com.itheima.reggie.mapper.SetmealMapper; import com.itheima.reggie.service.SetmealService; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; @Service @Slf4j public class SetmealServiceImpl extends ServiceImpl<SetmealMapper,Setmeal> implements SetmealService { } \"]},{\"header\":\"4.5.3 代码实现\",\"slug\":\"_4-5-3-代码实现\",\"contents\":[\"1.创建自定义异常\",\"在业务逻辑操作过程中，如果遇到一些业务参数、操作异常的情况下，直接抛出此异常\",\"所在包: com.itheima.reggie.common\",\"/** * 自定义业务异常类 */ public class CustomException extends RuntimeException { public CustomException(String message){ super(message); } } \",\"2.在CategoryService中扩展remove方法\",\"public interface CategoryService extends IService<Category> { //根据ID删除分类 public void remove(Long id); } \",\"3.在CategoryServiceImpl中实现remove方法\",\"@Autowired private DishService dishService; @Autowired private SetmealService setmealService; /** * 根据id删除分类，删除之前需要进行判断 * @param id */ @Override public void remove(Long id) { //添加查询条件，根据分类id进行查询菜品数据 LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<>(); dishLambdaQueryWrapper.eq(Dish::getCategoryId,id); int count1 = dishService.count(dishLambdaQueryWrapper); //如果已经关联，抛出一个业务异常 if(count1 > 0){ throw new CustomException(\\\"当前分类下关联了菜品，不能删除\\\");//已经关联菜品，抛出一个业务异常 } //查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常 LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>(); setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id); int count2 = setmealService.count(setmealLambdaQueryWrapper); if(count2 > 0){ throw new CustomException(\\\"当前分类下关联了套餐，不能删除\\\");//已经关联套餐，抛出一个业务异常 } //正常删除分类 super.removeById(id); } \",\"那么在上述的业务逻辑中，当分类下关联的有菜品或者套餐时，在业务代码中抛出了自定义异常，并且在异常中封装了错误提示信息，那这个错误提示信息如何提示给页面呢？\",\"异常抛出之后，会被异常处理器捕获，只需要在异常处理器中捕获这一类的异常，然后给页面返回对应的提示信息即可\",\"4.在GlobalExceptionHandler中处理自定义异常\",\"在全局异常处理器中增加方法，用于捕获自定义的异常 CustomException\",\"/** * 异常处理方法 * @return */ @ExceptionHandler(CustomException.class) public R<String> exceptionHandler(CustomException ex){ log.error(ex.getMessage()); return R.error(ex.getMessage()); } \",\"5.改造CategoryController的delete方法\",\"注释掉原有的代码，在delete方法中直接调用categoryService中 自定义的remove方法\",\"/** * 根据id删除分类 * @param id * @return */ @DeleteMapping public R<String> delete(Long id){ log.info(\\\"删除分类，id为：{}\\\",id); //categoryService.removeById(id); categoryService.remove(id); return R.success(\\\"分类信息删除成功\\\"); } \"]},{\"header\":\"4.5.4 功能测试\",\"slug\":\"_4-5-4-功能测试\",\"contents\":[\"进入管理系统访问分类管理，然后进行删除分类的测试，需要将所有情况都覆盖全\",\"新增一个分类，然后再直接删除，检查是否可以正常删除成功 (新增的分类时没有关联菜品和套餐的)\",\"在数据库表(dish/setmeal)中，找到一个与菜品或套餐关联的分类，然后在页面中执行删除操作，检查是否可以正常的提示出对应的错误信息\"]},{\"header\":\"5. 修改分类\",\"slug\":\"_5-修改分类\",\"contents\":[]},{\"header\":\"5.1 需求分析\",\"slug\":\"_5-1-需求分析\",\"contents\":[\"在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口会显分类信息并进行修改，最后点击确定按钮完成修改操作\"]},{\"header\":\"5.2 前端页面分析\",\"slug\":\"_5-2-前端页面分析\",\"contents\":[\"修改功能还没有实现，但是当点击 \\\"修改\\\" 按钮的时候，并没有开发根据ID查询数据，进行页面回显的功能，但是页面的分类数据确实回显回来了\",\"那么回显这一步的操作前端已经实现，就只需要开发一个方法，修改操作的方法即可\",\"请求\",\"说明\",\"请求方式\",\"PUT\",\"请求路径\",\"/category\",\"请求参数\",\"{id: \\\"1399923597874081794\\\",name: \\\"超值午餐\\\",sort: 0}\"]},{\"header\":\"5.3 代码实现\",\"slug\":\"_5-3-代码实现\",\"contents\":[\"创建服务端的CategoryController方法update方法\",\"/** * 根据id修改分类信息 * @param category * @return */ @PutMapping public R<String> update(@RequestBody Category category){ log.info(\\\"修改分类信息：{}\\\",category); categoryService.updateById(category); return R.success(\\\"修改分类信息成功\\\"); } \"]},{\"header\":\"5.4 功能测试\",\"slug\":\"_5-4-功能测试\",\"contents\":[\"按照前面分析的操作流程进行测试，查看数据是否正常修改即可\"]}]},\"/project/reggietakeout/01projectbasic/day04.html\":{\"title\":\"瑞吉外卖基础-Day04\",\"contents\":[{\"header\":\"1. 文件上传下载\",\"slug\":\"_1-文件上传下载\",\"contents\":[]},{\"header\":\"1.1 上传介绍\",\"slug\":\"_1-1-上传介绍\",\"contents\":[]},{\"header\":\"1.1.1 概述\",\"slug\":\"_1-1-1-概述\",\"contents\":[\"文件上传，也称为upload，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程\",\"文件上传时，对页面的form表单有如下要求：\",\"表单属性\",\"取值\",\"说明\",\"method\",\"post\",\"必须选择post方式提交\",\"enctype\",\"multipart/form-data\",\"采用multipart格式上传文件\",\"type\",\"file\",\"使用input的file控件上传\"]},{\"header\":\"1.1.2 前端介绍\",\"slug\":\"_1-1-2-前端介绍\",\"contents\":[\"简单html页面表单\",\"<form method=\\\"post\\\" action=\\\"/common/upload\\\" enctype=\\\"multipart/form-data\\\"> <input name=\\\"myFile\\\" type=\\\"file\\\" /> <input type=\\\"submit\\\" value=\\\"提交\\\" /> </form> \",\"ElementUI中提供的upload上传组件\",\"目前一些前端组件库也提供了相应的上传组件，但是底层原理还是基于form表单的文件上传\"]},{\"header\":\"1.1.3 服务端介绍\",\"slug\":\"_1-1-3-服务端介绍\",\"contents\":[\"服务端要接收客户端页面上传的文件，通常都会使用Apache的两个组件：\",\"commons-fileupload\",\"commons-io\",\"而Spring框架在spring-web包中对文件上传进行了封装，大大简化了服务端代码，只需要在Controller的方法中声明一个MultipartFile类型的参数即可接收上传的文件\",\"/** * 文件上传 * @param file * @return */ @PostMapping(\\\"/upload\\\") public R<String> upload(MultipartFile file){ System.out.println(file); return R.success(fileName); } \"]},{\"header\":\"1.2 下载介绍\",\"slug\":\"_1-2-下载介绍\",\"contents\":[\"文件下载，也称为download，是指将文件从服务器传输到本地计算机的过程 通过浏览器进行文件下载，通常有两种表现形式\",\"以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录\",\"直接在浏览器中打开\",\"今天所需要实现的菜品展示，表现形式为在浏览器中直接打开\",\"通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程\"]},{\"header\":\"1.3 上传代码实现\",\"slug\":\"_1-3-上传代码实现\",\"contents\":[]},{\"header\":\"1.3.1 前端代码\",\"slug\":\"_1-3-1-前端代码\",\"contents\":[\"使用资料中提供的上传页面，位置：资料/文件上传下载页面/upload.html，将其拷贝到项目的目录(resources/backend/page/demo)下，启动项目，访问上传页面\",\"http://localhost:8080/backend/page/demo/upload.html\",\"在上述的浏览器抓取的网络请求中，上传文件的调用url，在哪里配置的呢，需要去看一下前端上传组件\",\"虽然上述是ElementUI封装的代码，但是实际上最终还通过file域上传文件，如果未指定上传文件的参数名，默认为file\"]},{\"header\":\"1.3.2 服务端实现\",\"slug\":\"_1-3-2-服务端实现\",\"contents\":[\"application.yml\",\"需要在application.yml中定义文件存储路径\",\"reggie: path: D:\\\\img\\\\ \",\"CommonController\",\"编写文件上传的方法，通过MultipartFile类型的参数即可接收上传的文件，方法形参的名称需要与页面的file域的name属性一致\",\"所在包: com.itheima.reggie.controller\",\"上传逻辑\",\"获取文件的原始文件名，通过原始文件名获取文件后缀\",\"通过UUID重新声明文件名，防止文件名称重复造成文件覆盖\",\"创建文件存放目录\",\"将上传的临时文件转存到指定位置\",\"代码实现:\",\"import com.itheima.reggie.common.R; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import java.io.File; import java.util.UUID; /** * 文件上传和下载 */ @RestController @RequestMapping(\\\"/common\\\") @Slf4j public class CommonController { @Value(\\\"${reggie.path}\\\") private String basePath; /** * 文件上传 * @param file * @return */ @PostMapping(\\\"/upload\\\") public R<String> upload(MultipartFile file){ //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除 log.info(file.toString()); //原始文件名 String originalFilename = file.getOriginalFilename();//abc.jpg String suffix = originalFilename.substring(originalFilename.lastIndexOf(\\\".\\\")); //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖 String fileName = UUID.randomUUID().toString() + suffix;//dfsdfdfd.jpg //创建一个目录对象 File dir = new File(basePath); //判断当前目录是否存在 if(!dir.exists()){ //目录不存在，需要创建 dir.mkdirs(); } try { //将临时文件转存到指定位置 file.transferTo(new File(basePath + fileName)); } catch (IOException e) { e.printStackTrace(); } return R.success(fileName); } } \"]},{\"header\":\"1.3.3 测试\",\"slug\":\"_1-3-3-测试\",\"contents\":[\"访问上传页面 http://localhost:8080/backend/page/demo/upload.html，然后点击上传图片，选择图片上传时，会发现图片并不能正常的上传，而且在浏览器中可以抓取到响应的数据，从图中可以判断出需要登录才可以操作\",\"这样的话，就要求在测试时，每一次都需要先登录，登录完成后在进行图片上传的测试，为了简化的测试，可以在 LoginCheckFilter 的doFilter方法中，在不需要处理的请求路径的数组中再加入请求路径 /common/**\",\"在测试文件上传时，可以通过debug的形式来跟踪上传的整个过程，验证一下临时文件是否存在，以及上传完成之后，临时文件是否会自动删除\"]},{\"header\":\"1.4 下载代码实现\",\"slug\":\"_1-4-下载代码实现\",\"contents\":[]},{\"header\":\"1.4.1 前端代码\",\"slug\":\"_1-4-1-前端代码\",\"contents\":[\"文件下载，前端页面可以使用<img>标签展示下载的图片\",\"<img v-if=\\\"imageUrl\\\" :src=\\\"imageUrl\\\" class=\\\"avatar\\\"></img> \",\"通过<img>标签如何展示图片数据呢\",\"在文件上传成功后，在 handleAvatarSuccess 方法中获取文件上传成功之后返回的数据(文件名)，然后调用 /common/download?name=xxx 进行文件的下载 想让上传的照片能够在页面展示出来，需要在服务端将文件以流的形式写回浏览器\"]},{\"header\":\"1.4.2 服务端代码\",\"slug\":\"_1-4-2-服务端代码\",\"contents\":[\"在 CommonController 中定义方法download，并接收页面传递的参数name，然后读取图片文件的数据，然后以流的形式写回浏览器\",\"具体逻辑\",\"定义输入流，通过输入流读取文件内容\",\"通过response对象，获取到输出流\",\"通过response对象设置响应数据格式(image/jpeg)\",\"通过输入流读取文件数据，然后通过上述的输出流写回浏览器\",\"关闭资源\",\"代码实现:\",\"/** * 文件下载 * @param name * @param response */ @GetMapping(\\\"/download\\\") public void download(String name,HttpServletResponse response){ try { //输入流，通过输入流读取文件内容 FileInputStream fileInputStream = new FileInputStream(new File(basePath + name)); //输出流，通过输出流将文件写回浏览器 ServletOutputStream outputStream = response.getOutputStream(); response.setContentType(\\\"image/jpeg\\\"); int len = 0; byte[] bytes = new byte[1024]; while ((len = fileInputStream.read(bytes)) != -1){ outputStream.write(bytes,0,len); outputStream.flush(); } //关闭资源 outputStream.close(); fileInputStream.close(); } catch (Exception e) { e.printStackTrace(); } } \"]},{\"header\":\"1.4.3 测试\",\"slug\":\"_1-4-3-测试\",\"contents\":[\"访问页面 http://localhost:8080/backend/page/demo/upload.html ，点击上传图片 ，选择图片进行上传，上传完毕之后，查看图片是否可以展示出来\",\" 通过F12查询页面发起的请求及响应的数据：\"]},{\"header\":\"2. 菜品新增\",\"slug\":\"_2-菜品新增\",\"contents\":[]},{\"header\":\"2.1 需求分析\",\"slug\":\"_2-1-需求分析\",\"contents\":[\"后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品，在添加菜品时需要选择当前菜品所属的菜品分类，并且需要上传菜品图片，在移动端会按照菜品分类来展示对应的菜品信息\"]},{\"header\":\"2.2 数据模型\",\"slug\":\"_2-2-数据模型\",\"contents\":[\"新增菜品，其实就是将新增页面录入的菜品信息插入到dish表，如果添加了口味做法，还需要向dish_flavor表插入数据。所以在新增菜品时，涉及到两个表：\",\"表结构\",\"说明\",\"dish\",\"菜品表\",\"dish_flavor\",\"菜品口味表\",\"菜品表:dish\",\"菜品口味表:dish_flavor\"]},{\"header\":\"2.3 准备工作\",\"slug\":\"_2-3-准备工作\",\"contents\":[\"在开发业务功能前，先将需要用到的类和接口基本结构创建好\",\"1.实体类 DishFlavor\",\"所属包: com.itheima.reggie.entity\",\"import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import lombok.Data; import java.io.Serializable; import java.time.LocalDateTime; /** 菜品口味 */ @Data public class DishFlavor implements Serializable { private static final long serialVersionUID = 1L; private Long id; //菜品id private Long dishId; //口味名称 private String name; //口味数据list private String value; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; //是否删除 private Integer isDeleted; } \",\"2.Mapper接口DishFlavorMapper\",\"所属包: com.itheima.reggie.mapper\",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.DishFlavor; import org.apache.ibatis.annotations.Mapper; @Mapper public interface DishFlavorMapper extends BaseMapper<DishFlavor> { } \",\"3.业务层接口 DishFlavorService\",\"所属包: com.itheima.reggie.service\",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.DishFlavor; public interface DishFlavorService extends IService<DishFlavor> { } \",\"4.业务层实现类 DishFlavorServiceImpl\",\"所属包: com.itheima.reggie.service.impl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.DishFlavor; import com.itheima.reggie.mapper.DishFlavorMapper; import com.itheima.reggie.service.DishFlavorService; import org.springframework.stereotype.Service; @Service public class DishFlavorServiceImpl extends ServiceImpl<DishFlavorMapper,DishFlavor> implements DishFlavorService { } \",\"5.控制层 DishController\",\"菜品及菜品口味的相关操作，统一使用这一个controller即可\",\"所属包： com.itheima.reggie.controller\",\"import com.itheima.reggie.service.DishFlavorService; import com.itheima.reggie.service.DishService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * 菜品管理 */ @RestController @RequestMapping(\\\"/dish\\\") @Slf4j public class DishController { @Autowired private DishService dishService; @Autowired private DishFlavorService dishFlavorService; } \"]},{\"header\":\"2.4 前端页面分析\",\"slug\":\"_2-4-前端页面分析\",\"contents\":[\"接下来实现新增菜品功能，在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程\",\"1.点击新建菜品按钮，访问页面(backend/page/food/add.html)，页面加载时发送ajax请求，请求服务端获取菜品分类数据并展示到下拉框中\",\"2.页面发送请求进行图片上传，请求服务端将图片保存到服务器(上传功能已实现)\",\"3.页面发送请求进行图片下载，将上传的图片进行回显(下载功能已实现)\",\"4.点击保存按钮，发送ajax请求，将菜品相关数据以json形式提交到服务端\",\"页面代码:\",\"浏览器抓取请求:\",\"开发新增菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求(上传、下载已实现)即可 经过上述的分析，还需要在服务端实现两块功能\",\"A. 菜品分类数据列表查询\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/category/list\",\"请求参数\",\"?type=1\",\"B. 保存菜品信息\",\"请求\",\"说明\",\"请求方式\",\"POST\",\"请求路径\",\"/dish\",\"请求参数\",\"json格式\"]},{\"header\":\"2.5 代码实现\",\"slug\":\"_2-5-代码实现\",\"contents\":[]},{\"header\":\"2.5.1 菜品分类查询\",\"slug\":\"_2-5-1-菜品分类查询\",\"contents\":[\"在CategoryController中增加方法实现菜品分类查询，根据分类进行查询，并对查询的结果按照sort排序字段进行升序排序，如果sort相同，再按照修改时间倒序排序\",\"/** * 根据条件查询分类数据 * @param category * @return */ @GetMapping(\\\"/list\\\") public R<List<Category>> list(Category category){ //条件构造器 LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>(); //添加条件 queryWrapper.eq(category.getType() != null,Category::getType,category.getType()); //添加排序条件 queryWrapper.orderByAsc(Category::getSort).orderByDesc(Category::getUpdateTime); List<Category> list = categoryService.list(queryWrapper); return R.success(list); } \",\"代码编写完毕之后，可以打开新增菜品页面，查看响应的数据，及页面下拉列表的渲染情况：\"]},{\"header\":\"2.5.3 保存菜品信息\",\"slug\":\"_2-5-3-保存菜品信息\",\"contents\":[\"在上述的分析中，可以看到在保存菜品时，页面传递过来的是json格式数据\",\"{ \\\"name\\\":\\\"佛跳墙\\\", \\\"price\\\":88800, \\\"code\\\":\\\"\\\", \\\"image\\\":\\\"da9e1c70-fc32-4781-9510-a1c4ccd2ff59.jpg\\\", \\\"description\\\":\\\"佛跳墙\\\", \\\"status\\\":1, \\\"categoryId\\\":\\\"1397844357980663809\\\", \\\"flavors\\\":[ { \\\"name\\\":\\\"辣度\\\", \\\"value\\\":\\\"[\\\\\\\"不辣\\\\\\\",\\\\\\\"微辣\\\\\\\",\\\\\\\"中辣\\\\\\\",\\\\\\\"重辣\\\\\\\"]\\\", \\\"showOption\\\":false }, { \\\"name\\\":\\\"忌口\\\", \\\"value\\\":\\\"[\\\\\\\"不要葱\\\\\\\",\\\\\\\"不要蒜\\\\\\\",\\\\\\\"不要香菜\\\\\\\",\\\\\\\"不要辣\\\\\\\"]\\\", \\\"showOption\\\":false } ] } \",\"在服务端应该如何来封装前端传递的数据呢，如果使用菜品类Dish来封装，只能封装菜品的基本属性，flavors属性是无法封装的\",\"这个时候，需要自定义一个实体类，然后继承自Dish，并对Dish的属性进行拓展，增加 flavors 集合属性(内部封装DishFlavor)\",\"1.导入 DishDto 实体类\",\"封装页面传递的请求参数\",\"所属包: com.itheima.reggie.dto\",\"import com.itheima.reggie.entity.Dish; import com.itheima.reggie.entity.DishFlavor; import lombok.Data; import java.util.ArrayList; import java.util.List; @Data public class DishDto extends Dish { private List<DishFlavor> flavors = new ArrayList<>(); private String categoryName; private Integer copies; } \",\"拓展：在做项目时，经常会涉及到各种类型的实体模型 基本包含以下几种\",\"实体模型\",\"描述\",\"DTO\",\"Data Transfer Object(数据传输对象)，一般用于展示层与服务层之间的数据传输\",\"Entity\",\"最常用实体类，基本和数据表一一对应，一个实体类对应一张表\",\"VO\",\"Value Object(值对象)，主要用于封装前端页面展示的数据对象，用一个VO对象来封装整个页面展示所需要的对象数据\",\"PO\",\"Persistant Object(持久层对象)，是ORM(Objevt Relational Mapping)框架中Entity，PO属性和数据库中表的字段形成一一对应关系\",\"2.DishController定义方法新增菜品\",\"在该Controller的方法中，不仅需要保存菜品的基本信息，还需要保存菜品的口味信息，需要操作两张表，所以需要在DishService接口中定义接口方法，在这个方法中需要保存上述的两部分数据\",\"/** * 新增菜品 * @param dishDto * @return */ @PostMapping public R<String> save(@RequestBody DishDto dishDto){ log.info(dishDto.toString()); dishService.saveWithFlavor(dishDto); return R.success(\\\"新增菜品成功\\\"); } \",\"3.DishService中增加方法saveWithFlavor\",\"//新增菜品，同时插入菜品对应的口味数据，需要操作两张表：dish、dish_flavor public void saveWithFlavor(DishDto dishDto); \",\"4.DishServiceImpl中实现方法saveWithFlavor\",\"页面传递的菜品口味信息，仅仅包含name 和 value属性，缺少一个非常重要的属性dishId， 所以在保存完菜品的基本信息后，需要获取到菜品ID，然后为菜品口味对象属性dishId赋值\",\"具体逻辑\",\"保存菜品基本信息\",\"获取保存的菜品ID\",\"获取菜品口味列表，遍历列表，为菜品口味对象属性dishId赋值\",\"批量保存菜品口味列表\",\"代码实现:\",\"@Autowired private DishFlavorService dishFlavorService; /** * 新增菜品，同时保存对应的口味数据 * @param dishDto */ @Transactional public void saveWithFlavor(DishDto dishDto) { //保存菜品的基本信息到菜品表dish this.save(dishDto); Long dishId = dishDto.getId();//菜品id //菜品口味 List<DishFlavor> flavors = dishDto.getFlavors(); flavors = flavors.stream().map((item) -> { item.setDishId(dishId); return item; }).collect(Collectors.toList()); //保存菜品口味数据到菜品口味表dish_flavor dishFlavorService.saveBatch(flavors); } \",\"说明:\",\"​由于在 saveWithFlavor 方法中，进行了两次数据库的保存操作，操作了两张表，那么为了保证数据的一致性，需要在方法上加上注解 @Transactional来控制事务\",\"5.在引导类上加注解 @EnableTransactionManagement\",\"Service层方法上加的注解@Transactional要想生效，需要在引导类上加上注解 @EnableTransactionManagement， 开启对事务的支持\",\"@Slf4j @SpringBootApplication @ServletComponentScan @EnableTransactionManagement //开启对事物管理的支持 public class ReggieApplication { public static void main(String[] args) { SpringApplication.run(ReggieApplication.class,args); log.info(\\\"项目启动成功...\\\"); } } \"]},{\"header\":\"2.6 功能测试\",\"slug\":\"_2-6-功能测试\",\"contents\":[\"进行菜品的新增测试，在测试时，可以通过debug断点跟踪的形式，查看传输的数据，及数据的封装\",\"debug跟踪数据的封装情况:\",\"测试完毕后，可以检查一下数据库中的数据保存情况\"]},{\"header\":\"3. 菜品分页查询\",\"slug\":\"_3-菜品分页查询\",\"contents\":[]},{\"header\":\"3.1 需求分析\",\"slug\":\"_3-1-需求分析\",\"contents\":[\"在菜品列表展示时，除了菜品的基本信息(名称、售价、售卖状态、更新时间)外，还有两个字段略微特殊\",\"第一个是图片字段，从数据库查询出来的仅仅是图片的名字，图片要想在表格中回显展示出来，就需要下载这个图片 第二个是菜品分类，这里展示的是分类名称，而不是分类ID，此时就需要根据菜品的分类ID，去分类表中查询分类信息，然后在页面展示\"]},{\"header\":\"3.2 前端页面分析\",\"slug\":\"_3-2-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下菜品分页查询时前端页面和服务端的交互过程\",\"访问页面(backend/page/food/list.html)时，发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端，获取分页数据\",\"页面发送请求，请求服务端进行图片下载，用于页面图片展示\",\"开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可，而前端发起的请求中，图片文件下载回显的代码，已经实现了 所以，只需要开发分页查询的功能即可\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/dish/page\",\"请求参数\",\"?page=1&pageSize=10&name=xxx\"]},{\"header\":\"3.3 代码实现\",\"slug\":\"_3-3-代码实现\",\"contents\":[]},{\"header\":\"3.3.1 分析\",\"slug\":\"_3-3-1-分析\",\"contents\":[\"在 DishController 中开发方法，来完成菜品的条件分页查询，在分页查询时还需要给页面返回分类的名称，而分类的名称前端在接收的时候是通过 categoryName 属性获取的，那么对应的服务端也应该封装到 categoryName 属性中\",\"<el-table-column prop=\\\"categoryName\\\" label=\\\"菜品分类\\\"></el-table-column> \",\"而在的实体类 Dish 中，仅仅包含 categoryId， 不包含 categoryName，那么应该如何封装查询的数据呢？ 其实，这里可以返回DishDto对象，在该对象中可以拓展一个属性 categoryName，来封装菜品分类名称\",\"@Data public class DishDto extends Dish { private List<DishFlavor> flavors = new ArrayList<>(); private String categoryName; //菜品分类名称 private Integer copies; } \",\"具体逻辑\",\"构造分页条件对象\",\"构建查询及排序条件\",\"执行分页条件查询\",\"遍历分页查询列表数据，根据分类ID查询分类信息，从而获取该菜品的分类名称\",\"封装数据并返回\"]},{\"header\":\"3.3.2 实现\",\"slug\":\"_3-3-2-实现\",\"contents\":[\"/** * 菜品信息分页查询 * @param page * @param pageSize * @param name * @return */ @GetMapping(\\\"/page\\\") public R<Page> page(int page,int pageSize,String name){ //构造分页构造器对象 Page<Dish> pageInfo = new Page<>(page,pageSize); Page<DishDto> dishDtoPage = new Page<>(); //条件构造器 LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>(); //添加过滤条件 queryWrapper.like(name != null,Dish::getName,name); //添加排序条件 queryWrapper.orderByDesc(Dish::getUpdateTime); //执行分页查询 dishService.page(pageInfo,queryWrapper); //对象拷贝 BeanUtils.copyProperties(pageInfo,dishDtoPage,\\\"records\\\"); List<Dish> records = pageInfo.getRecords(); List<DishDto> list = records.stream().map((item) -> { DishDto dishDto = new DishDto(); BeanUtils.copyProperties(item,dishDto); Long categoryId = item.getCategoryId();//分类id //根据id查询分类对象 Category category = categoryService.getById(categoryId); if(category != null){ String categoryName = category.getName(); dishDto.setCategoryName(categoryName); } return dishDto; }).collect(Collectors.toList()); dishDtoPage.setRecords(list); return R.success(dishDtoPage); } \",\"数据库查询菜品信息时，获取到的分页查询结果 Page 的泛型为 Dish，而最终需要给前端页面返回的类型为 DishDto，所以这个时候就要进行转换，基本属性可以直接通过属性拷贝的形式对Page中的属性进行复制，而对于结果列表 records属性，是需要进行特殊处理的(需要封装菜品分类名称)\"]},{\"header\":\"3.4 功能测试\",\"slug\":\"_3-4-功能测试\",\"contents\":[\"代码编写完毕之后，重新启动服务，访问项目，可以通过debug端点的形式跟踪，整个分页查询过程中，数据的转换和封装\",\"在测试的过程中，发现有一些菜品图片并没有展示出来\",\"这是因为在导入sql脚本时，导入了一部分菜品的数据，而菜品的图片在的磁盘目录中并不存在，所以才会出现图片展示不出来的情况，而后续自己添加的菜品信息是没有问题的\"]},{\"header\":\"4. 菜品修改\",\"slug\":\"_4-菜品修改\",\"contents\":[]},{\"header\":\"4.1 需求分析\",\"slug\":\"_4-1-需求分析\",\"contents\":[\"在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击确定按钮完成修改操作\"]},{\"header\":\"4.2 前端页面分析\",\"slug\":\"_4-2-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下修改菜品时前端页面（add.html）和服务端的交互过程\",\"点击菜品列表的中的修改按钮，携带菜品id跳转至add.html\",\"进入add.html，页面发送ajax请求，请求服务端获取分类数据，用于菜品分类下拉框中数据展示(已实现)\",\"add.html获取id，发送ajax请求，请求服务端，根据id查询当前菜品信息，用于菜品信息回显\",\"页面发送请求，请求服务端进行图片下载，用于页图片回显(已实现)\",\"点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端\",\"经过上述的分析，发现，菜品分类下拉框的展示、图片的下载回显功能都已经实现了，只需要在这里实现两个功能即可，分别是：\",\"1.根据ID查询菜品及菜品口味信息\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/dish/\",\"2.修改菜品及菜品口味信息\",\"请求\",\"说明\",\"请求方式\",\"PUT\",\"请求路径\",\"/dish\",\"请求参数\",\"json格式数据\",\"具体的json格式数据，可以通过浏览器抓取\",\"{ \\\"id\\\":\\\"1422783914845487106\\\", \\\"name\\\":\\\"佛跳墙\\\", \\\"categoryId\\\":\\\"1397844357980663809\\\", \\\"price\\\":88800, \\\"code\\\":\\\"\\\", \\\"image\\\":\\\"da9e1c70-fc32-4781-9510-a1c4ccd2ff59.jpg\\\", \\\"description\\\":\\\"佛跳墙\\\", \\\"status\\\":1, \\\"sort\\\":0, \\\"createTime\\\":\\\"2021-08-04 12:58:14\\\", \\\"createUser\\\":\\\"1412578435737350122\\\", \\\"updateUser\\\":\\\"1412578435737350122\\\", \\\"flavors\\\":[ { \\\"id\\\":\\\"1422783914883235842\\\", \\\"dishId\\\":\\\"1422783914845487106\\\", \\\"name\\\":\\\"辣度\\\", \\\"value\\\":\\\"[\\\\\\\"不辣\\\\\\\",\\\\\\\"微辣\\\\\\\",\\\\\\\"中辣\\\\\\\",\\\\\\\"重辣\\\\\\\"]\\\", \\\"createTime\\\":\\\"2021-08-04 12:58:14\\\", \\\"updateTime\\\":\\\"2021-08-04 12:58:14\\\", \\\"createUser\\\":\\\"1412578435737350122\\\", \\\"updateUser\\\":\\\"1412578435737350122\\\", \\\"isDeleted\\\":0, \\\"showOption\\\":false }, { \\\"id\\\":\\\"1422783914895818754\\\", \\\"dishId\\\":\\\"1422783914845487106\\\", \\\"name\\\":\\\"忌口\\\", \\\"value\\\":\\\"[\\\\\\\"不要葱\\\\\\\",\\\\\\\"不要蒜\\\\\\\",\\\\\\\"不要香菜\\\\\\\",\\\\\\\"不要辣\\\\\\\"]\\\", \\\"createTime\\\":\\\"2021-08-04 12:58:14\\\", \\\"updateTime\\\":\\\"2021-08-04 12:58:14\\\", \\\"createUser\\\":\\\"1412578435737350122\\\", \\\"updateUser\\\":\\\"1412578435737350122\\\", \\\"isDeleted\\\":0, \\\"showOption\\\":false } ] } \"]},{\"header\":\"4.3 功能实现\",\"slug\":\"_4-3-功能实现\",\"contents\":[]},{\"header\":\"4.3.1 根据ID查询菜品信息\",\"slug\":\"_4-3-1-根据id查询菜品信息\",\"contents\":[]},{\"header\":\"4.3.1.1 代码实现\",\"slug\":\"_4-3-1-1-代码实现\",\"contents\":[\"页面发送ajax请求，请求服务端，根据id查询当前菜品信息和对应的口味信息，用于修改页面中菜品信息回显\",\"1.在DishService接口中扩展getByIdWithFlavor方法\",\"//根据id查询菜品信息和对应的口味信息 public DishDto getByIdWithFlavor(Long id); \",\"2.在DishService实现类中实现此方法\",\"具体逻辑\",\"根据ID查询菜品的基本信息\",\"根据菜品的ID查询菜品口味列表数据\",\"组装数据并返回\",\"代码实现:\",\"/** * 根据id查询菜品信息和对应的口味信息 * @param id * @return */ public DishDto getByIdWithFlavor(Long id) { //查询菜品基本信息，从dish表查询 Dish dish = this.getById(id); DishDto dishDto = new DishDto(); BeanUtils.copyProperties(dish,dishDto); //查询当前菜品对应的口味信息，从dish_flavor表查询 LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(DishFlavor::getDishId,dish.getId()); List<DishFlavor> flavors = dishFlavorService.list(queryWrapper); dishDto.setFlavors(flavors); return dishDto; } \",\"3.在DishController中创建get方法\",\"/** * 根据id查询菜品信息和对应的口味信息 * @param id * @return */ @GetMapping(\\\"/{id}\\\") public R<DishDto> get(@PathVariable Long id){ DishDto dishDto = dishService.getByIdWithFlavor(id); return R.success(dishDto); } \",\"@PathVariable : 该注解可以用来提取url路径中传递的请求参数\"]},{\"header\":\"4.3.1.2 功能测试\",\"slug\":\"_4-3-1-2-功能测试\",\"contents\":[\"编写完代码后，重启服务进行测试，点击列表的修改按钮，查询数据回显情况\"]},{\"header\":\"4.3.2 修改菜品信息\",\"slug\":\"_4-3-2-修改菜品信息\",\"contents\":[]},{\"header\":\"4.3.2.1 代码实现\",\"slug\":\"_4-3-2-1-代码实现\",\"contents\":[\"点击保存按钮，页面发送ajax请求，将修改后的菜品相关数据以json形式提交到服务端 在修改菜品信息时需要注意，除了要更新dish菜品表，还需要更新dish_flavor菜品口味表\",\"1.在DishService接口中扩展方法updateWithFlavor\",\"//更新菜品信息，同时更新对应的口味信息 public void updateWithFlavor(DishDto dishDto); \",\"2.在DishServiceImpl中实现方法updateWithFlavor\",\"在该方法中，既需要更新dish菜品基本信息表，还需要更新dish_flavor菜品口味表 而页面再操作时，关于菜品的口味，有修改，有新增，也有可能删除，应该如何更新菜品口味信息呢，其实，无论菜品口味信息如何变化，只需要保持一个原则：先删除，后添加\",\"@Override @Transactional public void updateWithFlavor(DishDto dishDto) { //更新dish表基本信息 this.updateById(dishDto); //清理当前菜品对应口味数据---dish_flavor表的delete操作 LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper(); queryWrapper.eq(DishFlavor::getDishId,dishDto.getId()); dishFlavorService.remove(queryWrapper); //添加当前提交过来的口味数据---dish_flavor表的insert操作 List<DishFlavor> flavors = dishDto.getFlavors(); flavors = flavors.stream().map((item) -> { item.setDishId(dishDto.getId()); return item; }).collect(Collectors.toList()); dishFlavorService.saveBatch(flavors); } \",\"3.在DishController中创建update方法\",\"/** * 修改菜品 * @param dishDto * @return */ @PutMapping public R<String> update(@RequestBody DishDto dishDto){ log.info(dishDto.toString()); dishService.updateWithFlavor(dishDto); return R.success(\\\"修改菜品成功\\\"); } \"]},{\"header\":\"4.3.2.2 功能测试\",\"slug\":\"_4-3-2-2-功能测试\",\"contents\":[\"代码编写完成之后，重启服务，然后按照前面分析的操作流程进行测试，查看数据是否正常修改即可\"]}]},\"/project/reggietakeout/01projectbasic/day05.html\":{\"title\":\"瑞吉外卖基础-Day05\",\"contents\":[{\"header\":\"1. 新增套餐\",\"slug\":\"_1-新增套餐\",\"contents\":[]},{\"header\":\"1.1 需求分析\",\"slug\":\"_1-1-需求分析\",\"contents\":[\"套餐就是菜品的集合\",\"后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐\"]},{\"header\":\"1.2 数据模型\",\"slug\":\"_1-2-数据模型\",\"contents\":[\"新增套餐，其实就是将新增页面录入的套餐信息插入到setmeal表，还需要向setmeal_dish表插入套餐和菜品关联数据 所以在新增套餐时，涉及到两个表\",\"表\",\"说明\",\"备注\",\"setmeal\",\"套餐表\",\"存储套餐的基本信息\",\"setmeal_dish\",\"套餐菜品关系表\",\"存储套餐关联的菜品的信息(一个套餐可以关联多个菜品)\",\"1.套餐表setmeal\",\"在该表中，套餐名称name字段是不允许重复的，在建表时已经创建了唯一索引\",\"2.套餐菜品关系表setmeal_dish\",\"在该表中，菜品的名称name，菜品的原价price 实际上都是冗余字段，因为在这张表中存储了菜品的ID(dish_id)，根据该ID就可以查询出name，price的数据信息，而这里又存储了name，price，这样的话，在后续的查询展示操作中，就不需要再去查询数据库获取菜品名称和原价了，这样可以简化操作\"]},{\"header\":\"1.3 准备工作\",\"slug\":\"_1-3-准备工作\",\"contents\":[\"在开发业务功能前，先将需要用到的类和接口基本结构创建好，在做这一块儿的准备工作时，无需准备Setmeal的相关实体类、Mapper接口、Service接口及实现，因为之前在做分类管理的时候，已经引入了Setmeal的相关基础代码\",\"1.实体类 SetmealDish\",\"所属包： com.itheima.reggie.entity\",\"import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import lombok.Data; import java.io.Serializable; import java.math.BigDecimal; import java.time.LocalDateTime; /** * 套餐菜品关系 */ @Data public class SetmealDish implements Serializable { private static final long serialVersionUID = 1L; private Long id; //套餐id private Long setmealId; //菜品id private Long dishId; //菜品名称 （冗余字段） private String name; //菜品原价 private BigDecimal price; //份数 private Integer copies; //排序 private Integer sort; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; //是否删除 private Integer isDeleted; } \",\"2.DTO SetmealDto\",\"该数据传输对象DTO，主要用于封装页面在新增套餐时传递过来的json格式的数据，其中包含套餐的基本信息，还包含套餐关联的菜品集合\",\"所属包： com.itheima.reggie.dto\",\"import com.itheima.reggie.entity.Setmeal; import com.itheima.reggie.entity.SetmealDish; import lombok.Data; import java.util.List; @Data public class SetmealDto extends Setmeal { private List<SetmealDish> setmealDishes;//套餐关联的菜品集合 private String categoryName;//分类名称 } \",\"3.Mapper接口 SetmealDishMapper\",\"所属包： com.itheima.reggie.mapper\",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.SetmealDish; import org.apache.ibatis.annotations.Mapper; @Mapper public interface SetmealDishMapper extends BaseMapper<SetmealDish> { } \",\"4.业务层接口 SetmealDishService\",\"所属包： com.itheima.reggie.service\",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.SetmealDish; public interface SetmealDishService extends IService<SetmealDish> { } \",\"5.业务层实现类 SetmealDishServiceImpl\",\"所属包： com.itheima.reggie.service.impl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.SetmealDish; import com.itheima.reggie.mapper.SetmealDishMapper; import com.itheima.reggie.service.SetmealDishService; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; @Service @Slf4j public class SetmealDishServiceImpl extends ServiceImpl<SetmealDishMapper,SetmealDish> implements SetmealDishService { } \",\"6.控制层 SetmealController\",\"套餐管理的相关业务，都统一在 SetmealController 中进行统一处理操作\",\"所属包： com.itheima.reggie.service.impl\",\"import com.itheima.reggie.service.SetmealDishService; import com.itheima.reggie.service.SetmealService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * 套餐管理 */ @RestController @RequestMapping(\\\"/setmeal\\\") @Slf4j public class SetmealController { @Autowired private SetmealService setmealService; @Autowired private SetmealDishService setmealDishService; } \"]},{\"header\":\"1.4 前端页面分析\",\"slug\":\"_1-4-前端页面分析\",\"contents\":[\"服务端的基础准备工作准备完毕之后，在进行代码开发之前，需要梳理一下新增套餐时前端页面和服务端的交互过程：\",\"点击新建套餐按钮，访问页面(backend/page/combo/add.html)，页面加载发送ajax请求，请求服务端获取套餐分类数据并展示到下拉框中(已实现)\",\"获取套餐分类列表的功能不用开发，之前已经开发完成了，之前查询时type传递的是1，查询菜品分类; 本次查询时，传递的type为2，查询套餐分类列表\",\"访问页面(backend/page/combo/add.html)，页面加载时发送ajax请求，请求服务端获取菜品分类数据并展示到添加菜品窗口中(已实现)\",\"本次查询分类列表，传递的type为1，表示需要查询的是菜品的分类 查询菜品分类的目的，是添加套餐关联的菜品时，需要根据菜品分类，来过滤查询菜品信息 查询菜品分类列表的代码已经实现， 具体展示效果如下：\",\"当点击添加菜品窗口左侧菜单的某一个分类，页面发送ajax请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中\",\"页面发送请求进行图片上传，请求服务端将图片保存到服务器(已实现)\",\"页面发送请求进行图片下载，将上传的图片进行回显(已实现)\",\"点击保存按钮，发送ajax请求，将套餐相关数据以json形式提交到服务端\",\"经过上述的页面解析及流程分析，发送这里需要发送的请求有5个，分别是 ：\",\"A. 根据传递的参数，查询套餐分类列表\",\"B. 根据传递的参数，查询菜品分类列表\",\"C. 图片上传\",\"D. 图片下载展示\",\"E. 根据菜品分类ID，查询菜品列表\",\"F. 保存套餐信息\",\"而对于以上的前4个功能都已经实现， 所以接下来需要开发的功能主要是最后两项， 具体的请求信息如下:\",\"1.根据分类ID查询菜品列表\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/dish/list\",\"请求参数\",\"?categoryId=1397844263642378242\",\"2.保存套餐信息\",\"请求\",\"说明\",\"请求方式\",\"POST\",\"请求路径\",\"/setmeal\",\"请求参数\",\"json格式数据\",\"传递的json格式数据如下:\",\"{ \\\"name\\\":\\\"营养超值工作餐\\\", \\\"categoryId\\\":\\\"1399923597874081794\\\", \\\"price\\\":3800, \\\"code\\\":\\\"\\\", \\\"image\\\":\\\"9cd7a80a-da54-4f46-bf33-af3576514cec.jpg\\\", \\\"description\\\":\\\"营养超值工作餐\\\", \\\"dishList\\\":[], \\\"status\\\":1, \\\"idType\\\":\\\"1399923597874081794\\\", \\\"setmealDishes\\\":[ {\\\"copies\\\":2,\\\"dishId\\\":\\\"1423329009705463809\\\",\\\"name\\\":\\\"米饭\\\",\\\"price\\\":200}, {\\\"copies\\\":1,\\\"dishId\\\":\\\"1423328152549109762\\\",\\\"name\\\":\\\"可乐\\\",\\\"price\\\":500}, {\\\"copies\\\":1,\\\"dishId\\\":\\\"1397853890262118402\\\",\\\"name\\\":\\\"鱼香肉丝\\\",\\\"price\\\":3800} ] } \"]},{\"header\":\"1.5 代码开发\",\"slug\":\"_1-5-代码开发\",\"contents\":[\"上面已经分析了接下来需要实现的两个功能，接下来就需要根据上述的分析，来完成具体的功能实现\"]},{\"header\":\"1.5.1 根据分类查询菜品\",\"slug\":\"_1-5-1-根据分类查询菜品\",\"contents\":[]},{\"header\":\"1.5.1.1 功能实现\",\"slug\":\"_1-5-1-1-功能实现\",\"contents\":[\"在当前的需求中，只需要根据页面传递的菜品分类的ID(categoryId)来查询菜品列表即可，可以直接定义一个DishController的方法，声明一个Long类型的categoryId，这样做是没问题的 但是考虑到该方法的拓展性，在这里定义方法时，通过Dish这个实体来接收参数\",\"在DishController中定义方法list，接收Dish类型的参数：\",\"在查询时，需要根据菜品分类categoryId进行查询，并且还要限定菜品的状态为起售状态(status为1)，然后对查询的结果进行排序\",\"/** * 根据条件查询对应的菜品数据 * @param dish * @return */ @GetMapping(\\\"/list\\\") public R<List<Dish>> list(Dish dish){ //构造查询条件 LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId()); //添加条件，查询状态为1（起售状态）的菜品 queryWrapper.eq(Dish::getStatus,1); //添加排序条件 queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime); List<Dish> list = dishService.list(queryWrapper); return R.success(list); } \"]},{\"header\":\"1.5.1.2 功能测试\",\"slug\":\"_1-5-1-2-功能测试\",\"contents\":[\"代码编写完毕，重新启动服务器，进行测试，可以通过debug断点跟踪的形式查看页面传递的参数封装情况，及响应给页面的数据信息\"]},{\"header\":\"1.5.2 保存套餐\",\"slug\":\"_1-5-2-保存套餐\",\"contents\":[]},{\"header\":\"1.5.2.1 功能实现\",\"slug\":\"_1-5-2-1-功能实现\",\"contents\":[\"在进行套餐信息保存时，前端提交的数据，不仅包含套餐的基本信息，还包含套餐关联的菜品列表数据 setmealDishes 所以这个时候使用Setmeal就不能完成参数的封装了，需要在Setmeal的基本属性的基础上，再扩充一个属性 setmealDishes 来接收页面传递的套餐关联的菜品列表，而在准备工作中，导入进来的SetmealDto能够满足这个需求\",\"1.SetmealController中定义方法save，新增套餐\",\"在该Controller的方法中，不仅需要保存套餐的基本信息，还需要保存套餐关联的菜品数据，所以需要再该方法中调用业务层方法，完成两块数据的保存\",\"页面传递的数据是json格式，需要在方法形参前面加上@RequestBody注解， 完成参数封装\",\"@PostMapping public R<String> save(@RequestBody SetmealDto setmealDto){ log.info(\\\"套餐信息：{}\\\",setmealDto); setmealService.saveWithDish(setmealDto); return R.success(\\\"新增套餐成功\\\"); } \",\"2.SetmealService中定义方法saveWithDish\",\"/** * 新增套餐，同时需要保存套餐和菜品的关联关系 * @param setmealDto */ public void saveWithDish(SetmealDto setmealDto); \",\"3.SetmealServiceImpl实现方法saveWithDish\",\"具体逻辑:\",\"A. 保存套餐基本信息\",\"B. 获取套餐关联的菜品集合，并为集合中的每一个元素赋值套餐ID(setmealId)\",\"C. 批量保存套餐关联的菜品集合\",\"代码实现:\",\"/** * 新增套餐，同时需要保存套餐和菜品的关联关系 * @param setmealDto */ @Transactional public void saveWithDish(SetmealDto setmealDto) { //保存套餐的基本信息，操作setmeal，执行insert操作 this.save(setmealDto); List<SetmealDish> setmealDishes = setmealDto.getSetmealDishes(); setmealDishes.stream().map((item) -> { item.setSetmealId(setmealDto.getId()); return item; }).collect(Collectors.toList()); //保存套餐和菜品的关联信息，操作setmeal_dish，执行insert操作 setmealDishService.saveBatch(setmealDishes); } \"]},{\"header\":\"1.5.2.2 功能测试\",\"slug\":\"_1-5-2-2-功能测试\",\"contents\":[\"代码编写完毕，重新启动服务器，进行测试，可以通过debug断点跟踪的形式查看页面传递的参数封装情况，及套餐相关数据的保存情况\",\"录入表单数据:\",\"debug跟踪数据封装:\",\"跟踪数据库保存的数据:\"]},{\"header\":\"2. 套餐分页查询\",\"slug\":\"_2-套餐分页查询\",\"contents\":[]},{\"header\":\"2.1 需求分析\",\"slug\":\"_2-1-需求分析\",\"contents\":[\"系统中的套餐数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据\",\"在进行套餐数据的分页查询时，除了传递分页参数以外，还可以传递一个可选的条件(套餐名称) 查询返回的字段中，包含套餐的基本信息之外，还有一个套餐的分类名称，在查询时，需要关联查询这个字段\"]},{\"header\":\"2.2 前端页面分析\",\"slug\":\"_2-2-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下套餐分页查询时前端页面和服务端的交互过程：\",\"访问页面(backend/page/combo/list.html)，页面加载时，会自动发送ajax请求，将分页查询参数(page、pageSize、name)提交到服务端，获取分页数据\",\"在列表渲染展示时，页面发送请求，请求服务端进行图片下载，用于页面图片展示(已实现)\",\"而对于以上的流程中涉及到2个功能，文件下载功能已经实现，本小节主要实现列表分页查询功能， 具体的请求信息如下:\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/setmeal/page\",\"请求参数\",\"?page=1&pageSize=10&name=xxx\"]},{\"header\":\"2.3 代码开发\",\"slug\":\"_2-3-代码开发\",\"contents\":[]},{\"header\":\"2.3.1 基本信息查询\",\"slug\":\"_2-3-1-基本信息查询\",\"contents\":[\"该方法的逻辑如下：\",\"构建分页条件对象\",\"构建查询条件对象，如果传递了套餐名称，根据套餐名称模糊查询， 并对结果按修改时间降序排序\",\"执行分页查询\",\"组装数据并返回\",\"代码实现 :\",\"/** * 套餐分页查询 * @param page * @param pageSize * @param name * @return */ @GetMapping(\\\"/page\\\") public R<Page> page(int page,int pageSize,String name){ //分页构造器对象 Page<Setmeal> pageInfo = new Page<>(page,pageSize); LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>(); //添加查询条件，根据name进行like模糊查询 queryWrapper.like(name != null,Setmeal::getName,name); //添加排序条件，根据更新时间降序排列 queryWrapper.orderByDesc(Setmeal::getUpdateTime); setmealService.page(pageInfo,queryWrapper); return R.success(pageInfo); } \"]},{\"header\":\"2.3.2 问题分析\",\"slug\":\"_2-3-2-问题分析\",\"contents\":[\"基本分页查询代码编写完毕后，重启服务，测试列表查询，发现， 列表页面的数据可以展示出来， 但是套餐分类名称没有展示出来\",\"这是因为在服务端仅返回分类ID(categoryId)， 而页面展示需要的是categoryName属性\"]},{\"header\":\"2.3.3 功能完善\",\"slug\":\"_2-3-3-功能完善\",\"contents\":[\"在查询套餐信息时， 只包含套餐的基本信息， 并不包含套餐的分类名称， 所以在这里查询到套餐的基本信息后， 还需要根据分类ID(categoryId)， 查询套餐分类名称(categoryName)，并最终将套餐的基本信息及分类名称信息封装到SetmealDto(在第一小节已经导入)中\",\"@Data public class SetmealDto extends Setmeal { private List<SetmealDish> setmealDishes; //套餐关联菜品列表 private String categoryName;//套餐分类名称 } \",\"完善后代码:\",\"/** * 套餐分页查询 * @param page * @param pageSize * @param name * @return */ @GetMapping(\\\"/page\\\") public R<Page> page(int page,int pageSize,String name){ //分页构造器对象 Page<Setmeal> pageInfo = new Page<>(page,pageSize); Page<SetmealDto> dtoPage = new Page<>(); LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>(); //添加查询条件，根据name进行like模糊查询 queryWrapper.like(name != null,Setmeal::getName,name); //添加排序条件，根据更新时间降序排列 queryWrapper.orderByDesc(Setmeal::getUpdateTime); setmealService.page(pageInfo,queryWrapper); //对象拷贝 BeanUtils.copyProperties(pageInfo,dtoPage,\\\"records\\\"); List<Setmeal> records = pageInfo.getRecords(); List<SetmealDto> list = records.stream().map((item) -> { SetmealDto setmealDto = new SetmealDto(); //对象拷贝 BeanUtils.copyProperties(item,setmealDto); //分类id Long categoryId = item.getCategoryId(); //根据分类id查询分类对象 Category category = categoryService.getById(categoryId); if(category != null){ //分类名称 String categoryName = category.getName(); setmealDto.setCategoryName(categoryName); } return setmealDto; }).collect(Collectors.toList()); dtoPage.setRecords(list); return R.success(dtoPage); } \"]},{\"header\":\"2.4 功能测试\",\"slug\":\"_2-4-功能测试\",\"contents\":[\"代码完善后，重启服务，测试列表查询，发现， 抓取浏览器的请求响应数据，可以获取到套餐分类名称categoryName，也可以在列表页面展示出来\"]},{\"header\":\"3. 删除套餐\",\"slug\":\"_3-删除套餐\",\"contents\":[]},{\"header\":\"3.1 需求分析\",\"slug\":\"_3-1-需求分析\",\"contents\":[\"在套餐管理列表页面，点击删除按钮，可以删除对应的套餐信息，也可以通过复选框选择多个套餐，点击批量删除按钮一次删除多个套餐 注意，对于状态为售卖中的套餐不能删除，需要先停售，然后才能删除\"]},{\"header\":\"3.2 前端页面分析\",\"slug\":\"_3-2-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下删除套餐时前端页面和服务端的交互过程：\",\"1.点击删除， 删除单个套餐时，页面发送ajax请求，根据套餐id删除对应套餐\",\"2.删除多个套餐时，页面发送ajax请求，根据提交的多个套餐id删除对应套餐\",\"开发删除套餐功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可，一次请求为根据ID删除，一次请求为根据ID批量删除\",\"观察删除单个套餐和批量删除套餐的请求信息可以发现，两种请求的地址和请求方式都是相同的，不同的则是传递的id个数，所以在服务端可以提供一个方法来统一处理\",\"具体的请求信息如下：\",\"请求\",\"说明\",\"请求方式\",\"DELETE\",\"请求路径\",\"/setmeal\",\"请求参数\",\"?ids=1423640210125656065,1423338765002256385\"]},{\"header\":\"3.3 代码开发\",\"slug\":\"_3-3-代码开发\",\"contents\":[\"在服务端的逻辑中，删除套餐时，不仅要删除套餐，还要删除套餐与菜品的关联关系\",\"1.在SetmealController中创建delete方法\",\"可以先测试在delete方法中接收页面提交的参数，具体逻辑后续再完善：\",\"/** * 删除套餐 * @param ids * @return */ @DeleteMapping public R<String> delete(@RequestParam List<Long> ids){ log.info(\\\"ids:{}\\\",ids); return R.success(\\\"套餐数据删除成功\\\"); } \",\"编写完代码，重启服务之后，访问套餐列表页面，勾选复选框，然后点击\\\"批量删除\\\"，可以看到服务端可以接收到集合参数ids，并且在控制台也可以输出对应的数据\",\"2.SetmealService接口定义方法removeWithDish\",\"/** * 删除套餐，同时需要删除套餐和菜品的关联数据 * @param ids */ public void removeWithDish(List<Long> ids); \",\"3.SetmealServiceImpl中实现方法removeWithDish\",\"该业务层方法具体的逻辑为:\",\"查询该批次套餐中是否存在售卖中的套餐，如果存在，不允许删除\",\"删除套餐数据\",\"删除套餐关联的菜品数据\",\"代码实现为:\",\"/** * 删除套餐，同时需要删除套餐和菜品的关联数据 * @param ids */ @Transactional public void removeWithDish(List<Long> ids) { //select count(*) from setmeal where id in (1，2，3) and status = 1 //查询套餐状态，确定是否可用删除 LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper(); queryWrapper.in(Setmeal::getId,ids); queryWrapper.eq(Setmeal::getStatus,1); int count = this.count(queryWrapper); if(count > 0){ //如果不能删除，抛出一个业务异常 throw new CustomException(\\\"套餐正在售卖中，不能删除\\\"); } //如果可以删除，先删除套餐表中的数据---setmeal this.removeByIds(ids); //delete from setmeal_dish where setmeal_id in (1，2，3) LambdaQueryWrapper<SetmealDish> lambdaQueryWrapper = new LambdaQueryWrapper<>(); lambdaQueryWrapper.in(SetmealDish::getSetmealId,ids); //删除关系表中的数据----setmeal_dish setmealDishService.remove(lambdaQueryWrapper); } \",\"由于当前的业务方法中存在多次数据库操作，为了保证事务的完整性，需要在方法上加注解 @Transactional 来控制事务\",\"4.完善SetmealController代码\",\"/** * 删除套餐 * @param ids * @return */ @DeleteMapping public R<String> delete(@RequestParam List<Long> ids){ log.info(\\\"ids:{}\\\",ids); setmealService.removeWithDish(ids); return R.success(\\\"套餐数据删除成功\\\"); } \"]},{\"header\":\"3.4 功能测试\",\"slug\":\"_3-4-功能测试\",\"contents\":[\"代码完善后，重启服务，测试套餐的删除功能，主要测试以下几种情况\",\"1.删除正在启用的套餐\",\"2.执行批量操作， 删除两条记录， 一个启售的， 一个停售的\",\"由于当前并未实现启售/停售功能，所以需要手动修改数据库表结构的status状态，将其中的一条记录status修改为0\",\"3.删除已经停售的套餐信息，执行删除之后， 检查数据库表结构 setmeal ， setmeal_dish表中的数据\"]},{\"header\":\"4. 短信发送\",\"slug\":\"_4-短信发送\",\"contents\":[]},{\"header\":\"4.1 短信服务介绍\",\"slug\":\"_4-1-短信服务介绍\",\"contents\":[\"在项目中，如果要实现短信发送功能，无需自己实现，也无需和运营商直接对接，只需要调用第三方提供的短信服务即可 目前市面上有很多第三方提供短信服务，这些第三方短信服务会和各个运营商（移动、联通、电信）对接，只需要注册成为会员，并且按照提供的开发文档进行调用就可以发送短信\",\"这些短信服务一般都是收费服务\",\"常用短信服务\",\"阿里云\",\"华为云\",\"腾讯云\",\"京东\",\"梦网\",\"乐信\"]},{\"header\":\"4.2 阿里云短信服务介绍\",\"slug\":\"_4-2-阿里云短信服务介绍\",\"contents\":[\"阿里云短信服务（Short Message Service）是广大企业客户快速触达手机用户所优选使用的通信能力，调用API或用群发助手，即可发送验证码、通知类和营销类短信\",\"国内验证短信秒级触达，到达率最高可达99% 国际/港澳台短信覆盖200多个国家和地区，安全稳定，广受出海企业选用\",\"应用场景\",\"场景\",\"案例\",\"验证码\",\"APP、网站注册账号，向手机下发验证码； 登录账户、异地登录时的安全提醒； 找回密码时的安全验证； 支付认证、身份校验、手机绑定等\",\"短信通知\",\"向注册用户下发系统相关信息，包括： 升级或维护、服务开通、价格调整、 订单确认、物流动态、消费确认、 支付通知等普通通知短信\",\"推广短信\",\"向注册用户和潜在客户发送通知和推广信息，包括促销活动通知、业务推广等商品与活动的推广信息，增加企业产品曝光率、提高产品的知名度\",\"阿里云短信服务官方网站：https://www.aliyun.com/product/sms?spm=5176.19720258.J_8058803260.52.5c432c4a11Dcwf\"]},{\"header\":\"4.3 阿里云短信服务准备\",\"slug\":\"_4-3-阿里云短信服务准备\",\"contents\":[]},{\"header\":\"4.3.1 注册账号\",\"slug\":\"_4-3-1-注册账号\",\"contents\":[\"阿里云官网：https://www.aliyun.com/\"]},{\"header\":\"4.3.2 开通短信服务\",\"slug\":\"_4-3-2-开通短信服务\",\"contents\":[\"登录后进入控制台，在左上角的菜单栏中搜索短信服务，第一次使用，需要点击并开通短信服务\"]},{\"header\":\"4.3.3 设置短信签名\",\"slug\":\"_4-3-3-设置短信签名\",\"contents\":[\"开通短信服务之后，进入短信服务管理页面，选择国内消息菜单，需要在这里添加短信签名\",\"什么是短信签名呢?\",\"短信签名是短信发送者的署名，表示发送方的身份，要调用阿里云短信服务发送短信，签名是比不可少的部分\",\"接下来添加短信签名\",\"注意：目前，阿里云短信服务申请签名主要针对企业开发，个人申请时有一定难度，审核时会审核资质，需要上传营业执照\"]},{\"header\":\"4.3.4 设置短信模板\",\"slug\":\"_4-3-4-设置短信模板\",\"contents\":[\"切换到【模板管理】标签页\",\"什么是模板呢?\",\"短信模板包含短信发送内容、场景、变量信息\",\"将${code}占位符替换成对应的验证码数据即可\",\"【xxxxx】您好，您的验证码为173822，5分钟之内有效，不要泄露给他人! \",\"可以点击右上角的按钮，添加模板，然后填写模板的基本信息及设置的模板内容\",\"添加的短信模板，也是需要进行审核的只有审核通过，才可以正常使用\"]},{\"header\":\"4.3.5 设置AccessKey\",\"slug\":\"_4-3-5-设置accesskey\",\"contents\":[\"AccessKey 是访问阿里云 API 的密钥，具有账户的完全权限，要想在后面通过API调用阿里云短信服务的接口发送短信，那么就必须要设置AccessKey\",\"点击右上角的用户头像，选择\\\"AccessKey管理\\\"\",\"进入到AccessKey的管理界面之后，提示两个选项 \\\"继续使用AccessKey\\\" 和 \\\"开始使用子用户AccessKey\\\"\",\"继续使用AccessKey\",\"如果选择的是该选项，创建的是阿里云账号的AccessKey，是具有账户的完全权限，有了这个AccessKey以后，就可以通过API调用阿里云的服务，不仅是短信服务，其他服务(OSS，语音服务，内容安全服务，视频点播服务等...)也可以调用 相对来说，并不安全，当前的AccessKey泄露，会影响到当前账户的其他云服务\",\"开始使用子用户AccessKey\",\"可以创建一个子用户，这个子用户可以分配比较低的权限，比如仅分配短信发送的权限，不具备操作其他的服务的权限，即使这个AccessKey泄漏了，也不会影响其他的云服务， 相对安全\",\"如何创建子用户AccessKey\"]},{\"header\":\"4.3.6 配置权限\",\"slug\":\"_4-3-6-配置权限\",\"contents\":[\"上述已经创建了子用户，但是这个子用户，目前没有任何权限，接下来，需要为创建的这个用户来分配权限\",\"经过上述的权限配置之后，那么新创建的这个 reggie 用户，仅有短信服务操作的权限，不具备别的权限\"]},{\"header\":\"4.3.7 禁用 / 删除AccessKey\",\"slug\":\"_4-3-7-禁用-删除accesskey\",\"contents\":[\"如果在使用的过程中 AccessKey 不小心泄漏了，可以在阿里云控制台中，禁用或者删除该AccessKey\",\"然后再创建一个新的AccessKey，保存好AccessKeyId和AccessKeySecret\",\"注意：创建好了AccessKey后，请及时保存AccessKeyId 和 AccessKeySecret ，弹窗关闭后将无法再次获取该信息，但您可以随时创建新的 AccessKey\"]},{\"header\":\"4.4 代码开发\",\"slug\":\"_4-4-代码开发\",\"contents\":[\"使用阿里云短信服务发送短信，可以参照官方提供的文档即可\",\"官方文档:https://help.aliyun.com/product/44282.html?spm=5176.12212571.help.dexternal.57a91cbewHHjKq\",\"根据官方文档的提示，引入对应的依赖，然后再引入对应的java代码，就可以发送消息了\",\"SDK : Software Development Kit 的缩写，翻译过来——软件开发工具包，辅助开发某一类软件的相关文档、范例和工具的集合都可以叫做SDK 在与第三方接口相互时， 一般都会提供对应的SDK，来简化的开发\",\"具体实现：\",\"1.pom.xml\",\"<dependency> <groupId>com.aliyun</groupId> <artifactId>aliyun-java-sdk-core</artifactId> <version>4.5.16</version> </dependency> <dependency> <groupId>com.aliyun</groupId> <artifactId>aliyun-java-sdk-dysmsapi</artifactId> <version>2.1.0</version> </dependency> \",\"2.将官方提供的main方法封装为一个工具类\",\"import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.IAcsClient; import com.aliyuncs.dysmsapi.model.v20170525.SendSmsRequest; import com.aliyuncs.dysmsapi.model.v20170525.SendSmsResponse; import com.aliyuncs.exceptions.ClientException; import com.aliyuncs.profile.DefaultProfile; /** * 短信发送工具类 */ public class SMSUtils { /** * 发送短信 * @param signName 签名 * @param templateCode 模板 * @param phoneNumbers 手机号 * @param param 参数 */ public static void sendMessage(String signName, String templateCode,String phoneNumbers,String param){ DefaultProfile profile = DefaultProfile.getProfile(\\\"cn-hangzhou\\\", \\\"xxxxxxxxxxxxxxxx\\\", \\\"xxxxxxxxxxxxxx\\\"); IAcsClient client = new DefaultAcsClient(profile); SendSmsRequest request = new SendSmsRequest(); request.setSysRegionId(\\\"cn-hangzhou\\\"); request.setPhoneNumbers(phoneNumbers); request.setSignName(signName); request.setTemplateCode(templateCode); request.setTemplateParam(\\\"{\\\\\\\"code\\\\\\\":\\\\\\\"\\\"+param+\\\"\\\\\\\"}\\\"); try { SendSmsResponse response = client.getAcsResponse(request); System.out.println(\\\"短信发送成功\\\"); }catch (ClientException e) { e.printStackTrace(); } } } \",\"备注 : 由于个人目前无法申请阿里云短信服务，所以这里只需要把流程跑通，具体的短信发送可以实现\"]},{\"header\":\"5. 手机验证码登录\",\"slug\":\"_5-手机验证码登录\",\"contents\":[]},{\"header\":\"5.1 需求分析\",\"slug\":\"_5-1-需求分析\",\"contents\":[\"手机验证码登录有如下优点\",\"方便快捷，无需注册，直接登录\",\"使用短信验证码作为登录凭证，无需记忆密码\",\"安全\",\"登录流程：\",\"输入手机号 > 获取验证码 > 输入验证码 > 点击登录 > 登录成功\",\"注意：通过手机验证码登录，手机号是区分不同用户的标识\"]},{\"header\":\"5.2 数据模型\",\"slug\":\"_5-2-数据模型\",\"contents\":[\"通过手机验证码登录时，涉及的表为user表，即用户表\"]},{\"header\":\"5.3 前端页面分析\",\"slug\":\"_5-3-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下登录时前端页面和服务端的交互过程：\",\"1.在登录页面(front/page/login.html)输入手机号，点击【获取验证码】按钮，页面发送ajax请求，在服务端调用短信服务API给指定手机号发送验证码短信\",\"2.在登录页面输入验证码，点击【登录】按钮，发送ajax请求，在服务端处理登录请求\",\"如果服务端返回的登录成功，页面将会把当前登录用户的手机号存储在sessionStorage中，并跳转到移动的首页页面\",\"开发手机验证码登录功能，其实就是在服务端编写代码去处理前端页面发送的这2次请求即可，分别是 获取短信验证码 和 登录请求\",\"1.获取短信验证码\",\"请求\",\"说明\",\"请求方式\",\"POST\",\"请求路径\",\"/user/sendMsg\",\"请求参数\",\"{\\\"phone\\\":\\\"13100001111\\\"}\",\"2.登录\",\"请求\",\"说明\",\"请求方式\",\"POST\",\"请求路径\",\"/user/login\",\"请求参数\",\"{\\\"phone\\\":\\\"13100001111\\\", \\\"code\\\":\\\"1111\\\"}\"]},{\"header\":\"5.4 代码开发\",\"slug\":\"_5-4-代码开发\",\"contents\":[]},{\"header\":\"5.4.1 准备工作\",\"slug\":\"_5-4-1-准备工作\",\"contents\":[\"在开发业务功能前，先将需要用到的类和接口基本结构创建好：\",\"1.实体类 User\",\"所属包： com.itheima.reggie.entity\",\"import lombok.Data; import java.io.Serializable; /** * 用户信息 */ @Data public class User implements Serializable { private static final long serialVersionUID = 1L; private Long id; //姓名 private String name; //手机号 private String phone; //性别 0 女 1 男 private String sex; //身份证号 private String idNumber; //头像 private String avatar; //状态 0:禁用，1:正常 private Integer status; } \",\"2.Mapper接口 UserMapper\",\"所属包： com.itheima.reggie.mapper\",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.User; import org.apache.ibatis.annotations.Mapper; @Mapper public interface UserMapper extends BaseMapper<User>{ } \",\"3.业务层接口 UserService\",\"所属包： com.itheima.reggie.service\",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.User; public interface UserService extends IService<User> { } \",\"4.业务层实现类 UserServiceImpl\",\"所属包： com.itheima.reggie.service.impl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.User; import com.itheima.reggie.mapper.UserMapper; import com.itheima.reggie.service.UserService; import org.springframework.stereotype.Service; @Service public class UserServiceImpl extends ServiceImpl<UserMapper,User> implements UserService{ } \",\"5.控制层 UserController\",\"所属包： com.itheima.reggie.controller\",\"import com.itheima.reggie.service.UserService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\\\"/user\\\") @Slf4j public class UserController { @Autowired private UserService userService; } \",\"6.工具类SMSUtils、ValidateCodeUtils（直接从课程资料中导入即可）\",\"所属包： com.itheima.reggie.utils\",\"SMSUtils : 是上面改造的阿里云短信发送的工具类 ValidateCodeUtils : 是验证码生成的工具类\"]},{\"header\":\"5.4.2 功能实现\",\"slug\":\"_5-4-2-功能实现\",\"contents\":[]},{\"header\":\"5.4.2.1 修改LoginCheckFilter\",\"slug\":\"_5-4-2-1-修改logincheckfilter\",\"contents\":[\"在进行手机验证码登录时，发送的两个请求(获取验证码和登录)需要在此过滤器处理时直接放行\",\"对于移动的端的页面，也是用户登录之后才可以访问，这个时候就需要在 LoginCheckFilter 中进行判定，如果移动端用户已登录，获取到用户登录信息，存入ThreadLocal中(在后续的业务处理中，如果需要获取当前登录用户ID，直接从ThreadLocal中获取)，然后放行\",\"//4-2、判断登录状态，如果已登录，则直接放行 if(request.getSession().getAttribute(\\\"user\\\") != null){ log.info(\\\"用户已登录，用户id为：{}\\\",request.getSession().getAttribute(\\\"user\\\")); Long userId = (Long) request.getSession().getAttribute(\\\"user\\\"); BaseContext.setCurrentId(userId); filterChain.doFilter(request,response); return; } \"]},{\"header\":\"5.4.2.2 发送短信验证码\",\"slug\":\"_5-4-2-2-发送短信验证码\",\"contents\":[\"在UserController中创建方法，处理登录页面的请求，为指定手机号发送短信验证码，同时需要将手机号对应的验证码保存到Session，方便后续登录时进行比对\",\"/** * 发送手机短信验证码 * @param user * @return */ @PostMapping(\\\"/sendMsg\\\") public R<String> sendMsg(@RequestBody User user, HttpSession session){ //获取手机号 String phone = user.getPhone(); if(StringUtils.isNotEmpty(phone)){ //生成随机的4位验证码 String code = ValidateCodeUtils.generateValidateCode(4).toString(); log.info(\\\"code={}\\\",code); //调用阿里云提供的短信服务API完成发送短信 //SMSUtils.sendMessage(\\\"瑞吉外卖\\\",\\\"\\\",phone,code); //需要将生成的验证码保存到Session session.setAttribute(phone,code); return R.success(\\\"手机验证码短信发送成功\\\"); } return R.error(\\\"短信发送失败\\\"); } \",\"备注:\",\"这里发送短信只需要调用封装的工具类中的方法即可，这个功能流程跑通，在测试中不用真正的发送短信，只需要将验证码信息，通过日志输出，登录时，直接从控制台就可以看到生成的验证码(实际上也就是发送到手机上的验证码)\"]},{\"header\":\"5.4.2.3 验证码登录\",\"slug\":\"_5-4-2-3-验证码登录\",\"contents\":[\"在UserController中增加登录的方法 login，该方法的具体逻辑为：\",\"获取前端传递的手机号和验证码\",\"从Session中获取到手机号对应的正确的验证码\",\"进行验证码的比对，如果比对失败，直接返回错误信息\",\"如果比对成功， 需要根据手机号查询当前用户，如果用户不存在，则自动注册一个新用户\",\"将登录用户的ID存储Session中\",\"具体代码实现:\",\"/** * 移动端用户登录 * @param map * @param session * @return */ @PostMapping(\\\"/login\\\") public R<User> login(@RequestBody Map map, HttpSession session){ log.info(map.toString()); //获取手机号 String phone = map.get(\\\"phone\\\").toString(); //获取验证码 String code = map.get(\\\"code\\\").toString(); //从Session中获取保存的验证码 Object codeInSession = session.getAttribute(phone); //进行验证码的比对（页面提交的验证码和Session中保存的验证码比对） if(codeInSession != null && codeInSession.equals(code)){ //如果能够比对成功，说明登录成功 LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(User::getPhone,phone); User user = userService.getOne(queryWrapper); if(user == null){ //判断当前手机号对应的用户是否为新用户，如果是新用户就自动完成注册 user = new User(); user.setPhone(phone); user.setStatus(1); userService.save(user); } session.setAttribute(\\\"user\\\",user.getId()); return R.success(user); } return R.error(\\\"登录失败\\\"); } \"]},{\"header\":\"5.5 功能测试\",\"slug\":\"_5-5-功能测试\",\"contents\":[\"重启服务，测试短信验证码的发送及登录功能\",\"1.测试错误验证码的情况\",\"2.测试正确验证码的情况\",\"检查user表\"]}]},\"/project/reggietakeout/01projectbasic/day06.html\":{\"title\":\"瑞吉外卖基础-Day06\",\"contents\":[{\"header\":\"1. 用户地址簿功能\",\"slug\":\"_1-用户地址簿功能\",\"contents\":[]},{\"header\":\"1.1 需求分析\",\"slug\":\"_1-1-需求分析\",\"contents\":[\"地址簿，指的是移动端消费者用户的地址信息，用户登录成功后可以维护自己的地址信息，同一个用户可以有多个地址信息，但是只能有一个默认地址\",\"对于地址簿管理，需要实现以下几个功能：\",\"新增地址\",\"地址列表查询\",\"设置默认地址\",\"编辑地址\",\"删除地址\"]},{\"header\":\"1.2 数据模型\",\"slug\":\"_1-2-数据模型\",\"contents\":[\"用户的地址信息会存储在address_book表，即地址簿表中，具体表结构如下\",\"这里面有一个字段is_default，实际上在设置默认地址时，只需要更新这个字段就可以了\"]},{\"header\":\"1.3 导入功能代码\",\"slug\":\"_1-3-导入功能代码\",\"contents\":[\"对于这一类的单表的增删改查，已经写过很多了，基本的开发思路都是一样的，那么本小节的用户地址簿管理的增删改查功能，就不再一一实现了，基本的代码都已经提供了，直接导入进来，做一个测试即可\",\"对于下面的地址管理的代码，可以直接从资料拷贝，也可以直接从下面的讲义中复制\",\"1.实体类 AddressBook（直接从课程资料中导入即可）\",\"所属包: com.itheima.reggie.entity\",\"import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import lombok.Data; import java.io.Serializable; import java.time.LocalDateTime; /** * 地址簿 */ @Data public class AddressBook implements Serializable { private static final long serialVersionUID = 1L; private Long id; //用户id private Long userId; //收货人 private String consignee; //手机号 private String phone; //性别 0 女 1 男 private String sex; //省级区划编号 private String provinceCode; //省级名称 private String provinceName; //市级区划编号 private String cityCode; //市级名称 private String cityName; //区级区划编号 private String districtCode; //区级名称 private String districtName; //详细地址 private String detail; //标签 private String label; //是否默认 0 否 1是 private Integer isDefault; //创建时间 @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; //更新时间 @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; //创建人 @TableField(fill = FieldFill.INSERT) private Long createUser; //修改人 @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; //是否删除 private Integer isDeleted; } \",\"2.Mapper接口 AddressBookMapper（直接从课程资料中导入即可）\",\"所属包: com.itheima.reggie.mapper\",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.AddressBook; import org.apache.ibatis.annotations.Mapper; import org.apache.ibatis.annotations.Select; import java.util.List; @Mapper public interface AddressBookMapper extends BaseMapper<AddressBook> { } \",\"3.业务层接口 AddressBookService（直接从课程资料中导入即可）\",\"所属包: com.itheima.reggie.service\",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.AddressBook; public interface AddressBookService extends IService<AddressBook> { } \",\"4.业务层实现类 AddressBookServiceImpl（直接从课程资料中导入即可）\",\"所属包: com.itheima.reggie.service.impl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.AddressBook; import com.itheima.reggie.mapper.AddressBookMapper; import com.itheima.reggie.service.AddressBookService; import org.springframework.stereotype.Service; @Service public class AddressBookServiceImpl extends ServiceImpl<AddressBookMapper, AddressBook> implements AddressBookService { } \",\"5.控制层 AddressBookController（直接从课程资料中导入即可）\",\"所属包: com.itheima.reggie.controller\",\"controller主要开发的功能:\",\"A. 新增地址逻辑说明：\",\"需要记录当前是哪个用户的地址(关联当前登录用户)\",\"B. 设置默认地址\",\"每个用户可以有很多地址，但是默认地址只能有一个 ；\",\"先将该用户所有地址的is_default更新为0， 然后将当前的设置的默认地址的is_default设置为1\",\"C. 根据ID查询地址\",\"D. 查询默认地址\",\"根据当前登录用户ID 以及 is_default进行查询，查询当前登录用户is_default为1的地址信息\",\"E. 查询指定用户的全部地址\",\"根据当前登录用户ID，查询所有的地址列表\",\"代码实现如下：\",\"import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper; import com.itheima.reggie.common.BaseContext; import com.itheima.reggie.common.R; import com.itheima.reggie.entity.AddressBook; import com.itheima.reggie.service.AddressBookService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; /** * 地址簿管理 */ @Slf4j @RestController @RequestMapping(\\\"/addressBook\\\") public class AddressBookController { @Autowired private AddressBookService addressBookService; /** * 新增 */ @PostMapping public R<AddressBook> save(@RequestBody AddressBook addressBook) { addressBook.setUserId(BaseContext.getCurrentId()); log.info(\\\"addressBook:{}\\\", addressBook); addressBookService.save(addressBook); return R.success(addressBook); } /** * 设置默认地址 */ @PutMapping(\\\"default\\\") public R<AddressBook> setDefault(@RequestBody AddressBook addressBook) { log.info(\\\"addressBook:{}\\\", addressBook); LambdaUpdateWrapper<AddressBook> wrapper = new LambdaUpdateWrapper<>(); wrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId()); wrapper.set(AddressBook::getIsDefault, 0); //SQL:update address_book set is_default = 0 where user_id = ? addressBookService.update(wrapper); addressBook.setIsDefault(1); //SQL:update address_book set is_default = 1 where id = ? addressBookService.updateById(addressBook); return R.success(addressBook); } /** * 根据id查询地址 */ @GetMapping(\\\"/{id}\\\") public R get(@PathVariable Long id) { AddressBook addressBook = addressBookService.getById(id); if (addressBook != null) { return R.success(addressBook); } else { return R.error(\\\"没有找到该对象\\\"); } } /** * 查询默认地址 */ @GetMapping(\\\"default\\\") public R<AddressBook> getDefault() { LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId()); queryWrapper.eq(AddressBook::getIsDefault, 1); //SQL:select * from address_book where user_id = ? and is_default = 1 AddressBook addressBook = addressBookService.getOne(queryWrapper); if (null == addressBook) { return R.error(\\\"没有找到该对象\\\"); } else { return R.success(addressBook); } } f /** * 查询指定用户的全部地址 */ @GetMapping(\\\"/list\\\") public R<List<AddressBook>> list(AddressBook addressBook) { addressBook.setUserId(BaseContext.getCurrentId()); log.info(\\\"addressBook:{}\\\", addressBook); //条件构造器 LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(null != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId()); queryWrapper.orderByDesc(AddressBook::getUpdateTime); //SQL:select * from address_book where user_id = ? order by update_time desc return R.success(addressBookService.list(queryWrapper)); } } \"]},{\"header\":\"1.4 功能测试\",\"slug\":\"_1-4-功能测试\",\"contents\":[\"代码导入进来，并且去阅读了一下地址管理各个功能的逻辑实现，接下来，就可以启动项目，进行一个测试 测试过程中，通过debug断点调试观察服务端程序的执行过程，在浏览器中使用调试工具查看页面和服务端的交互过程和请求响应数据\",\"1.新增\",\"填写表单数据，点击保存地址，查看网络请求\",\"测试完毕之后，检查数据库中的数据，是否正常插入\",\"2.列表查询\",\"当新增地址完成后，页面会再次发送一个请求，来查询该用户的所有地址列表，在界面进行展示\",\"3.设置默认\",\"在地址列表页面中，勾选 \\\"设为默认地址\\\" ，此时会发送PUT请求，来设置默认地址\",\"测试完毕后，再次查看数据库表中的数据：\"]},{\"header\":\"2. 菜品展示\",\"slug\":\"_2-菜品展示\",\"contents\":[]},{\"header\":\"2.1 需求分析\",\"slug\":\"_2-1-需求分析\",\"contents\":[\"用户登录成功后跳转到系统首页，在首页需要根据分类来展示菜品和套餐 如果菜品设置了口味信息，需要展示\",\"按钮，否则显示\",\"按钮\"]},{\"header\":\"2.2 前端页面分析\",\"slug\":\"_2-2-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下前端页面和服务端的交互过程：\",\"1.页面(front/index.html)发送ajax请求，获取分类数据（菜品分类和套餐分类）\",\"该功能在之前的业务开发中，都已经实现了 通过请求响应的数据，也可以看到数据是可以正确获取到的\",\"注意：首页加载时，不仅发送请求获取分类列表，还发送了一次ajax请求用于加载购物车数据，而这两次请求必须全部成功，页面才可以正常渲染，而当前购物车列表查询功能还未实现(报404)，所以列表目前并未渲染 此处可以将这次请求的地址暂时修改一下，从静态json文件获取数据，等后续开发购物车功能时再修改回来\",\"修改之后，再次测试：\",\"目前该部分的功能已经调通，左侧的分类菜单，和右侧的菜品信息都可以看到，后续只需要将购物车列表的数据改成调用服务端接口查询即可\",\"2.页面发送ajax请求，获取第一个分类下的菜品或者套餐\",\"A. 根据分类ID查询套餐列表：\",\"B. 根据分类ID查询菜品列表：\",\"异步请求，查询分类对应的菜品列表，功能已经实现了，但是之前查询的只是菜品的基本信息，不包含菜品的口味信息 所以在前端界面中，看不到选择菜品分类的信息\",\"经过上述的分析，可以看到，服务端主要提供两个方法， 分别用来：\",\"A. 根据分类ID查询菜品列表(包含菜品口味列表)， 具体请求信息如下:\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/dish/list\",\"请求参数\",\"?categoryId=1397844263642378242&status=1\",\"该功能在服务端已经实现，需要修改此方法，在原有方法的基础上增加查询菜品的口味信息\",\"B. 根据分类ID查询套餐列表， 具体请求信息如下:\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/setmeal/list\",\"请求参数\",\"?categoryId=1397844263642378242&status=1\",\"该功能在服务端并未实现\"]},{\"header\":\"2.3 代码开发\",\"slug\":\"_2-3-代码开发\",\"contents\":[]},{\"header\":\"2.3.1 查询菜品方法修改\",\"slug\":\"_2-3-1-查询菜品方法修改\",\"contents\":[\"由于之前实现的根据分类查询菜品列表，仅仅查询了菜品的基本信息，未查询菜品口味信息，而移动端用户在点餐时，是需要选择口味信息的，所以需要对之前的代码实现进行完善，那么如何完善呢？\",\"需要修改DishController的list方法，原来此方法的返回值类型为：R<List<Dish>> 为了满足移动端对数据的要求(菜品基本信息和菜品对应的口味信息)，现在需要将方法的返回值类型改为：R<List<DishDto>> ，因为在DishDto中封装了菜品对应的口味信息：\",\"代码逻辑:\",\"A. 根据分类ID查询，查询目前正在启售的菜品列表 (已实现)\",\"B. 遍历菜品列表，并查询菜品的分类信息及菜品的口味列表\",\"C. 组装数据DishDto，并返回\",\"代码实现：\",\"@GetMapping(\\\"/list\\\") public R<List<DishDto>> list(Dish dish){ //构造查询条件 LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId()); //添加条件，查询状态为1（起售状态）的菜品 queryWrapper.eq(Dish::getStatus,1); //添加排序条件 queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime); List<Dish> list = dishService.list(queryWrapper); List<DishDto> dishDtoList = list.stream().map((item) -> { DishDto dishDto = new DishDto(); BeanUtils.copyProperties(item,dishDto); Long categoryId = item.getCategoryId();//分类id //根据id查询分类对象 Category category = categoryService.getById(categoryId); if(category != null){ String categoryName = category.getName(); dishDto.setCategoryName(categoryName); } //当前菜品的id Long dishId = item.getId(); LambdaQueryWrapper<DishFlavor> lambdaQueryWrapper = new LambdaQueryWrapper<>(); lambdaQueryWrapper.eq(DishFlavor::getDishId,dishId); //SQL:select * from dish_flavor where dish_id = ? List<DishFlavor> dishFlavorList = dishFlavorService.list(lambdaQueryWrapper); dishDto.setFlavors(dishFlavorList); return dishDto; }).collect(Collectors.toList()); return R.success(dishDtoList); } \"]},{\"header\":\"2.3.2 根据分类ID查询套餐\",\"slug\":\"_2-3-2-根据分类id查询套餐\",\"contents\":[\"在SetmealController中创建list方法，根据条件查询套餐数据\",\"/** * 根据条件查询套餐数据 * @param setmeal * @return */ @GetMapping(\\\"/list\\\") public R<List<Setmeal>> list(Setmeal setmeal){ LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(setmeal.getCategoryId() != null,Setmeal::getCategoryId,setmeal.getCategoryId()); queryWrapper.eq(setmeal.getStatus() != null,Setmeal::getStatus,setmeal.getStatus()); queryWrapper.orderByDesc(Setmeal::getUpdateTime); List<Setmeal> list = setmealService.list(queryWrapper); return R.success(list); } \"]},{\"header\":\"2.4 功能测试\",\"slug\":\"_2-4-功能测试\",\"contents\":[\"把菜品展示的功能代码完善完成之后，重新启动服务，来测试一个菜品展示的功能 测试过程中可以使用浏览器的监控工具查看页面和服务端的数据交互细节\",\"点击分类，根据分类查询菜品列表/套餐列表:\"]},{\"header\":\"3. 购物车\",\"slug\":\"_3-购物车\",\"contents\":[]},{\"header\":\"3.1 需求分析\",\"slug\":\"_3-1-需求分析\",\"contents\":[\"移动端用户可以将菜品或者套餐添加到购物车 对于菜品来说，如果设置了口味信息，则需要选择规格后才能加入购物车;对于套餐来说，可以直接点击\",\"将当前套餐加入购物车 在购物车中可以修改菜品和套餐的数量，也可以清空购物车\",\"这里面需要实现的功能包括:\",\"添加购物车\",\"查询购物车\",\"清空购物车\"]},{\"header\":\"3.2 数据模型\",\"slug\":\"_3-2-数据模型\",\"contents\":[\"用户的购物车数据，也是需要保存在数据库中的，购物车对应的数据表为shopping_cart表，具体表结构如下：\",\"说明：\",\"购物车数据是关联用户的，在表结构中，需要记录，每一个用户的购物车数据是哪些\",\"菜品列表展示出来的既有套餐，又有菜品，如果APP端选择的是套餐，就保存套餐ID(setmeal_id)，如果APP端选择的是菜品，就保存菜品ID(dish_id)\",\"对同一个菜品/套餐，如果选择多份不需要添加多条记录，增加数量number即可\",\"最终shopping_cart表中存储的数据示例:\"]},{\"header\":\"3.3 前端页面分析\",\"slug\":\"_3-3-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下购物车操作时前端页面和服务端的交互过程：\",\"点击 \\\"加入购物车\\\" 或者 \\\"+\\\" 按钮，页面发送ajax请求，请求服务端，将菜品或者套餐添加到购物车\",\"点击购物车图标，页面发送ajax请求，请求服务端查询购物车中的菜品和套餐\",\"此时，就需要将查询购物车的代码放开，不用再加载静态的json数据了\",\"点击清空购物车按钮，页面发送ajax请求，请求服务端来执行清空购物车操作\",\"经过上述的分析，可以看到，对于购物车的功能，主要需要开发以下几个功能，具体的请求信息如下：\",\"1.加入购物车\",\"请求\",\"说明\",\"请求方式\",\"POST\",\"请求路径\",\"/shoppingCart/add\",\"请求参数\",\"json格式\",\"菜品数据: {\\\"amount\\\":118,\\\"dishFlavor\\\":\\\"不要蒜,微辣\\\",\\\"dishId\\\":\\\"1397851099502260226\\\",\\\"name\\\":\\\"全家福\\\",\\\"image\\\":\\\"a53a4e6a-3b83-4044-87f9-9d49b30a8fdc.jpg\\\"} 套餐数据: {\\\"amount\\\":38,\\\"setmealId\\\":\\\"1423329486060957698\\\",\\\"name\\\":\\\"营养超值工作餐\\\",\\\"image\\\":\\\"9cd7a80a-da54-4f46-bf33-af3576514cec.jpg\\\"} \",\"2.查询购物车列表\",\"请求\",\"说明\",\"请求方式\",\"GET\",\"请求路径\",\"/shoppingCart/list\",\"3.清空购物车功能\",\"请求\",\"说明\",\"请求方式\",\"DELETE\",\"请求路径\",\"/shoppingCart/clean\"]},{\"header\":\"3.4 准备工作\",\"slug\":\"_3-4-准备工作\",\"contents\":[\"分析完毕购物车的业务需求和实现思路之后，在开发业务功能前，先将需要用到的类和接口基本结构创建好：\",\"1.实体类 ShoppingCart（直接从课程资料中导入即可）\",\"所属包: com.itheima.reggie.entity\",\"import lombok.Data; import java.io.Serializable; import java.math.BigDecimal; import java.time.LocalDateTime; /** * 购物车 */ @Data public class ShoppingCart implements Serializable { private static final long serialVersionUID = 1L; private Long id; //名称 private String name; //用户id private Long userId; //菜品id private Long dishId; //套餐id private Long setmealId; //口味 private String dishFlavor; //数量 private Integer number; //金额 private BigDecimal amount; //图片 private String image; private LocalDateTime createTime; } \",\"2.Mapper接口 ShoppingCartMapper\",\"所属包: com.itheima.reggie.mapper\",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.ShoppingCart; import org.apache.ibatis.annotations.Mapper; @Mapper public interface ShoppingCartMapper extends BaseMapper<ShoppingCart> { } \",\"3.业务层接口 ShoppingCartService\",\"所属包: com.itheima.reggie.service\",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.ShoppingCart; public interface ShoppingCartService extends IService<ShoppingCart> { } \",\"4.业务层实现类 ShoppingCartServiceImpl\",\"所属包: com.itheima.reggie.service.impl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.ShoppingCart; import com.itheima.reggie.mapper.ShoppingCartMapper; import com.itheima.reggie.service.ShoppingCartService; import org.springframework.stereotype.Service; @Service public class ShoppingCartServiceImpl extends ServiceImpl<ShoppingCartMapper, ShoppingCart> implements ShoppingCartService { } \",\"5.控制层 ShoppingCartController\",\"所属包: com.itheima.reggie.controller\",\"import com.itheima.reggie.service.ShoppingCartService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * 购物车 */ @Slf4j @RestController @RequestMapping(\\\"/shoppingCart\\\") public class ShoppingCartController { @Autowired private ShoppingCartService shoppingCartService; } \"]},{\"header\":\"3.5 代码开发\",\"slug\":\"_3-5-代码开发\",\"contents\":[]},{\"header\":\"3.5.1 添加购物车\",\"slug\":\"_3-5-1-添加购物车\",\"contents\":[\"在ShoppingCartController中创建add方法，来完成添加购物车的逻辑实现，具体的逻辑如下：\",\"A. 获取当前登录用户，为购物车对象赋值\",\"B. 根据当前登录用户ID 及 本次添加的菜品ID/套餐ID，查询购物车数据是否存在\",\"C. 如果已经存在，就在原来数量基础上加1\",\"D. 如果不存在，则添加到购物车，数量默认就是1\",\"代码实现如下：\",\"/** * 添加购物车 * @param shoppingCart * @return */ @PostMapping(\\\"/add\\\") public R<ShoppingCart> add(@RequestBody ShoppingCart shoppingCart){ log.info(\\\"购物车数据:{}\\\",shoppingCart); //设置用户id，指定当前是哪个用户的购物车数据 Long currentId = BaseContext.getCurrentId(); shoppingCart.setUserId(currentId); Long dishId = shoppingCart.getDishId(); LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(ShoppingCart::getUserId,currentId); if(dishId != null){ //添加到购物车的是菜品 queryWrapper.eq(ShoppingCart::getDishId,dishId); }else{ //添加到购物车的是套餐 queryWrapper.eq(ShoppingCart::getSetmealId,shoppingCart.getSetmealId()); } //查询当前菜品或者套餐是否在购物车中 //SQL:select * from shopping_cart where user_id = ? and dish_id/setmeal_id = ? ShoppingCart cartServiceOne = shoppingCartService.getOne(queryWrapper); if(cartServiceOne != null){ //如果已经存在，就在原来数量基础上加一 Integer number = cartServiceOne.getNumber(); cartServiceOne.setNumber(number + 1); shoppingCartService.updateById(cartServiceOne); }else{ //如果不存在，则添加到购物车，数量默认就是一 shoppingCart.setNumber(1); shoppingCart.setCreateTime(LocalDateTime.now()); shoppingCartService.save(shoppingCart); cartServiceOne = shoppingCart; } return R.success(cartServiceOne); } \"]},{\"header\":\"3.5.2 查询购物车\",\"slug\":\"_3-5-2-查询购物车\",\"contents\":[\"在ShoppingCartController中创建list方法，根据当前登录用户ID查询购物车列表，并对查询的结果进行创建时间的倒序排序\",\"代码实现如下\",\"/** * 查看购物车 * @return */ @GetMapping(\\\"/list\\\") public R<List<ShoppingCart>> list(){ log.info(\\\"查看购物车...\\\"); LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId()); queryWrapper.orderByAsc(ShoppingCart::getCreateTime); List<ShoppingCart> list = shoppingCartService.list(queryWrapper); return R.success(list); } \"]},{\"header\":\"3.5.3 清空购物车\",\"slug\":\"_3-5-3-清空购物车\",\"contents\":[\"在ShoppingCartController中创建clean方法，在方法中获取当前登录用户，根据登录用户ID，删除购物车数据\",\"代码实现如下：\",\"/** * 清空购物车 * @return */ @DeleteMapping(\\\"/clean\\\") public R<String> clean(){ //SQL:delete from shopping_cart where user_id = ? LambdaQueryWrapper<ShoppingCart> queryWrapper = new LambdaQueryWrapper<>(); queryWrapper.eq(ShoppingCart::getUserId,BaseContext.getCurrentId()); shoppingCartService.remove(queryWrapper); return R.success(\\\"清空购物车成功\\\"); } \"]},{\"header\":\"3.6 功能测试\",\"slug\":\"_3-6-功能测试\",\"contents\":[\"按照前面分析的操作流程进行测试，测试功能以及数据库中的数据是否是否正常\",\"1.添加购物车\",\"当添加的是菜品信息，而这个用户的购物车中当前并没有这个菜品时，添加一条数据，数量为1\",\"检查数据库数据，由于是菜品保存的是dish_id\",\"这时在页面上，可以继续点击+号，在购物车中增加该菜品，此时，应该是对现有的购物车菜品数量加1，而不应该插入新的记录\",\"检查数据库数据：\",\"如果添加的是套餐，该套餐在当前用户的购物车中并不存在，则添加一条数据，数量为1\",\"检查数据库数据：\",\"2.查看购物车\",\"点击页面下面的购物车边栏，查看购物车数据列表是否正常展示\",\"3.清空购物车\",\"在购物车列表展示页中点击\\\"清空\\\"， 查看购物车是否被清空\",\"并检查数据库中的数据，可以看到数据已经被删除\"]},{\"header\":\"4. 下单\",\"slug\":\"_4-下单\",\"contents\":[]},{\"header\":\"4.1 需求分析\",\"slug\":\"_4-1-需求分析\",\"contents\":[\"移动端用户将菜品或者套餐加入购物车后，可以点击购物车中的 \\\"去结算\\\" 按钮，页面跳转到订单确认页面，点击 \\\"去支付\\\" 按钮则完成下单操作\",\"这里，需要说明一下，这里并不会去开发支付功能，因为不论是支付宝的支付，还是微信支付，都是需要企业资质的，而大家在测试的时候，是没有办法提供企业资质的，所以这一部分支付功能就不去实现了\"]},{\"header\":\"4.2 数据模型\",\"slug\":\"_4-2-数据模型\",\"contents\":[\"用户下单业务对应的数据表为orders表和order_detail表(一对多关系,一个订单关联多个订单明细)：\",\"表名\",\"含义\",\"说明\",\"orders\",\"订单表\",\"主要存储订单的基本信息(如: 订单号、状态、金额、支付方式、下单用户、收件地址等)\",\"order_detail\",\"订单明细表\",\"主要存储订单详情信息(如: 该订单关联的套餐及菜品的信息)\",\"具体的表结构如下:\",\"A.orders 订单表\",\"B.order_detail\",\"数据示例:\",\"用户提交订单时，需要往订单表orders中插入一条记录，并且需要往order_detail中插入一条或多条记录\"]},{\"header\":\"4.3 前端页面分析\",\"slug\":\"_4-3-前端页面分析\",\"contents\":[\"在开发代码之前，需要梳理一下用户下单操作时前端页面和服务端的交互过程：\",\"1.在购物车中点击\",\"按钮，页面跳转到订单确认页面**\",\"页面跳转前端已经完成，无需操作\",\"2.在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的默认地址\",\"该功能在用户地址簿管理功能开发时，已经实现(导入)，无需操作\",\"3.在订单确认页面，发送ajax请求，请求服务端获取当前登录用户的购物车数据\",\"该功能已经实现，无需操作\",\"**4. 在订单确认页面点击\",\"按钮，发送ajax请求，请求服务端完成下单操作**\",\"经过上述的分析，看到前三步的功能都已经实现了，主要需要实现最后一步的下单功能，该功能具体的请求信息如下：\",\"请求\",\"说明\",\"请求方式\",\"POST\",\"请求路径\",\"/order/submit\",\"请求参数\",\"{\\\"remark\\\":\\\"老板,记得带一次性筷子\\\",\\\"payMethod\\\":1,\\\"addressBookId\\\":\\\"1425792459560005634\\\"}\"]},{\"header\":\"4.4 准备工作\",\"slug\":\"_4-4-准备工作\",\"contents\":[\"在开发业务功能前，先将需要用到的类和接口基本结构创建好：\",\"1.实体类 Orders、OrderDetail（直接从课程资料中导入即可）\",\"所属包: com.itheima.reggie.entity\",\"import lombok.Data; import java.io.Serializable; import java.math.BigDecimal; import java.time.LocalDateTime; /** * 订单 */ @Data public class Orders implements Serializable { private static final long serialVersionUID = 1L; private Long id; //订单号 private String number; //订单状态 1待付款，2待派送，3已派送，4已完成，5已取消 private Integer status; //下单用户id private Long userId; //地址id private Long addressBookId; //下单时间 private LocalDateTime orderTime; //结账时间 private LocalDateTime checkoutTime; //支付方式 1微信，2支付宝 private Integer payMethod; //实收金额 private BigDecimal amount; //备注 private String remark; //用户名 private String userName; //手机号 private String phone; //地址 private String address; //收货人 private String consignee; } \",\"import lombok.Data; import java.io.Serializable; import java.math.BigDecimal; /** * 订单明细 */ @Data public class OrderDetail implements Serializable { private static final long serialVersionUID = 1L; private Long id; //名称 private String name; //订单id private Long orderId; //菜品id private Long dishId; //套餐id private Long setmealId; //口味 private String dishFlavor; //数量 private Integer number; //金额 private BigDecimal amount; //图片 private String image; } \",\"2.Mapper接口 OrderMapper、OrderDetailMapper\",\"所属包: com.itheima.reggie.mapper\",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.Orders; import org.apache.ibatis.annotations.Mapper; @Mapper public interface OrderMapper extends BaseMapper<Orders> { } \",\"import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.itheima.reggie.entity.OrderDetail; import org.apache.ibatis.annotations.Mapper; @Mapper public interface OrderDetailMapper extends BaseMapper<OrderDetail> { } \",\"3.业务层接口 OrderService、OrderDetailService\",\"所属包: com.itheima.reggie.service\",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.Orders; public interface OrderService extends IService<Orders> { } \",\"import com.baomidou.mybatisplus.extension.service.IService; import com.itheima.reggie.entity.OrderDetail; public interface OrderDetailService extends IService<OrderDetail> { } \",\"4.业务层实现类 OrderServiceImpl、OrderDetailServiceImpl\",\"所属包: com.itheima.reggie.service.impl\",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.*; import com.itheima.reggie.mapper.OrderMapper; import com.itheima.reggie.service.*; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Service; @Service @Slf4j public class OrderServiceImpl extends ServiceImpl<OrderMapper, Orders> implements OrderService { } \",\"import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl; import com.itheima.reggie.entity.OrderDetail; import com.itheima.reggie.mapper.OrderDetailMapper; import com.itheima.reggie.service.OrderDetailService; import org.springframework.stereotype.Service; @Service public class OrderDetailServiceImpl extends ServiceImpl<OrderDetailMapper, OrderDetail> implements OrderDetailService { } \",\"5.控制层 OrderController、OrderDetailController\",\"所属包: com.itheima.reggie.controller\",\"import com.itheima.reggie.service.OrderService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * 订单 */ @Slf4j @RestController @RequestMapping(\\\"/order\\\") public class OrderController { @Autowired private OrderService orderService; } \",\"import com.itheima.reggie.service.OrderDetailService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; /** * 订单明细 */ @Slf4j @RestController @RequestMapping(\\\"/orderDetail\\\") public class OrderDetailController { @Autowired private OrderDetailService orderDetailService; } \"]},{\"header\":\"4.5 代码开发\",\"slug\":\"_4-5-代码开发\",\"contents\":[\"在OrderController中创建submit方法，处理用户下单的逻辑 ：\",\"/** * 用户下单 * @param orders * @return */ @PostMapping(\\\"/submit\\\") public R<String> submit(@RequestBody Orders orders){ log.info(\\\"订单数据：{}\\\",orders); orderService.submit(orders); return R.success(\\\"下单成功\\\"); } \",\"由于下单的逻辑相对复杂，可以在OrderService中定义submit方法，来处理下单的具体逻辑：\",\"/** * 用户下单 * @param orders */ public void submit(Orders orders); \",\"然后在OrderServiceImpl中完成下单功能的具体实现，下单功能的具体逻辑如下：\",\"A. 获得当前用户id， 查询当前用户的购物车数据\",\"B. 根据当前登录用户id， 查询用户数据\",\"C. 根据地址ID， 查询地址数据\",\"D. 组装订单明细数据， 批量保存订单明细\",\"E. 组装订单数据， 批量保存订单数据\",\"F. 删除当前用户的购物车列表数据\",\"具体代码实现如下:\",\"@Autowired private ShoppingCartService shoppingCartService; @Autowired private UserService userService; @Autowired private AddressBookService addressBookService; @Autowired private OrderDetailService orderDetailService; /** * 用户下单 * @param orders */ @Transactional public void submit(Orders orders) { //获得当前用户id Long userId = BaseContext.getCurrentId(); //查询当前用户的购物车数据 LambdaQueryWrapper<ShoppingCart> wrapper = new LambdaQueryWrapper<>(); wrapper.eq(ShoppingCart::getUserId,userId); List<ShoppingCart> shoppingCarts = shoppingCartService.list(wrapper); if(shoppingCarts == null || shoppingCarts.size() == 0){ throw new CustomException(\\\"购物车为空，不能下单\\\"); } //查询用户数据 User user = userService.getById(userId); //查询地址数据 Long addressBookId = orders.getAddressBookId(); AddressBook addressBook = addressBookService.getById(addressBookId); if(addressBook == null){ throw new CustomException(\\\"用户地址信息有误，不能下单\\\"); } long orderId = IdWorker.getId();//订单号 AtomicInteger amount = new AtomicInteger(0); //组装订单明细信息 List<OrderDetail> orderDetails = shoppingCarts.stream().map((item) -> { OrderDetail orderDetail = new OrderDetail(); orderDetail.setOrderId(orderId); orderDetail.setNumber(item.getNumber()); orderDetail.setDishFlavor(item.getDishFlavor()); orderDetail.setDishId(item.getDishId()); orderDetail.setSetmealId(item.getSetmealId()); orderDetail.setName(item.getName()); orderDetail.setImage(item.getImage()); orderDetail.setAmount(item.getAmount()); amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue()); return orderDetail; }).collect(Collectors.toList()); //组装订单数据 orders.setId(orderId); orders.setOrderTime(LocalDateTime.now()); orders.setCheckoutTime(LocalDateTime.now()); orders.setStatus(2); orders.setAmount(new BigDecimal(amount.get()));//总金额 orders.setUserId(userId); orders.setNumber(String.valueOf(orderId)); orders.setUserName(user.getName()); orders.setConsignee(addressBook.getConsignee()); orders.setPhone(addressBook.getPhone()); orders.setAddress((addressBook.getProvinceName() == null ? \\\"\\\" : addressBook.getProvinceName()) + (addressBook.getCityName() == null ? \\\"\\\" : addressBook.getCityName()) + (addressBook.getDistrictName() == null ? \\\"\\\" : addressBook.getDistrictName()) + (addressBook.getDetail() == null ? \\\"\\\" : addressBook.getDetail())); //向订单表插入数据，一条数据 this.save(orders); //向订单明细表插入数据，多条数据 orderDetailService.saveBatch(orderDetails); //清空购物车数据 shoppingCartService.remove(wrapper); } \",\"备注:\",\"​上述逻辑处理中，计算购物车商品的总金额时，为保证每一次执行的累加计算是一个原子操作，这里用到了JDK中提供的一个原子类 AtomicInteger\"]},{\"header\":\"4.6 功能测试\",\"slug\":\"_4-6-功能测试\",\"contents\":[\"代码编写完成，重新启动服务，按照前面分析的操作流程进行测试，查看数据是否正常即可 在测试过程中，可以通过debug的形式来跟踪代码的正常执行\",\"检查数据库数据:\",\"订单表插入一条记录：\",\"订单明细表插入四条记录()：\",\"同时，购物车的数据被删除：\"]}]},\"/project/reggietakeout/02git/git01.html\":{\"title\":\"Git-Day01\",\"contents\":[]},\"/project/reggietakeout/03linux/day01.html\":{\"title\":\"Linux-Day01\",\"contents\":[]},\"/project/reggietakeout/03linux/day02.html\":{\"title\":\"Linux-Day02\",\"contents\":[]},\"/project/reggietakeout/04Redis/redis01.html\":{\"title\":\"Redis-Day01\",\"contents\":[]},\"/project/reggietakeout/05projectenhance/day01.html\":{\"title\":\"瑞吉外卖优化-Day01\",\"contents\":[]},\"/project/reggietakeout/05projectenhance/day02.html\":{\"title\":\"瑞吉外卖优化-Day02\",\"contents\":[]},\"/project/reggietakeout/05projectenhance/day03.html\":{\"title\":\"瑞吉外卖优化-Day03\",\"contents\":[]},\"/BackEnd/\":{\"title\":\"Back End\",\"contents\":[]},\"/ComputerBasics/\":{\"title\":\"Computer Basics\",\"contents\":[]},\"/Database/\":{\"title\":\"Database\",\"contents\":[]},\"/FrontEnd/\":{\"title\":\"Front End\",\"contents\":[]},\"/Others/\":{\"title\":\"Others\",\"contents\":[]},\"/Tools/\":{\"title\":\"Tools\",\"contents\":[]},\"/Database/Basic/\":{\"title\":\"Basic\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
