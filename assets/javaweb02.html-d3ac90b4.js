import{_ as o,W as n,X as s,Y as d,a0 as t,a2 as e,$ as i,Z as a,C as g}from"./framework-f482b5e1.js";const p="/assets/image-20220617224427947-553d0e6e.png",c="/assets/image-20221201224603497-d404437c.png",h="/assets/image-20220823200024507-682e7b23.png",l="/assets/image-20221202111044434-8ef95de2.png",f="/assets/image-20221202111307819-82e0603d.png",_="/assets/image-20220823202344149-ab49b71f.png",b="/assets/1530625192392-1a23c10d.png",m="/assets/image-20220824233614686-b4ae7226.png",u="/assets/image-20221202202305118-5eb89da1.png",x="/assets/image-20221202204013113-ae1f7e14.png",T="/assets/image-20221202204536647-a332d9ee.png",P="/assets/image-20221202205103486-1805f538.png",y="/assets/image-20221202205318778-43a2b7b0.png",v={},w=t("h1",{id:"http协议",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#http协议","aria-hidden":"true"},"#"),e(" HTTP协议")],-1),S=a('<p>SpringFramework中提供很多实用功能<br> 如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p><figure><img src="'+p+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_1-web分析" tabindex="-1"><a class="header-anchor" href="#_1-web分析" aria-hidden="true">#</a> 1. Web分析</h2><figure><img src="'+c+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-http协议" tabindex="-1"><a class="header-anchor" href="#_2-http协议" aria-hidden="true">#</a> 2. HTTP协议</h2><h3 id="_2-1-http-概述" tabindex="-1"><a class="header-anchor" href="#_2-1-http-概述" aria-hidden="true">#</a> 2.1 HTTP-概述</h3><p><strong>介绍</strong>:</p><figure><img src="'+h+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>HTTP：Hyper Text Transfer Protocol（ 超文本传输协议 ），规定了浏览器与服务器之间数据传输的规则。</p><p>浏览器向服务器进行请求时：</p><figure><img src="'+l+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>服务器向浏览器进行响应时：</p><figure><img src="'+f+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container note"><p class="hint-container-title">特点</p><p><strong>基于TCP协议:</strong> 面向连接，安全</p><p><strong>基于请求-响应模型:</strong> 一次请求对应一次响应（先请求后响应）</p><p><strong>HTTP协议是无状态协议:</strong> 对于数据没有记忆能力。每次请求-响应都是独立的</p></div><h3 id="_2-2-http-请求协议" tabindex="-1"><a class="header-anchor" href="#_2-2-http-请求协议" aria-hidden="true">#</a> 2.2 HTTP-请求协议</h3><p><strong>浏览器</strong>和<strong>服务器</strong>是按照HTTP协议进行数据通信的。</p><p>HTTP协议又分为：请求协议和响应协议</p><ul><li>请求协议：浏览器将数据以请求格式发送到服务器 <ul><li>包括：<strong>请求行</strong>、<strong>请求头</strong> 、<strong>请求体</strong></li></ul></li><li>响应协议：服务器将数据以响应格式返回给浏览器 <ul><li>包括：<strong>响应行</strong> 、<strong>响应头</strong> 、<strong>响应体</strong></li></ul></li></ul><p>GET请求和POST请求的区别：</p><table><thead><tr><th>区别方式</th><th>GET请求</th><th>POST请求</th></tr></thead><tbody><tr><td>请求参数</td><td>请求参数在请求行中。<br>例：/brand/findAll?name=OPPO&amp;status=1</td><td>请求参数在请求体中</td></tr><tr><td>请求参数长度</td><td>请求参数长度有限制(浏览器不同限制也不同)</td><td>请求参数长度没有限制</td></tr><tr><td>安全性</td><td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td><td>安全性相对高</td></tr></tbody></table><h3 id="_2-3-http-响应协议" tabindex="-1"><a class="header-anchor" href="#_2-3-http-响应协议" aria-hidden="true">#</a> 2.3 HTTP-响应协议</h3><p>与HTTP的请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong> 、<strong>响应体</strong></p><figure><img src="'+_+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p>',24),H={id:"响应状态码",tabindex:"-1"},z=t("a",{class:"header-anchor",href:"#响应状态码","aria-hidden":"true"},"#",-1),k={href:"https://cloud.tencent.com/developer/chapter/13553",target:"_blank",rel:"noopener noreferrer"},B=a('<table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong> --- 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td></tr><tr><td>2xx</td><td><strong>成功</strong> --- 表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong> --- 重定向到其它地方，让客户端再发起一个请求以完成整个处理</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong> --- 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong> --- 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><h2 id="_3-web服务器-tomcat" tabindex="-1"><a class="header-anchor" href="#_3-web服务器-tomcat" aria-hidden="true">#</a> 3. WEB服务器-Tomcat</h2><h3 id="_3-1-服务器概述" tabindex="-1"><a class="header-anchor" href="#_3-1-服务器概述" aria-hidden="true">#</a> 3.1 服务器概述</h3><p><strong>服务器硬件</strong>:</p><p>服务器是提供计算服务的设备。</p><p>服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。</p><p>在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p><p><strong>服务器软件</strong>:</p><p>基于ServerSocket编写的程序</p><ul><li>服务器软件本质是一个运行在服务器设备上的应用程序</li><li>能够接收客户端请求，并根据请求给客户端响应数据</li></ul><figure><img src="'+b+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="web服务器" tabindex="-1"><a class="header-anchor" href="#web服务器" aria-hidden="true">#</a> Web服务器</h4><p>Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装。主要功能是&quot;提供网上信息浏览服务&quot;。</p><figure><img src="'+m+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure>',14),W={id:"tomcat",tabindex:"-1"},E=t("a",{class:"header-anchor",href:"#tomcat","aria-hidden":"true"},"#",-1),N={href:"https://tomcat.apache.org/",target:"_blank",rel:"noopener noreferrer"},V=a('<p>Tomcat服务器软件是一个免费的开源的web应用服务器</p><p>因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。JavaWeb程序需要依赖Tomcat才能运行。</p><h3 id="_3-2-起步依赖" tabindex="-1"><a class="header-anchor" href="#_3-2-起步依赖" aria-hidden="true">#</a> 3.2 起步依赖</h3><figure><img src="'+u+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在SpringBoot的项目中，起步依赖有一个共同的特征：都是以<code>spring-boot-starter-</code>作为开头</p><div class="hint-container note"><p class="hint-container-title">起步依赖特殊之处</p><p>spring-boot-starter-web：包含了web应用开发所需要的常见依赖<br> spring-boot-starter-test：包含了单元测试所需要的常见依赖</p></div><p><strong>spring-boot-starter-web</strong>内部把关于Web开发所有的依赖都已经导入并且<strong>指定了版本</strong>，只需引入 <code>spring-boot-starter-web</code> 依赖就可以实现Web开发的需要的功能</p><figure><img src="'+x+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure>',8),q={href:"https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters",target:"_blank",rel:"noopener noreferrer"},C=a('<figure><img src="'+T+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每一个起步依赖，都用于开发一个特定的功能。</p><blockquote><p>举例：<br> 开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis ，即可导入redis开发所需要的依赖。</p></blockquote><h3 id="_3-3-springboot父工程" tabindex="-1"><a class="header-anchor" href="#_3-3-springboot父工程" aria-hidden="true">#</a> 3.3 SpringBoot父工程</h3><p>SpringBoot通过maven引入的依赖，是没有指定具体的依赖版本号的。</p><figure><img src="'+P+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为什么没有指定&lt;version&gt;版本号，可以正常使用呢？</p><ul><li>因为每一个SpringBoot工程，都有一个父工程。依赖的版本号，在父工程中统一管理。</li></ul><figure><img src="'+y+'" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure>',9);function O(j,G){const r=g("ExternalLinkIcon");return n(),s("div",null,[w,d(" more "),S,t("h4",H,[z,e(),t("a",k,[e("响应状态码"),i(r)])]),B,t("h4",W,[E,e(),t("a",N,[e("Tomcat"),i(r)])]),V,t("p",null,[t("a",q,[e("Spring官方"),i(r)]),e("提供了很多现成的starter(起步依赖)，开发相关应用时，只需要引入对应的starter即可。")]),C])}const J=o(v,[["render",O],["__file","javaweb02.html.vue"]]);export{J as default};
